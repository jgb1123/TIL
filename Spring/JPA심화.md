# JPA 심화
## API 설계 기본 원칙
### 입력을 엔티티가 아닌 DTO로 받기
* 입력값을 엔티티로 그대로 받으면, 다양한 문제가 생긴다.
  * 엔티티에 `@NotEmpty`와 같은 API검증 요구사항이 들어가서 유지보수가 힘들어진다.
  * 엔티티는 여러 API에서 참조되는데, 한 엔티티에 여러 API를 위한 모든 요구사항을 담기 어렵다.
  * 엔티티가 변경되면 API 스펙이 변한다.
* 따라서 API 요청 스펙에 맞는 별도의 DTO를 만들어 사용자입력을 바인딩하여 받는 것이 좋다.
### 응답을 엔티티가 아닌 DTO로 반환하기
* 엔티티를 직접 응답값으로 사용하면 다음과 같은 문제가 생긴다.
  * 엔티티의 모든 값이 노출되기 때문에, API에서는 스펙에 맞는 값만 응답하는 것이 좋다.
  * 응답 스펙을 맞추려면 `@JsonIgnore`와 같은 View로직이 엔티티에 들어와야 한다.
  * 엔티티는 여러 API에서 참조되는데, 한 엔티티에서 여러 API를 위한 View로직을 담기 어렵다.
  * 엔티티가 변경되면 API 스펙이 변한다.
  * 컬렉션의 경우 직접 반환하면 API 스펙을 변경하기 어려워지므로, 별도의 클래스로 감싸서 응답하는 것이 좋다.
### 결론
* DTO를 사용하여 엔티티를 외부에 노출하지 않는 것이 좋다.
* 사용자 입력을 받을때와 응답값을 반환할 때 모두 엔티티 대신 별도의 DTO를 사용하는 것이 좋다.

## X대일 연관관계 성능 최적화
* X대일 연관관계는 즉시 로딩으로 설정하면 항상 테이블에서 조인이 일어나서 성능 튜닝이 어려워지므로 지연 로딩으로 설정하는 것이 좋다.
* 기본값이 즉시 로딩이기 때문에, 직접 지연 로딩으로 수정해줘야 한다.

### 페치조인을 통한 N+1 문제 해결
* X대일 연관관계에서는 지연로딩으로 설정 하면 엔티티는 초기화되지 않은 프록시로 조회된다.
* 하지만 DTO로 변환하는 과정에서 프록시를 초기화하기 위해 추가 쿼리가 나가게 된다. ([이전 N+1 문제 참고](https://github.com/jgb1123/TIL/blob/main/Spring/JPQL.md))
* 페치 조인을 통해 해당 N+1 문제를 해결할 수 있다. 
  * 페치 조인은 엔티티에 설정한 글로벌 로딩 전략을 무시하고 연관된 엔티티를 즉시 로딩한다.
  * 즉시 로딩하기 때문에 프록시가 아닌 실제 엔티티를 조회한다.
  * 프록시가 아니기 때문에 DTO 변환과정에서 프록시를 초기화하면서 발생하는 N+1 문제 또한 발생하지 않는다.

### DTO 직접 조회
* 
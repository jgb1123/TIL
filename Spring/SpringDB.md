# Spring DataBase
## JDBC
### JDBC의 등장배경
* 클라이언트가 애플리케이션 서버를 통해 데이터를 저장하거나 조회를 한다.
* 예전에는 주로 TCP/IP를 사용해 커넥션을 연결하고, SQL을 연결된 커넥션을 통해 DB에 전달한 후, DB는 전달된 SQL을 수행하고 그 결과를 응답했다. 그리고 애플리케이션 서버는 그 응답 결과를 활용했다.
* 각각의 데이터베이스마다 커넥션 연결 방법, SQL 전달 방법, 응답을 받는 방법이 모두 달랐으며, 다른 종류의 데이터 베이스로 변경하려면 애플리케이션 서버에 개발된 데이터베이스 사용 코드도 함께 변경해야 했다.
* 개발자들은 각각의 데이터베이스마다의 커넥션 연결, SQL전달, 응답받는 방법을 새로 학습해야 했다.
* 이러한 문제를 해결하기위해 JDBC라는 자바 표준이 등장했다.

### JDBC 표준 인터페이스
* JDBC는 자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API이다.
* 데이터베이스에서 자료를 쿼리하거나 업데이트하는 방법을 제공한다.
* 표준 인터페이스를 정의해 두었고, 개발자들은 이 표준 인터페이스만 사용해서 개발하면 된다.
  * java.sql.Connection 연결
  * java.sql.Statement SQL을 담은 내용
  * java.sql.ResultSet SQL 요청 응답
* 이 JDBC 인터페이스를 각각의 DB벤더에서 각각의 DB에 맞도록 구현해서 라이브러리로 제공한다. (JDBC 드라이버)
  * ex) MySQL JDBC 드라이버, Oracle JDBC 드라이버

* 애플리케이션 로직은 이제 JDBC 표준 인터페이스에만 의존하므로, 데이터베이스를 다른 종류의 데이터 베이스로 변경하고 싶으면 JDBC 구현 라이브러리만 변경하면 된다. (사용 코드를 그대로 유지 가능)
* 개발자들은 **JDBC 표준 인터페이스 사용법만 학습**하면 되게 되었다.

### JDBC의 한계
* JDBC의 등장으로 많은 부분이 편해지긴 했지만, 데이터베이스마다의 SQL, 데이터 타입 등 일부 사용법이 달랐다. (일반적인 부분만 공통화 했기 때문에 한계가 있음)
* 데이터베이스를 변경하면 JDBC코드는 변경하지 않아도 되지만 SQL은 해당 데이터베이스에 맞도록 변경해야 한다.
  * JPA를 사용하면 이렇게 데이터베이스마다 다른 SQL을 정의해야 하는 문제도 많이 해결할 수 있다.

### JDBC와 데이터 접근 기술
1. 직접 JDBC 사용
   * 굉장히 오래된 기술이기 때문에 사용 방법도 복잡하다.

2. SQL Mapper
   * JDBC를 편리하게 사용하도록 도와준다. (장점)
     * SQL응답 결과를 객체로 편리하게 변환해준다.
     * JDBC의 반복 코드를 제거해준다.
   * 개발자가 SQL을 직접 작성해야 한다. (단점)
   * ex) JDBC Template, MyBatis

3. ORM 기술
   * ORM은 객체를 관계형 데이터베이스 테이블과 매핑해주는 기술이다.
   * 개발자는 반복적인 SQL을 직접 작성하지 않고 ORM기술이 개발자 대신 SQL을 동적으로 만들어 실행해준다.
     * 각각의 데이터베이스마다 다른 SQL을 사용하는 문제도 해결해준다.
   * ex) JPA, Hibernate, eclipselink
   > * JPA는 자바진영의 ORM 표준 인터페이스이고, 이것을 구현한 것으로 하이버네이트와 이클립스 링크 등의 구현 기술이 있다.
   > 
   > * 실무에서는 대부분 하이버네이트를 사용한다.

#### SQL Mapper vs ORM 기술
* SQL Mapper는 SQL만 작성할 줄 알면 금방 배워서 사용할 수 있다.
* ORM기술은 SQL자체를 작성하지 않아도 되서 개발 생산성이 높아진다. 하지만 쉬운 기술이 아니기 때문에 학습을 많이 해야 한다.
* 결국 이러한 다양한 기술들도 내부에서는 JDBC를 사용하기 때문에, JDBC를 직접 사용하지 않더라도 JDBC가 어떻게 동작하는지 기본원리는 알아야 한다.


### DriverManager
* JDBC가 제공하는 `DriverManager`는 라이브러리에 등록된 DB드라이버들을 관리하고 커넥션을 획득하는 기능을 한다.
* 애플리케이션 로직에서 커넥션이 필요하면 `DriverManager.getConnection()`을 호출한다
* `DriverManager`는 라이브러리에 등록된 드라이버 목록을 자동으로 인식한다.
* 이 드라이버들에게 순서대로 정보를 넘겨 커넥션을 획득할 수 있는지 확인한다.
  * URL (URL이 jdbc:h2로 시작하면 h2데이터베이스에 접근하기 위한 규칙임)
  * 이름, 비밀번호 등 접속에 필요한 추가 정보
* 만약 커넥션을 획득할 수 있는 경우 커넥션을 획득하고, 이 커넥션 구현체를 클라이언트에 반환한다.


### 커넥션 풀
#### 커넥션 획득 과정
* 애플리케이션 로직은 DB드라이버를 통해 커넥션을 조회한다.
* DB드라이버는 DB와 TCP/IP 커넥션을 연결한다. (3 way handshake같은 TCP/IP연결을 위한 네트워크 동작이 발생)
  > 3 way handshake
  >
  > TCP에서 통신을 하는 장치간 서로 연결이 잘 되어있는지 확인하는 과정이다.
  > 1. 클라이언트가 SYN(연결 요청 메시지)패킷 를 전송
  > 2. 서버가 SYN패킷을 받으면 응답으로 ACK(응답플래그)와 SYN 패킷을 전송
  > 3. 클라이언트는 받은 패킷에 대한 응답으로 ACK패킷을 보냄 (클라이언트는 연결된 상태가 됨)
  > 4. 서버는 ACK패킷을 받으면 연결된 상태가 된다.

* DB드라이버는 TCP/IP 커넥션이 연결되면 ID, Password와 같은 부가적인 정보들을 DB에 전달한다
* DB는 ID, Password를 통해 내부 인증을 완료하고 내부에 DB세션을 생성한다
* DB는 커넥션 생성이 완료되었다는 응답을 보낸다.
* DB드라이버는 커넥션 객체를 생성해서 클라이언트에 반환한다.

#### 커넥션 풀?
* DB와 애플리케이션 서버는 TCP/IP 커넥션을 새로 생성하기 위한 리소스를 매번 사용해야 한다.
* 결과적으로 DB를 사용할 때마다 SQL을 실행하는 시간 뿐만 아니라 커넥션을 새로 만드는 시간이 추가되기 때문에 응답속도에 영향을 주게 된다.
* 이러한 문제를 해결하기 위해 **커넥션을 미리 생성해두고 사용**하는 커넥션 풀이라는 방법을 이용한다.
* 애플리케이션 시작 시점에서 커넥션 풀은 필요한 만큼 커넥션을 미리 확보해서 보관한다. (최대 커넥션 수는 보통 기본 값은 10개이고, 설정을 통해 변경할 수 있음)
* 커넥션 풀에 들어있는 커넥션은 TCP/IP로 DB와 커넥션이 연결되어 있는 상태이므로, 즉시 SQL을 DB에 전달할 수 있게 된다.
* 애플리케이션 로직은 DB드라이버를 통해 새로운 커넥션을 획득하는게 아니라 커넥션 풀을 통해 이미 생성되어 있는 커넥션을 참조해서 쓰기만 하면된다.
  * 커넥션 풀에 커넥션을 요청하면 커넥션 풀에 저장된 커넥션 중 하나를 반환한다.
* 애플리케이션 로직은 커넥션 풀에서 받은 커넥션을 사용해 SQL을 DB에 전달하고 그 결과를 받아 이용한다.
* 만약 커넥션을 모두 사용하면 해당 커넥션은 종료되지 않는 상태로 커넥션을 다시 커넥션 풀에 반환한다. (다시 사용할 수 있어짐)
* 적절한 커넥션 풀 숫자는 서비스의 특징과 애플리케이션 서버 스펙, DB 서버 스펙에 따라 다르기 때문에 성능 테스트를 통해 정해야 한다.
* 커넥션 풀은 실무에서 항상 기본으로 사용하며, 대표적인 커넥션 풀 오픈소스는 commons-dbcp2, tomcat-jdbc pool, HikariCP 등이 있다.
  * 성능 및 편리함 때문에 보통 hikariCP를 사용하며, 스프링부트 2.0부터는 기본 커넥션풀로 hikariCP를 제공한다.

### DataSource
* 커넥션을 얻는 방법은 `DriverManager`를 직접 사용하거나, 커넥션 풀을 사용하는 등 다양한 방법이 존재한다.
* 하지만 `DriverManager`를 사용해 커넥션을 획득하다가 커넥션풀을 사용하도록 변경하면 커넥션을 획득하는 애플리케이션 코드도 함께 변경해야 한다.
* 이러한 문제를 해결하기 위해 javax.sql.DataSource라는 인터페이스를 제공한다.
* `DataSource`는 **커넥션을 획득하는 방법을 추상화하는 인터페이스**이다.
  * 다양한 기능이 있지만 핵심 기능은 **커넥션 조회**이다.
* 대부분의 커넥션 풀은 `DataSource` 인터페이스를 이미 구현해놓았기 때문에, `DataSource`인터페이스에만 의존하도록 애플리케이션 로직을 작성하면 된다.
  * 커넥션 풀 구현 기술을 변경하고 싶으면 해당 구현체로 바꾸기면 하면 된다. (DIP, OCP)
* `DriverManager`는 `DataSource`를 통해서 사용할 수 있도록 `DriverManagerDataSource`라는 `DataSource`를 구현한 클래스도 제공한다.
  * `DriverManagerDataSource`를 통해 `DriverManager`를 사용하다가 커넥션 풀을 사용하도록 코드를 변경해도 로직은 변경되지 않는다. (DIP, OCP)

#### DriverManager vs DataSource
* `DriverManager`는 커넥션을 획득할 때마다 같은 파라미터를 계속 전달해야 한다.
* `DataSource`는 객체를 처음 생성할 때만 필요한 파라미터를 넘겨두고, 커넥션을 획득할 때는 단순히 `getConnection()`만 호출하면 된다.
* `DataSource`의 경우, 필요한 데이터를 `DataSource`가 만들어지는 시점에 미리 다 넣어두게 되면 사용하는 곳에선 `getConnection()`만 호출하면 되므로 파라미터들에 의존하지 않아도 된다.
  * `DataSource`만 주입받아서 사용할 때 파라미터 없이 getConnection()만 호출하면 된다.
* 이로인해 객체를 설정하는 부분과 사용하는 부분을 분리할 수 있게 된다. 


## 트랜잭션
* 트랜잭션과 관련된 기본적인 개념은 [DataBase 공부](https://github.com/jgb1123/TIL/blob/main/Database/Database.md)에서 한번 정리한 적이 있다.
* 여기서 설명할 내용은 DB에서의 실제 동작 원리이다.


### 데이터베이스의 연결 구조
#### 세션
* 사용자는 웹 애플리케이션 서버나 DB접근 툴 같은 클라이언트를 사용해 데이터베이스 서버에 접근할 수 있다.
* 클라이언트는 데이터베이스 서버에 연결을 요청하고 커넥션을 맺게 된다.
* 이때 데이터베이스 서버는 내부에 세션이라는 것을 만들고, 앞으로 해당 커넥션을 통한 모든 요청은 이 세션을 통해서 실행하게 된다.
* 커넥션 풀의 개수만큼 새션이 만들어진다.
#### 데이터베이스 연결 구조
* 개발자가 클라이언트를 통해 SQL을 전달하면 현재 커넥션에 연결된 세션이 SQL을 실행한다.
* 세션은 트랜잭션을 시작하고, 커밋 또는 롤백을 통해 트랜잭션을 종료한다. (이후 새로운 트랜잭션 다시 시작 가능)
* 사용자가 커넥션을 닫거나 DBA(DB 관리자)가 세션을 강제로 종료하면 세션은 종료된다.

### 트랜잭션 사용
* 데이터 변경 쿼리를 실행하고 데이터베이스에 그 결과를 반영하려면 커밋 명령어인 commit을 호출하고, 반영하고 싶지 않으면 롤백 명령어인 rollback을 호출하면 된다.
* commit을 호출하기 전까지는 임시로 데이터를 저장한다.
* 해당 트랜잭션을 시작한 세션에게만 변경 데이터가 보이고, 다른 세션에게는 변경 데이터가 보이지 않는다. (격리수준 READ UNCOMMITTED에서는 보인다)
* 만약 commit을 호출하면 실제 데이터베이스에 반영되고, rollback을 호출하면 데이터베이스에 반영한 모든 데이터가 처음 상태로 복구된다.
> 트랜잭션 격리 수준
> 
> * ACID중 격리성(Isolation)으로 인해 성능이 매우 나빠질 수 있다.
> * 그래서 ANSI표준은 트랜잭션의 격리 수준을 4단계로 나누어 정의했다.
> 
>   * READ UNCOMMITTED 커밋되지 않은 읽기 (격리수준 가장 낮음)
>   * READ COMMITTED 커밋된 읽기
>   * REPEATABLE READ 반복 가능한 읽기
>   * SERIALIZABLE 직렬화 가능 (격리수준 가장 높음)
> * 보통 READ COMMITTED와 REPEATABLE READ 중에서 많이 사용한다.

### 자동커밋, 수동커밋
#### 자동커밋
* 기본이 자동커밋 모드이며, 자동커밋으로 설정하면 각각의 쿼리 실행 직후 자동으로 커밋을 호출한다.
* 커밋이나 롤백을 직접 호출하지 않아도 되는 편리함이 있지만, 쿼리를 하나하나 실행할때마다 자동으로 커밋 되어버리기 때문에 트랜잭션 기능을 사용할 수 없다.

#### 수동커밋
* 수동커밋 모드로 설정하는것을 트랜잭션을 시작한다고 표현할 수 있다. (자동커밋 모드가 기본으로 설정된 경우가 많기 때문)
* 수동커밋 설정을 하면 꼭 commit, rollback을 해야한다.
* 커밋 모드 설정은 한번 설정하면 해당 세션에서는 계속 유지되며, 중간에 변경할 수 있다.

### DB 락
* 아직 커밋이 수행되지 않았는데 다른 세션에서 동시에 같은 데이터를 수정하게 되면 트랜잭션의 원자성이 깨지게 된다.
* 또 그 상태에서 다시 롤백을 하게 되면 잘못된 데이터를 또 다시 수정하는 문제가 발생한다.
* 이러한 문제 때문에, 세션이 트랜잭션을 시작하고 데이터를 수정하는 동안에는 커밋이나 롤백 전까지 다른 세션에서 해당 데이터를 수정할 수 없게 막야아 한다.
* 데이터베이스는 이러한 문제를 해결하기 위해 락이라는 기능을 제공한다.
  * 트랜잭션 락은 데이터베이스마다 실제 동작방식이 조금 다를 수 있기 때문에 해당 데이터베이스 메뉴얼을 보고 테스트 한 이후에 사용해야 한다.
#### 동작 구조
* 세션 1이 데이터를 변경하려고 하면 해당 로우의 락을 먼저 획득해야 한다.
* 만약 이때 세션2에서도 해당 데이터를 변경하려고 락을 획득하려고 하면 락이 없으므로 락이 돌아올때까지 대기한다.
  * 락 대기시간을 넘어가면 락 타임아웃 오류가 발생하며, 이 락 대기시간은 설정할 수 있다.
* 세션 1이 커밋을 호출하면, 트랜잭션이 종료되었으므로 락도 반납한다.
* 락을 획득하기 위해 대기하던 세션2가 락을 획득한다.

#### 데이터 조회에서의 락
* 일반적인 조회는 락을 사용하지 않으며, 조회가 아니라 데이터를 변경하려면 락이 필요하다
* 데이터를 조회할 때도 락을 획득하고 싶으면, `select for update`구문을 사용하면 된다.
* 그러면 락을 가져오기 때문에, 다른 세션에서 해당 데이터를 변경할 수 없고, 이 경우도 트랜잭션을 커밋하면 락을 반납한다.
* 트랜잭션 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 막아야 할 때 사용한다.
  * 예를들면 데이터 조회를 먼저한 다음 해당 정보로 어떠한 계산을 수행해야 하는 상황이다. (그 사이에 데이터가 바뀌면 안됨)

### Spring에서의 트랜잭션
#### 트랜잭션 적용 구간
* 트랜잭션은 비즈니스 로직이 있는 서비스 계층에서 시작해야 한다.
    * 비즈니스 로직이 잘못되면 해당 비즈니스 로직으로 인해 문제가 되는 부분을 함께 롤백해야 하기 때문이다.
* 트랜잭션을 시작하려면 커넥션이 필요하므로, 서비스 계층에서 커넥션을 만들고 트랜잭션 커밋 이후 커넥션을 종료해야 한다.
* 애플리케이션에서 DB트랜잭션을 사용하려면 트랜잭션을 사용하는 동안 같은 커넥션을 유지해야 같은 세션을 사용할 수 있다.

#### Spring의 트랜잭션 추상화 인터페이스
* JDBC기술을 사용하다가 JPA기술로 변경 하는 등의 상황이 생기면 서비스 계층의 코드도 함께 수정되어야 한다.
* 이러한 문제를 해결하기 위해 트랜잭션 추상화 인터페이스를 이용하면 된다.
    * 트랜잭션은 트랜잭션을 시작하고, 비즈니스로직의 수행이 끝나면 커밋하거나 롤백하면 된다. (기능이 단순함)
* 아래와 같이 스프링이 제공하는 트랜잭션 추상화 기술을 사용하면 된다.
* `PlatformTransactionManager`
  * `getTransaction()` : 트랜잭션 시작
  * `commit()` : 트랜잭션 커밋
  * `rollback()` : 트랜잭션 롤백
* 데이터 접근 기술에 따른 트랜잭션 구현체도 대부분 만들어져 있기 때문에, 그냥 가져와서 사용하기만 하면 된다.
  * ex) `DataSourceTransactionManager`, `JpaTransactionManage`, `HibernateTransactionManage` 등

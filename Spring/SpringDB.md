# Spring DataBase
## JDBC
### JDBC의 등장배경
* 클라이언트가 애플리케이션 서버를 통해 데이터를 저장하거나 조회를 한다.
* 예전에는 주로 TCP/IP를 사용해 커넥션을 연결하고, SQL을 연결된 커넥션을 통해 DB에 전달한 후, DB는 전달된 SQL을 수행하고 그 결과를 응답했다. 그리고 애플리케이션 서버는 그 응답 결과를 활용했다.
* 각각의 데이터베이스마다 커넥션 연결 방법, SQL 전달 방법, 응답을 받는 방법이 모두 달랐으며, 다른 종류의 데이터 베이스로 변경하려면 애플리케이션 서버에 개발된 데이터베이스 사용 코드도 함께 변경해야 했다.
* 개발자들은 각각의 데이터베이스마다의 커넥션 연결, SQL전달, 응답받는 방법을 새로 학습해야 했다.
* 이러한 문제를 해결하기위해 JDBC라는 자바 표준이 등장했다.

### JDBC 표준 인터페이스
* JDBC는 자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API이다.
* 데이터베이스에서 자료를 쿼리하거나 업데이트하는 방법을 제공한다.
* 표준 인터페이스를 정의해 두었고, 개발자들은 이 표준 인터페이스만 사용해서 개발하면 된다.
  * java.sql.Connection 연결
  * java.sql.Statement SQL을 담은 내용
  * java.sql.ResultSet SQL 요청 응답
* 이 JDBC 인터페이스를 각각의 DB벤더에서 각각의 DB에 맞도록 구현해서 라이브러리로 제공한다. (JDBC 드라이버)
  * ex) MySQL JDBC 드라이버, Oracle JDBC 드라이버

* 애플리케이션 로직은 이제 JDBC 표준 인터페이스에만 의존하므로, 데이터베이스를 다른 종류의 데이터 베이스로 변경하고 싶으면 JDBC 구현 라이브러리만 변경하면 된다. (사용 코드를 그대로 유지 가능)
* 개발자들은 **JDBC 표준 인터페이스 사용법만 학습**하면 되게 되었다.

### JDBC의 한계
* JDBC의 등장으로 많은 부분이 편해지긴 했지만, 데이터베이스마다의 SQL, 데이터 타입 등 일부 사용법이 달랐다. (일반적인 부분만 공통화 했기 때문에 한계가 있음)
* 데이터베이스를 변경하면 JDBC코드는 변경하지 않아도 되지만 SQL은 해당 데이터베이스에 맞도록 변경해야 한다.
  * JPA를 사용하면 이렇게 데이터베이스마다 다른 SQL을 정의해야 하는 문제도 많이 해결할 수 있다.

### JDBC와 데이터 접근 기술
1. 직접 JDBC 사용
   * 굉장히 오래된 기술이기 때문에 사용 방법도 복잡하다.

2. SQL Mapper
   * JDBC를 편리하게 사용하도록 도와준다. (장점)
     * SQL응답 결과를 객체로 편리하게 변환해준다.
     * JDBC의 반복 코드를 제거해준다.
   * 개발자가 SQL을 직접 작성해야 한다. (단점)
   * ex) JDBC Template, MyBatis

3. ORM 기술
   * ORM은 객체를 관계형 데이터베이스 테이블과 매핑해주는 기술이다.
   * 개발자는 반복적인 SQL을 직접 작성하지 않고 ORM기술이 개발자 대신 SQL을 동적으로 만들어 실행해준다.
     * 각각의 데이터베이스마다 다른 SQL을 사용하는 문제도 해결해준다.
   * ex) JPA, Hibernate, eclipselink
   > * JPA는 자바진영의 ORM 표준 인터페이스이고, 이것을 구현한 것으로 하이버네이트와 이클립스 링크 등의 구현 기술이 있다.
   > 
   > * 실무에서는 대부분 하이버네이트를 사용한다.

#### SQL Mapper vs ORM 기술
* SQL Mapper는 SQL만 작성할 줄 알면 금방 배워서 사용할 수 있다.
* ORM기술은 SQL자체를 작성하지 않아도 되서 개발 생산성이 높아진다. 하지만 쉬운 기술이 아니기 때문에 학습을 많이 해야 한다.
* 결국 이러한 다양한 기술들도 내부에서는 JDBC를 사용하기 때문에, JDBC를 직접 사용하지 않더라도 JDBC가 어떻게 동작하는지 기본원리는 알아야 한다.


### DriverManager
* JDBC가 제공하는 `DriverManager`는 라이브러리에 등록된 DB드라이버들을 관리하고 커넥션을 획득하는 기능을 한다.
* 애플리케이션 로직에서 커넥션이 필요하면 `DriverManager.getConnection()`을 호출한다
* `DriverManager`는 라이브러리에 등록된 드라이버 목록을 자동으로 인식한다.
* 이 드라이버들에게 순서대로 정보를 넘겨 커넥션을 획득할 수 있는지 확인한다.
  * URL (URL이 jdbc:h2로 시작하면 h2데이터베이스에 접근하기 위한 규칙임)
  * 이름, 비밀번호 등 접속에 필요한 추가 정보
* 만약 커넥션을 획득할 수 있는 경우 커넥션을 획득하고, 이 커넥션 구현체를 클라이언트에 반환한다.


### 커넥션 풀
#### 커넥션 획득 과정
* 애플리케이션 로직은 DB드라이버를 통해 커넥션을 조회한다.
* DB드라이버는 DB와 TCP/IP 커넥션을 연결한다. (3 way handshake같은 TCP/IP연결을 위한 네트워크 동작이 발생)
  > 3 way handshake
  >
  > TCP에서 통신을 하는 장치간 서로 연결이 잘 되어있는지 확인하는 과정이다.
  > 1. 클라이언트가 SYN(연결 요청 메시지)패킷 를 전송
  > 2. 서버가 SYN패킷을 받으면 응답으로 ACK(응답플래그)와 SYN 패킷을 전송
  > 3. 클라이언트는 받은 패킷에 대한 응답으로 ACK패킷을 보냄 (클라이언트는 연결된 상태가 됨)
  > 4. 서버는 ACK패킷을 받으면 연결된 상태가 된다.

* DB드라이버는 TCP/IP 커넥션이 연결되면 ID, Password와 같은 부가적인 정보들을 DB에 전달한다
* DB는 ID, Password를 통해 내부 인증을 완료하고 내부에 DB세션을 생성한다
* DB는 커넥션 생성이 완료되었다는 응답을 보낸다.
* DB드라이버는 커넥션 객체를 생성해서 클라이언트에 반환한다.

#### 커넥션 풀?
* DB와 애플리케이션 서버는 TCP/IP 커넥션을 새로 생성하기 위한 리소스를 매번 사용해야 한다.
* 결과적으로 DB를 사용할 때마다 SQL을 실행하는 시간 뿐만 아니라 커넥션을 새로 만드는 시간이 추가되기 때문에 응답속도에 영향을 주게 된다.
* 이러한 문제를 해결하기 위해 **커넥션을 미리 생성해두고 사용**하는 커넥션 풀이라는 방법을 이용한다.
* 애플리케이션 시작 시점에서 커넥션 풀은 필요한 만큼 커넥션을 미리 확보해서 보관한다. (최대 커넥션 수는 보통 기본 값은 10개이고, 설정을 통해 변경할 수 있음)
* 커넥션 풀에 들어있는 커넥션은 TCP/IP로 DB와 커넥션이 연결되어 있는 상태이므로, 즉시 SQL을 DB에 전달할 수 있게 된다.
* 애플리케이션 로직은 DB드라이버를 통해 새로운 커넥션을 획득하는게 아니라 커넥션 풀을 통해 이미 생성되어 있는 커넥션을 참조해서 쓰기만 하면된다.
  * 커넥션 풀에 커넥션을 요청하면 커넥션 풀에 저장된 커넥션 중 하나를 반환한다.
* 애플리케이션 로직은 커넥션 풀에서 받은 커넥션을 사용해 SQL을 DB에 전달하고 그 결과를 받아 이용한다.
* 만약 커넥션을 모두 사용하면 해당 커넥션은 종료되지 않는 상태로 커넥션을 다시 커넥션 풀에 반환한다. (다시 사용할 수 있어짐)
* 적절한 커넥션 풀 숫자는 서비스의 특징과 애플리케이션 서버 스펙, DB 서버 스펙에 따라 다르기 때문에 성능 테스트를 통해 정해야 한다.
* 커넥션 풀은 실무에서 항상 기본으로 사용하며, 대표적인 커넥션 풀 오픈소스는 commons-dbcp2, tomcat-jdbc pool, HikariCP 등이 있다.
  * 성능 및 편리함 때문에 보통 hikariCP를 사용하며, 스프링부트 2.0부터는 기본 커넥션풀로 hikariCP를 제공한다.

### DataSource
* 커넥션을 얻는 방법은 `DriverManager`를 직접 사용하거나, 커넥션 풀을 사용하는 등 다양한 방법이 존재한다.
* 하지만 `DriverManager`를 사용해 커넥션을 획득하다가 커넥션풀을 사용하도록 변경하면 커넥션을 획득하는 애플리케이션 코드도 함께 변경해야 한다.
* 이러한 문제를 해결하기 위해 javax.sql.DataSource라는 인터페이스를 제공한다.
* `DataSource`는 **커넥션을 획득하는 방법을 추상화하는 인터페이스**이다.
  * 다양한 기능이 있지만 핵심 기능은 **커넥션 조회**이다.
* 대부분의 커넥션 풀은 `DataSource` 인터페이스를 이미 구현해놓았기 때문에, `DataSource`인터페이스에만 의존하도록 애플리케이션 로직을 작성하면 된다.
  * 커넥션 풀 구현 기술을 변경하고 싶으면 해당 구현체로 바꾸기면 하면 된다. (DIP, OCP)
* `DriverManager`는 `DataSource`를 통해서 사용할 수 있도록 `DriverManagerDataSource`라는 `DataSource`를 구현한 클래스도 제공한다.
  * `DriverManagerDataSource`를 통해 `DriverManager`를 사용하다가 커넥션 풀을 사용하도록 코드를 변경해도 로직은 변경되지 않는다. (DIP, OCP)

#### DriverManager vs DataSource
* `DriverManager`는 커넥션을 획득할 때마다 같은 파라미터를 계속 전달해야 한다.
* `DataSource`는 객체를 처음 생성할 때만 필요한 파라미터를 넘겨두고, 커넥션을 획득할 때는 단순히 `getConnection()`만 호출하면 된다.
* `DataSource`의 경우, 필요한 데이터를 `DataSource`가 만들어지는 시점에 미리 다 넣어두게 되면 사용하는 곳에선 `getConnection()`만 호출하면 되므로 파라미터들에 의존하지 않아도 된다.
  * `DataSource`만 주입받아서 사용할 때 파라미터 없이 getConnection()만 호출하면 된다.
* 이로인해 객체를 설정하는 부분과 사용하는 부분을 분리할 수 있게 된다. 


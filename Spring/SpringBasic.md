# SpringBasic
## Spring Framework이란
### Framework?
* 프로그래밍 상에서 Framework은 기본적으로 프로그래밍을 하기 위한 어떠한 틀이나 구조를 제공한다.
* Framework은 개발자가 애플리케이션의 핵심 로직을 개발하는 것에 집중할 수 있도록 해준다.
* Library와의 차이점은, Library는 애플리케이션 흐름의 주도권이 개발자에게 있고, Framework은 애플리케이션의 흐름의 주도권이 개발자가 아닌 Framework에 있다.

### Spring Framework?
* Spring Framework은 Java기반의 웹 애플리케이션을 개발하는데 필요한 Framework이며, 그냥 Spring이라고도 많이 부른다.
* Java기반의 웹 애플리케이션을 개발하는데 있어선 거의 표준과 다름없다.
* Spirng이 도입되기 전에는 JSP나 Servlet을 사용한 Model1, Model2아키텍쳐를 기반으로한 Java웹 애플리케이션을 제작했다.
* Spring MVC 방식이 도입됨으로써 Java 웹 애플리케이션의 제작 방식이 획기적으로 변하게 되었고, Spring MVC 설정의 복잡함과 어려움을 극복하기위해 Spring Boot라는게 탄생하게 된다.
* Servlet 자체를 사용하는 기술은 현재 거의 사용하고 있진 않지만, Spring MVC같은 웹 애플리케이션 내부에서 여전히 사용되고 있다.
  * 아파치 톰캣(Apache Tomcat) 은Servlet Container의 한 종류로, Spirng MVC기반의 웹 애플리케이션은 기본적으로 아파치 톰캣에서 실행된다.

## Spring의 핵심 개념
![img.png](images/Spring 삼각형.png)
* 위 그림은 Spring 삼각형이라는 유명한 그림이다.
* 이 삼각형 하나로 Spring의 핵심 개념들을 모두 표현하고 있다고 봐도 된다.
* 그림에서 POJO는 Spring에서 사용하는 핵심 개념들에 둘러 싸여져 있는 모습인데, POJO라는 것을 IoC/DI, AOP, PSA를 통해서 달성할 수 있다는 것을 의미한다.
### POJO
* POJO는 Plain Old Java Object의 약자로, 말그대로 해석하면 오래된 방식의 간단한 자바 오브젝트라는 말이다.
  * 풀어서 얘기하면, Java 객체가 다른 기술이나 환경에 종속되지 않는다는 것을 의미한다.

1. Java나 Java의 스펙에 정의된 것 이외에는 다른 기술이나 규약에 얽매이지 않아야 한다.
    * 특정 기술을 상속해서 코드를 작성하게 되면 나중에 다른 기술로 변경하려면 코드를 일일이 전부 수정해야 하는 일이 생긴다.
    * 또한 Java는 다중상속을 지원하지 않기 때문에 한번 상속을 하게되면, 하위클래스를 확장하는 객체지향 설계기법을 적용하기 어려워진다.

2. 특정 환경에 종속적이지 않아야 한다.
    * 예를들면 아파치 톰캣이라는 서블릿 컨테이너를 이용하다가, 톰캣 말고 제티라는 다른 서블릿 컨테이너를 사용하게 되는 상황이 오면 톰캣 API코드를 제티로 수정하거나 최악의 경우에는 애플리케이션을 전부 고쳐야 하는 상황이 올 수도 있다. 
3. Spring에서는 POJO 프로그래밍을 지향하기 위해 IoC/DI, AOP, PSA라는 기술을 제공한다.
#### POJO 프로그래밍이 필요한 이유
* 특정환경이나 기술에 종속적이지 않으면 재사용 가능하고, 확장에 유연한 코드를 작성할 수 있다.
* 저수준 레벨의 기술과 환경에 종속적인 코드를 애플리케이션 코드에서 제거함으로써 코드가 간결해진다.
* 코드가 간결해지기 때문에 디버깅하기가 상대적으로 쉽다.
* 특정 기술이나 환경에 종속적이지 않기 때문에 테스트가 단순해진다.
* **객체지향적인 설계를 제한없이 적용할 수 있다.**

### Ioc/DI
* IoC란 Inversion of Control의 약자로, 애플리케이션 흐름의 주도권이 개발자에게 있지 않고 Framework이나 서블릿 컨테이너 등 외부에 있는 것으로 흐름의 주도권이 뒤바뀐 것을 Ioc라고 한다.
* DI란 Dependency Injection의 약자로, Ioc는 서버 컨테이너 기술, 디자인 패턴, 객체 지향 설계 등에 적용하게되는 일반적인 개념인데, DI는 IoC개념을 조금 더 구체화 시킨 것으로, **객체 간의 관계를 느슨하게 해준다.**
* 객체지향 프로그래밍에서 의존성이라고 하면 대부분 객체 간의 의존성을 의미한다.
* 의존성 주입이란 생성자를 통해서 어떤 클래스의 객체를 전달 받는것이라고 생각하면 된다.
* 생성자의 파라미터로 객체를 전달하는 것을 외부에서 객체를 주입한다라고 표현한다.
* 클래스 내부에서 new를 사용해 참조할 클래스의 객체를 직접 생성하지 않고, 생성자등을 통해 다른 클래스의 객체를 전달받고 있으면 의존성 주입이 이루어 지고 있는 것이다.
* new 키워드를 사용하여 객체를 생성할 때, 클래스 간에 강하게 결합되어 있다고 한다.
* 클래스가 인터페이스같이 일반화된 구성 요소에 의존하고 있을 때, 클래스들 간에 느슨하게 결합되어 있다고 한다.
* 객체들간의 느슨한 결합은 요구사항의 변경에 유연하게 대처할 수 있도록 해준다.
* Spring을 사용하면, 애플리케이션 코드에서 이루어지는 DI를 Spring에서 대신 해준다.


### AOP
* Aspect Oriented Programming의 약자로, 관심 지향 프로그래밍이라고 한다.
* AOP에서 Aspect는 애플리케이션의 공통 관심사를 의미한다.
* 애플리케이션의 공통 관심사는 비즈니스 로직을 제외한 애플리케이션 전반에 걸쳐서 사용되는 공통 기능들을 의미한다.
  * 예로는 로깅, 보안, 트랜잭션, 모니터링, 트레이싱 등의 기능이 있다.
* 중복된 코드를 공통화해서 재사용 가능하도록 만들어야 하고, 이 공통화 작업은 AOP를 통해서 할 수 있다.
* AOP를 활용하면 공통 기능들을 비즈니스 로직에서 깔끔하게 분리하여 재사용 가능한 모듈로 사용할 수 있게 된다.
#### AOP의 장점
* 코드의 간결성 유지
* 객체 지향 설계 원칙에 맞는 코드 구현
* 코드의 재사용

### PSA
* Portable Service Abstraction의 약자로, 직역하면 일관된 서비스 추상화라고 해석할 수 있다.
* 추상화 된 상위 클래스를 일관되게 바라보며 하위클래스의 기능을 사용하는 것이 PSA의 기본 개념이다.
* 애플리케이션에서 특정 서비스를 이용할 때, 서비스의 기능을 접근하는 방식 자체를 일관되게 유지하면서 기술 자체를 유연하게 상요할 수 있도록 하는것을 PSA라고 한다.
* PSA가 필요한 주된 이유는, 어떤 서비스를 이용하기 위한 접근 방식을 일관된 방식으로 유지함으로써 애플리케이션에서 사용하는 기술이 변경되더라도 최소한의 변경으로 변경된 요구사항을 반영할 수 있게 하기 위해서이다.


## 아키텍처
* 아키텍처(Architecture)는 건축 분야에서 유래된 용어로써, 요구 사항을 만족하는 건축물을 짓는데 있어 청사진 같은 역할을 한다.
* 소프트웨어의 구성을 큰 그림으로 표현한 것이 소프트웨어 아키텍처이다.
* 애플리케이션은 소프트웨어 종류의 하나로, 좁게는 데스크탑이나 스마트폰에서 사용하는 응용 프로그램을 말하지만, 넓게는 클라이언트의 요청을 처리하는 서버 애플리케이션을 의미한다.
* 웹 개발을 목표로 하기 떄문에, 중점적으로 알아야 할 아키텍처는 웹 상에서 동작하는 웹 애플리케이션을 위한 아키텍처이다.

### 계층형 애플리케이션 아키텍처
* REST API 기반 웹 애플리케이션의 계층은 크게 API계층, 비즈니스 계층, 데이터 액세스 계층으로 구분된다.
* API 계층은 클라이언트의 요청을 받아들이는 계층이다.
* 비즈니스 계층은 API 계층에서 전달받은 요청을 업무 도메인의 요구사항에 맞게 비즈니스적으로 처리하는 계층이다.
* 데이터 액세스 계층은 비즈니스 계층에서 처리된 데이터를 데이터베이스 등의 데이터 저장소에 저장하기 위한 계층이다.

### Spring Module의 아키텍처
![img.png](images/Spring 아키텍처.png)
* 위 사진은 Spring Framework에서 지원하는 모듈들을 아키텍처로 표현한 그림이다.
* 지금은 각 모듈들이 눈에 잘 들어오지 않지만, 추후 Spring을 더 공부하고 나서 다시 보면 눈에 많이 익숙해져 있을 것이다.

>모듈
> 
> * Java에서는 보통 지원되는 여러가지 기능들을 목적에 맞게 그룹화하여 묶어 놓은 것을 모듈이라고 한다.
> * 모듈들은 Java의 패키지 단위로 묶여 있으며, 이 패키지 안에는 고나련 기능을 제공하기 위한 클래스들이 포함되어 있다.
> * 일반적으로 모듈은 재사용 가능하도록 라이브러리 형태로 제공되는 경우가 많다.

## Spring Boot
* Spring Framework의 편리함에도 불구하고 Spring 설정의 복잡함으로 인해 Spring 기반 애플리케이션 개발을 시작하기도 전에 어려움을 겪는 경우가 많다.
* Spring Boot은 이를 해결하기 위해 생겨난 Spring Project중 하나이다.
* Spring의 구성은 Spring Boot에서 해주기 때문에, 비즈니스 로직에 집중할 수 있게 된다.
### Spring Boot을 사용해야 하는 이유
#### XML기반의 복잡한 설계 방식 지양
* Spring Boot 이 전에는 Spring 애플리케이션 개발을 위한 설정은 굉장히 복잡했다.
* 하지만 Spring Boot으로 인해 개발자는 Spring의 복잡한 설정에 대한 어려움으로 부터 벗어날 수 있게 되었다.
#### 의존 라이브러리의 자동 관리
* Spring Boot 이 전에는 애플리케이션에서 필요한 라이브러리를 사용하기 위해서는 필요한 라이브러리들의 이름과 버전을 일일이 추가해야 했다.
* 이로인해 라이브러리 간의 버전 불일치로 인한 빌드 오류 및 실행 오류가 굉장히 많았다.
* Spring Boot의 starter 모듈 구성 기능을 통해 의존 라이브러리를 수동으로 설정해야 하는 불편함이 사라졌다.
#### 애플리케이션 설정의 자동 구성
* Spring Boot은 starter 모듈을 통해 설치되는 의존 라이브러리를 기반으로 애플리케이션의 설정을 자동으로 구성한다.
* 자동으로 구성해주기 때문에 애플리케이션에 대한 설정을 직접해야 하는 번거로움이 줄었다.
#### 프로덕션 급 애플리케이션의 손쉬운 빌드
* Spring Boot을 사용하면 개발한 애플리케이션 구현 코드를 손쉽게 빌드하며, 빌드 결과물을 War(Web application archive)파일 형태로 WAS(Web Application Server)에 올릴 필요가 없다.
* Spring Boot에서 빌드를 하면 jar파일이 생성되고, jar파일은 즉시 시작 가능한 애플리케이션 실행파일로 사용된다.
> WAS
> 
> * Java 기반의 웹 애플리케이션을 배포하는 일반적인 방식은, 개발자가 구현한 애플리케이션 코드를 war파일 형태로 빌드한 후에 WAS라는 서버(Java에서는 서블릿 컨테이너)에 배포해서 해당 애플리케이션을 실행하는 것이다.
> * 대표적인 WAS로는 Tomcat이 있다.
> * WAS는 구현된 코드를 빌드해서 나온 결과물을 실제 웹 애플리케이션으로 실행되게 해주는 서버이다.
>

#### 내장된 WAS를 통한 손쉬운 배포
* Spring Boot는 Apache Tomcat이라는 WAS를 내장하고 있기 떄문에 별도의 WAS를 구축할 필요가 없다.
* Spring Boot을 통해 빌드된 jar파일을 이용해서 명령어 한줄로 서비스 가능한 웹 애플리케이션을 실행할 수 있다.



## Spring project 생성
### project 생성
* 스프링 부트는 스프링을 쉽게 사용할 수 있도록 필요한 설정들이 모두 세팅되어져 있는 것을 말한다. 
* 스프링 부트 스타터 사이트인 https://start.spring.io 에서 프로젝트를 생성한다.
* Project에는 Maven Project와 Gradle Project가 있는데, 과거 프로젝트들은 Maven으로 남아있는게 있으나, **요즘은 Gradle을 이용**하는 추세이다.
* Project Metadata에 Group에는 보통 기업 도메인명을 적고, Artifact는 빌드되어 나오는 결과물을 말한다. (프로젝트 명)
* Dependencies란에선 어떤 라이브러리를 쓸 건지 결정하면 된다.
    * 웹 프로젝트를 만들 것이므로, Spring Web 선택
    * html을 만들어주는 템플릿 엔진으로 Thymeleaf를 선택
* generate를 클릭하면 zip파일이 다운되는데, 압출을 풀고 해당 파일을 IntelliJ로 실행하면 준비 완료이다.

### .gitignore 파일
* git에는 소스코드만 올라갈 수 있도록 스프링 부트에서 자동적으로 생성해준다.

### gradle 폴더
* gradle wrapper와 같이 gradle과 관련된 파일들이 있다.
>gradle
>
> groovy를 이용한 빌드 자동화 시스템이다. 소프트웨어 개발자가 반복적으로 해야하는 코딩을 잘 짜여진 프로세스를 통해 자동으로 실행하며 믿을 수 있는 결과물로 생산해 낼 수 있는 방법이다.
> 1) 빠른 기간동안 계속해서 늘어나는 라이브러리를 추가한다.
> 2) 프로젝트를 진행하면서 라이브러리의 버전을 쉽게 동기화할 수 있다.
### src 폴더
* src에 main과 test가 있는데, main에는 JAVA와 resources가 있다.
  * JAVA에 실제 패키지들과 소스파일들이 있다
  * resources에는 xml, html, properties 등이 들어간다.
  * test에는 test코드들과 관련된 소스들이 들어가 있다. (test code가 요즘 개발 트렌드에서 매우 중요하다)
* gradle과 관련되서 gradle을 쓰는 폴더가 있다.

### build.gradle 파일
* 스프링 부트들이 나오면서 설정파일들까지 모두 제공되는데, build.gradle파일은 지금은 gradle버전을 설정하고 라이브러리들을 가져온다 정도로만 알고 있으면 된다.
* dependencies에서 설정했던 라이브러리들을 볼 수 있고, 테스트파일로는 Junit5가 기본적으로 들어간다.
* 이러한 라이브러리들을 mavenCentral을 통해 특정 사이트에서 다운받도록 되어있다.

## 기본적인 라이브러리
* Gradle은 의존관계가 있는 라이브러리들을 함께 다운로드한다.
* 아래는 아주 기본적인 라이브러리들이다.
### 스프링 부트 라이브러리
* spring-boot-starter-web
  * spring-boot-starter-tomcat : 톰캣(웹서버)
  * spring-webmvc : 스프링 웹 MVC
* spring-boot-starter-thymeleaf : 타임리프 템플릿 엔진(View)
* spring-boot-start(공통) : 스프링 부트 + 스프링 코어 + 로깅
  * spring-boot
    * spring-core
  * spring-boot-starter-logging
    * logback, slf4j

### 테스트 라이브러리
* spring-boot-starter-test
  * junit : 테스트 프레임워크
  * mockito : 목 라이브러리
  * assertj : 테스트 코드를 좀 더 편하게 작성하도록 도와주는 라이브러리
  * spring-test : 스프링 통합 테스트 지원



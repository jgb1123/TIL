# JWT
## 인증 방식 종류
* 서버가 클라이언트 인증을 확인하는 방식은 대표적으로 쿠키, 세션, 토큰 3가지 방식이 있다.
* JWT를 공부하기 전에 쿠키, 세션, 토큰의 차이를 간단하게 정리하려고 한다.
### Cookie
* 쿠키는 Key-Value 형식의 문자열이다.
* 클라이언트가 어떤 웹사이트를 방문할 경우 그 사이트가 사용하고 있는 서버를 통해 클라이언트의 브라우저에 저장되는 작은 기록전용 파일이다.
* 각 사용자마다의 브라우저에 정보를 저장하니 고유 정보 식별이 가능하다.
#### Cookie 인증 과정
1. 브라우저가 서버에 요청을 보낸다.
2. 서버는 클라이언트의 요청에 대한 응답을 작성할 때, 클라이언트 측에 저장하고 싶은 정보를 응답헤더의 Set-Cookie에 담는다.
3. 이후 해당 클라이언트는 요청을 보낼 때마다 저장된 쿠키를 요청 헤더에 Cookie에 담아 보낸다.
4. 서버는 쿠키에 담긴 정보를 바탕으로 해당 요청의 클라이언트가 누군지 식별한다.

#### Cookie 방식의 단점
* 가장 큰 단점으로는, 보안에 매우 취약하다.
  * 요청 시 쿠키의 값을 그대로 보내기 때문에 유출 및 조작당할 위험이 존재한다.
* 쿠키에는 용량제한이 있기 때문에 많은 정보를 담을 수 없다.
* 웹 브라우저마다 쿠키에 대한 지원 형태가 다르기 때문에, 브라우저간 공유가 불가능하다.
* 쿠키의 사이즈가 커질수록 네트워크에 부하가 심해진다.


### Session 인증
* 쿠키의 보안적인 이슈 때문에, 세션은 비밀번호 등 클라이언트의 민감한 인증 정보를 브라우저가 아닌 서버 측에 저장하고 관리한다.
* 서버의 메모리,  서버의 로컬 파일,  데이터베이스에 저장한다.
* 민감한 정보는 클라이언트에 보내지 않고 서버에서 관리하게 되는 것이다.

#### Session 인증 과정
1. 유저 웹사이트에서 로그인을 하면 세션이 서버 메모리 혹슨 데이터베이스 상에 저장된다. (Session Id를 기준으로 정보를 저장)
2. 서버에서 브라우저 쿠키에 Session Id를 저장한다.
3. 쿠키에 정보가 담겨있기 때문에 브라우저는 해당 사이트에 대한 모든 요청에 Session Id를 쿠키에 담아 전송한다.
4. 서버는 클라이언트가 보낸 Session Id와 서버 메모리로 관리하고 있는 Session Id를 비교하여 인증을 수행한다.

#### Session 방식의 단점
* 쿠키를 포함한 요청이 외부에 노출되더라도 세션 ID 자체는 유의미한 개인정보를 담고 있지 않지만, 해커가 세션 ID 자체를 탈취하여 클라이언트인척 위장할 수 있다.
* 서버에서 세션 저장소를 사용하므로 요청이 많아지면 서버에 부하가 심해진다.

### Token 인증
* 토큰 기반 인증 시스템은 클라이언트가 서버에 접속하면 서버에서 해당 클라이언트에게 인증되었다는 의미로 토큰을 부여한다.
* 이 토큰은 유일하며, 토큰을 발급받은 클라이언트는 또 다시 서버에 요청을 보낼 때 요청 헤더에 토큰을 심어서 보낸다.
* 서버에서는 클라이언트로부터 받은 토큰을 서버에서 제공한 토큰과의 일치 여부를 체크하여 인증 과정을 처리하게 된다.
* 기존의 세션 기반 인증은 서버가 파일이나 데이터베이스 등에 세션 정보를 가지고 있어야 하고, 이를 조회하는 과정이 필요했지만, 토큰은 세션과 달리 서버가 아닌 클라이언트에 저장되기 때문에 서버의 부담을 덜 수 있다.
* 토큰 자체에 데이터가 들어있기 때문에 클라이언트에서 받아 위조되었는지 판별만 하면 되는 것이다.
#### Token 인증 과정
1. 사용자가 아이디와 비밀번호로 로그인한다.
2. 서버 측에서 사용자에게 유일한 토큰을 발급한다.
3. 클라이언트는 서버 측에서 전달받은 토큰을 쿠키나 스토리지에 저장해 두고, 서버에 요청을 할 때마다 해당 토큰을 요청 헤더에 포함시켜 전달한다.
4. 서버는 전달받은 토큰을 검증하고 요청에 응답한다.
  * 토큰에는 요청한 사람의 정보가 담겨있기 때문에 서버는 DB를 조회하지 않아도 누가 요청하는지 알 수 있다.

#### Token 방식의 단점
* 쿠키 세션과 다르게 토큰 자체의 데이터 길이가 길기 때문에, 인증 요청이 많아질수록 네트워크 부하가 심해질 수 있다.
* Payload자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없다.
* 토큰을 탈취당하면 대처하기 어렵다. (사용 기간을 제한하는 방법으로 극복함)

## JWT(JSON Web Token)
* JWT란 Json포맷을 이용하여 사용자에 대한 속성을 저장하는 Claim(속성 정보)기반의 Web Token이다.
* JWT는 토큰 자체를 정보로 사용하는 Self-Contained 방식으로 정보를 안전하게 전달한다.
* JWT는 URI에서 파라미터로 사용할 수 있도록 URL-Safe한 Base64Url인코딩을 사용한다.
* 주로 회원 인증이나 정보 전달에 사용된다.

### JWT 구조
* JWT는 `.`을 구분자로 나누어지는 세가지 문자열의 조합이다. (Header.Payload.Signature)
* JSON형태인 각 부분은 Base64Url로 인코딩되어 표현된다.
* 좌측부터 Header, Payload, Signature를 의미한다.
* Header에는 JWT에서 사용할 타입과 해시 암호화 알고리즘으로 구성되어 있다.
  * 첫째는 토큰의 유형(JWT)을 나타내고, 두번째는 HMAC,SHA256, RSA와 같은 해시 알고리즘을 나타낸다.
* Payload에는 토큰을 담을 claim 정보를 포함하고 있다.
  * claim은 name, value의 한 쌍으로 이뤄져 있고, 토큰에는 여러개의 클레임들을 넣을 수 있다.
  * claim의 정보는 registered claim, public claim, private claim 세 종류가 있다.
* Signature는 Header와 Payload의 값을 각각 Base64Url로 인코딩하고, 인코딩한 값을 secret key를 이용해 Header에서 정의한 알고리즘으로 해싱을 하고, 이 값을 다시 Base64Url로 인코딩하여 생성한다.

### JWT 인증 과정
1. 사용자가 로그인을 시도한다.
2. 서버는 요청을 확인하고, Header, PayLoad, Signature를 정의하고 Secret Key로 암호화하여 JWT를 생성하고 쿠키에 담아 클라이언트에게 전달한다.
3. 클라이언트는 JWT를 로컬 스토리지에 저장한다. (쿠키등 다른곳에 저장할 수 있음)
4. 클라이언트가 서버에 요청을 할때 Authorization header에 Access Token을 담아서 보낸다.
5. 서버는 클라이언트가 Header에 담아서 보낸 JWT가 서버 내에서 발행한 토큰인지 확인하고, 일치하면 페이로드에 들어있는 유저의 정보들을 클라이언트에 돌려준다.
  * Token이 검증되면 따로 username, password를 검사하지 않아도 식별이 가능해진다.
6. 만약 클라이언트가 서버에 요청을 했는데 액세스토큰의 시간이 만료되었다면 클라이언트는 리프래시 토큰을 이용해서 서버로부터 새로운 액세스토큰을 발급 받는다.

### JWT의 장점
* Header와 Payload를 가지고 Signature를 생성하므로 데이터 위변조를 막을 수 있다.
* 인증 정보에 대한 별도의 저장소가 필요 없다.
* JWT는 토큰에 대한 기본 정보, 전달할 정보, 토큰이 검증되었음을 증명하는 서명 등 필요한 모든 정보를 자체적으로 지니고 있다.
* 클라이언트 인증 정보를 저장하는 세션과 다르게 서버는 무상태(StateLess)가 된다.
* 확장성이 우수하다.
* 토큰 기반으로 다른 로그인 시스템에 접근 및 권한 공유가 가능하다. (쿠키와의 차이)
* OAuth의 경우 kakao, Google등 소셜 계정을 이용하여 다른 웹서비스에서도 로그인을 할 수 있다.
* 모바일 어플리케이션 환경에서도 잘 동작한다.(모바일은 세션 사용 불가)
* 대부분 DB문제로 서버도 같이 죽는 경우가 많은데, JWT는 DB조회를 하지 않아도 되는 장점을 가지고 있다.

### JWT의 단점
* 쿠키, 세션과 다르게 JWT는 토큰의 길이가 길기 때문에 인증 요청이 많아질수록 네트워크 부하가 심해진다.
* Payload자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없다.
* 토큰을 탈취당하면 대처하기가 어렵다.

## Refresh Token
### Refresh Token 등장 배경
* Access Token만을 통한 인증방식의 단점은 토큰을 탈취당할 경우 보안에 취약하다는 점이다.
  * Access Token은 발급된 이후 서버에 저장되지 않고 토큰 자체로 검증을 하며 사용자 권한을 인증하기 때문에, Access Token이 탈취되면 토큰이 만료되기 전까지 토큰을 획득한 사람은 누구나 권한 접근이 가능해진다.
* JWT는 발급한 후 삭제가 불가능하기 때문에, 접근에 관여하는 토큰에 유효시간을 부여하는 식으로 탈취문제에 대해 대응을 할 수 있다.
* 토큰의 유효기간을 짧게 하면 Token의 경우 그만큼 로그인을 자주 해서 새롭게 Token을 발급받아야 하므로 불편하다는 단점이 있다.
* 이러한 문제를 해결하기 위해 생긴게 바로 Refresh Token이다.
* RefreshToken은 Access Token과 똑같은 JWT이지만, Access Token은 접근에 관여하는 토큰이고, Refresh Token은 재발급에 관여하는 토큰이므로 하는 역할이 다르다.
* Refresh Token은 긴 유효기간을 가지며, Access Token이 만료되었을 때 새로 재발급을 해줄 수 있게 해준다.
### Access Token과 Refresh Token의 재발급
1. 기본적으로 로그인과 같은 인증요청을 진행하면 Access Token과 Refresh Token을 모두 발급한다.
  *  Refresh Token만 서버측 DB에 저장하며, Refresh Token과 Access Token을 쿠키나 로컬 스토리지에 저장한다.
2. 사용자가 인증이 필요한 API에 접근하고자 하면 가장 먼저 토큰 검사를 한다.
  * 토큰을 검사함과 동시에 각 경우에 대해서 토큰의 유효기간을 확인하여 재발급 여부를 결정한다.
    * 두 토큰 모두 만료된 경우, 재 로그인하여 둘다 새로 발급
    * Access Token만 만료된 경우, refresh token을 검증하여 access token 재발급
    * refresh Token만 만료된 경우, access token을 검증하여 refresh token 재발급
    * 두 토큰 모두 유효한 경우, 정상 처리
3. 로그아웃을 하면 Access Token과 Refresh Token을 모두 만료시킨다.














___
참고

https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC#JWT_%EA%B5%AC%EC%A1%B0

https://mangkyu.tistory.com/56

http://www.opennaru.com/opennaru-blog/jwt-json-web-token/

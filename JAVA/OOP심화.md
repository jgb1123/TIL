# OOP 심화

* 객체지향 프로그래밍 설계를 지탱하는 핵심개념인 상속성, 캡슐화, 다형성, 추상화가 있다.
* 자바 뿐만 아니라 다른 OOP 설계를 지향하는 모든 언어에 적용되는 핵심 요소이다.

## 1. 상속(Inheritance)
* 기존의 클래스를 확장하여 새로운 클래스를 만드는 것을 말한다.
* 이 때 상속 해준 클래스는 상위 클래스(부모 클래스)라 하고, 상속 받은 클래스를 하위 클래스(자식 클래스)라고 한다.
```java
class 자식클래스 extends 부모클래스{ // extends를 이용해 상속받을 수 있다.

}
```
* 자바에서는 1개의 부모 클래스로부터의 단일 상속만 허용된다. (인터페이스를 이용하면 다중 상속 가능)
* 부모 클래스는 여러개의 자식 클래스에게 상속이 가능하다.

### 상속의 장점
* 중복된 코드를 줄일 수 있다.
* 유지보수가 편리하다.
* 다형성을 구현할 수 있다.

### 포함(composite)
* 포함은 상속처럼 클래스를 재사용 할 수 있는 방법으로, **클래스의 멤버로 참조변수를 선언하여, 다른 클래스의 객체를 참조하는방법**이다.
* 상속 관계를 맺어줄지 포함 관계를 맺어줄지의 기준을 쉽게 생각하는 법은 `~은~이다.(is-a)`관계(상속) 인지 `~은 ~을 가지고 있다.(has-a)` 관계(포함) 인지 생각해보는 것이다.
```java
class Circle{
    Point c = new Point(); //Circle class의 멤버로 참조변수를 선언하여
    int r;                             //다른 class의 객체를 참조한다.
} 
class Point{
    int x;
    int y;
}
```

### 메소드 오버라이딩
* 상위 클래스로부터 상속받은 메서드와 동일한 이름의 메서드로 재정의 하는 것이다.
* 메서드의 다형성을 구현할 수 있다.
* 오바라이딩의 3가지 조건이 있다.
  * 메서드의 시그니처(메서드 이름, 매개변수, 반환타입)가 상위클래스와 동일해야 한다.
  * 접근 제어자의 범위가 상위 클래스의 메서드보다 같거나 넓어야 한다.
  * 예외는 상위 클래스의 메서드보다 많이 선언할 수 없다.

>super() vs super
> 
> super()
>* this()와 달리 상위클래스의 생성자를 호출하는데 사용된다.
>* 반드시 첫줄에 위치해야 한다.
>
> super
> * this와 달리 상위클래스의 객체를 의미한다.


### Object 클래스
* Object 클래스는 자바의 클래스 상속 계층도에서 최상위에 위치한 상위 클래이며, 자바의 모든 클래스는 Object클래스를 상속 받는다.
* 자바 컴파일러는 아무런 상속을 받지 않는 클래스에 자동적으로 `extends Object`를 추가하여 Object 클래스를 상속받도록 한다.






## 2. 캡슐화(Encapsulation)
* 특정 객체 안에 관련된 속성과 기능을 하나의 캡슐로 만들어 데이터를 외부로부터 보호하는 것을 말한다.

### 캡슐화의 장점
* 데이터를 보호할 수 있다.
* 내부적으로만 사용되는 데이터에 대한 불필요한 외부 노출을 방지한다
* 데이터가 변경되더라도 다른객체에 영향을 주지 않기에 독립성을 확보할 수 있다.
* 유지보수와 코드 확장 시 오류의 범위를 최소화할 수 있다.

### 패키지
* 패키지란 특정한 목적을 공유하는 클래스와 인터페이스의 묶음이다.
* 우리가 컴퓨터를 사용할 때 폴더를 만들어 관련된 내용들을 정리해 놓은 것과 같은 느낌이다.
* 하나의 패키지 안에 있는 클래스나 인터페이스 파일들은 모두 그 패키지에 속하게 된다.
```java
package 상위패키지.하위패키지; 
                            
public class ClassName {
    
}
```
* 패키지 명은 보통 소문자로 만든다.
* 같은 클래스명을 갖고 있더라도 다른 패키지에 포함되어 있으면 충돌하지 않는다.

#### import
* import문을 이용하면 클래스를 사용할 때 패키지 이름을 생략할 수 있다.
* 컴파일러에게 클래스가 속한 패키지를 알려주면서, 클래스명 만으로도 사용할 수 있게 된다.
  (기본 패키지들은 import하지 않고도 사용할 수 있다.)
* import문은 컴파일 시 처리되므로 프로그램의 성능에 영향이 없다.
```java
import 패키지명.클래스명;   //해당 페키지의 클래스를 불러옴
import 패키지명.*;  // 해당 패키지의 모든 클래스들을 불러옴
```

### 접근 제어자

* 접근 제어자를 사용하면 클래스 외부로의 불필요한 데이터 노출을 방지할 수 있다.
* 하나의 대상에 접근 제어자는 하나만 쓸 수 있다.

|  접근 제어자   |  클래스 내  | 패키지 내  | 다른 패키지의<br>하위 클래스  | 패키지 외  |
|:---------:|:-------:|:------:|:------------------:|:------:|
|  private  |    O    |   X    |         X          |   X    |
| (default) |    O    |   O    |         X          |   X    |
| protected |    O    |   O    |         O          |   X    |
|  public   |    O    |   O    |         O          |   O    |

### setter, getter
* 자바에서 데이터 보호와 은닉을 위해 접근 제어자를 사용한다.
* 객체지향의 캡슐화의 목적을 달성하면서도 데이터의 변경이 필요한 경우에는 setter 메서드와 getter 메서드를 이용하면 된다.
* 일반적으로 메서드명 앞에 `set-`, `get-`을 붙여서 정의한다.
* setter 메서드를 이용하여 데이터 값을 할당할 수 있고, getter 메서드를 이용하여 데이터 값을 불러올 수 있다.
```java
//Setter 메소드
class setterEx {
  private int pirce;

  void setPrice(int num) {
    this.price = price;
  }
}
//Getter 메소드
class getterEx {
  private int price;

  int getPrice() {
    return price;
  }
}
```

## 3. 다형성(Polymorphism)
* 한 타입의 참조변수로 여러가지 객체를 참조하여 다양한 결과를 얻어내는 성질이다.
* 자바에서 다형성은 부모 클래스 타입 참조 변수로 여러 자손 클래스의 객체를 참조할 수 있도록 하여 구현하고 있다.
* 참조변수가 사용할 수 있는 멤버 개수가 실제 객체의 멤버 개수보다 같거나 적어야 참조할 수 있다.(자식 타입 참조변수로 부모 클래스 객체를 참조할 수 없다.)
* 만약 자식 타입이 부모 클래스 타입으로 형변환 된 이후에는 참조 변수는 자식객체를 참조하지만, 참조 변수로 접근 가능한 멤버는 부모클래스 멤버로만 한정된다.
  (부모클래스에는 없고 자식클래스에만 있는 멤버에 접근할 수 없다.)

### 다형성의 장점
* 부모 타입 참조변수로 자식타입 객체를 다룰 수 있다.
* 하나의 배열에 여러 객체를 넣을 수 있게 된다.

### 참조변수의 형변환
* 자바에서는 참조 변수의 형변환이 가능하며, 서로 상속관계에 있는 클래스 사이에서만 가능하다.
* 쉽게 말하면 형변환을 통해 사용할 수 있는 멤버들을 조절할 수 있다. (다형성)
* ❗ 형변환 시 참조변수가 가리키는 객체가 무엇인지 확인하는것이 중요하다.

#### 1) 자동 형변환
* 부모클래스 참조변수에 자식객체 타입을 대입하면 자동으로 형변환이 일어난다. (Up casting)
* 자동으로 형변환이 되기 때문에 형변환 연산자 `()`를 생략할 수 있다.
* 부모 타입 참조 변수는 자식 객체를 참조하지만, 참조 변수로 접근 가능한 멤버는 부모클래스 멤버로만 한정된다.
  (❗메소드가 자식클래스에서 오버라이딩 되었다면 오버라이딩된 메소드가 대신 호출 됨)

#### 2) 강제 형변환
* 부모타입을 **다시** 자식타입으로 형변환하는 것이다. (Down Casting)
* 자식타입이 부모타입으로 자동 변환 후 다시 자식타입으로 변환할 때 강제 타입 변환을 사용할 수 있다.
* 자동으로 형변환이 되지 않기 떄문에 형변환 연산자`()`를 사용하여 강제 형변환을 수행한다.
  ```java
  Child child = (Child) parent; 
  ```
* 자식타입에 선언된 필드와 메소드를 사용해야 하는 경우 사용된다.
* 강제타입 변환은 부모타입으로 형변환 되어 있는 상태에서만 가능하기 때문에, instanceof 연산자를 사용하여 그 상태를 확인할 수 있다.
  > instanceof 연산자
  >* 참조변수의 형변환이 가능한 지 여부를 boolean타입으로 확인할 수 있는 자바의 문법이다.
  >* 프로젝트의 규모가 커지거나, 소스코드가 너무 길어지는 등 일일이 생성 객체의 타입을 확인하기 어려운 상황에서 유용하다.
  >* ❗instanceof를 사용하면 외부의 객체에서 해당 객체가 어떤 타입인지를 알 수 있기 때문에 캡슐화가 깨질 수 있으므로 무작정 사용하진 말자.
  >```java
  >참조변수 instanceof 타입
  >```
 
## 4. 추상화(Abstraction)
* 기존 클래스들의 공통적인 요소를 추출하여 정의하는 것이다.

### abstract 제어자
* 추상적인이란 뜻으로 클래스와 메서드를 형용하는 키워드로 사용된다. (abstract method, abstract class)
* abstract의 가장 핵심적인 개념은 '미완성'이다.
* abstract가 붙은 메서드인 추상 메서드는 시그니처만 있고 바디가 없다. 
* 추상 메서드를 포함하는 클래스는 미완성 클래스인 추상 클래스가 된다.
```java
abstract class 클래스명 {         // 추상클래스는 추상메서드를 포함하고 있다.
    abstract 리턴타입 메서드이름(); // 추상메서드는 {} 없이 ;으로 마무리된다.
}
```
### 추상 클래스
* 추상 클래스는 메서드 시그니처만 존재하고 바디가 선언되어 있지 않은 추상 메서드가 포함 되어있는 '미완성 클래스'이다.
* 미완성 클래스이기 때문에 추상클래스의 객체는 생성이 불가능 하다.
* 이러한 추상 클래스는 메서드의 내용이 하위 클래스에 따라 달라지는 경우에 사용한다.
* 상속받는 하위클래스에서 오버라이딩을 통해 상황에 맞는 메서드 구현이 가능해진다. 
* 이러한 추상클래스는 추상화를 구현하는데 핵심적인 역할을 한다.
* 이렇게 추상화된 코드는 구체화된 코드보다 유연하다. (변경에 유리)

### final 키워드
* final 키워드는 필드, 지역변수, 클래스 앞에 위치할 수 있으며 위치에 따라 의미가 조금씩 달라진다
  
|위치|의미|
|---| --- |
|클래스| 변경 또는 확장 불가능한 클래스 |
|메서드| 오버라이딩 불가 |
|변수| 값 변경이 불가한 상수 |


### 인터페이스
* 추상 메서드의 집합이다.
* 인터페이스는 추상 클래스와 다르게, 오직 추상 메서드와 상수만을 멤버로 가질 수 있다.(구현된 것이 전혀 없다.)
* 일반 클래스와 다르게 내부의 모든 필드가 public static final로 정의된다.
* static, default 메서드 이외의 모든 메서드가 public abstract로 정의된다.
* 모든 인터페이스의 필드와 메서드는 위의 요소가 내포되어 있기 때문에 생략이 가능하다.
```java
interface 인터페이스명{
    public static final 타입 상수이름 = 값;
    public abstract 메서드명(매개변수목록);
} 

```
#### 인터페이스의 상속
* 인터페이스의 조상 인터페이스만 가능하다(Object가 최고 조상 아님)
* **다중 상속**이 가능하다
  * 클래스와 다르게, 인터페이스는 애초에 미완성된 멤버를 가지고 있기 때문에 충돌이 발생할 수 없다.

#### 인터페이스의 구현
* 추상클래스와 다르게 extends 키워드 대신 implements 키워드를 이용한다.
* 인터페이스에 정의된 추상메서드를 모두 구현해야 한다.
* 일부 추상메서드만 구현하는 경우, 클래스 앞에 abstract을 붙여 추상클래스로 만들어야 한다.
```java
class 클래스명 implements 인터페이스명{
    
}
```
#### 인터페이스 vs 추상클래스
* 공통점 - 추상 메서드를 가지고 있다. (미완성이다.)
* 차이점 - 인터페이스는 멤버변수, 생성자, 인스턴스 메서드 등을 가질 수 없다.(추상 메서드와 상수만을 멤버로 가질 수 있다.)

#### 인터페이스를 이용한 다형성
* 인터페이스를 메서드의 리턴타입으로  지정할 수 있다. (인터페이스를 구현한 객체를 반환해야 한다.)

#### 인터페이스의 장점
* 두 대상 간의 연결, 대화, 소통을 돕는 중간역할을 한다.
* 시그니처(선언부)와 바디(구현부)를 분리시킬 수 있다.(결합이 느슨해지기 때문에 변경에 유리하다)
* 개발시간을 단축할 수 있다. (완성되지 않은 상태에서도 동시 개발 가능.)
* 표준화가 가능하다. ex) JDBC
* 서로 관계없는 클래스들에게 새로운 관계 맺어줄 수 있다. (인터페이스는 다중상속이 가능하기 때문이다.)

#### default 메서드와 static 메서드 (Java8~)
* 인터페이스에 새로운 메서드를 추가하기가 어렵다.
* 인터페이스에 default 메서드와 static 메서드 추가 가능해졌다.
##### default
* default 메서드는 인스턴스 메서드이다.(인터페이스 원칙 위반)
* 이러한 디폴드 메서드가 기존의 메서드와 충돌할 때 아래와 같은 방법으로 해결할 수 있다.
  * 여러 인터페이스의 디폴트 메서드 간의 충돌 : 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩 한다.
  * 디폴트 메서드와 조상 클래스의 메서드 간의 충돌 : 조상 클래스의 메서드가 상송되고, 디폴트 메서드는 무시된다.
##### static
* 인스턴스 생성과 상관없이 인터페이스 타입으로 호출하는 메서드이다.
* 인터페이스를 구현하는 클래스에서 오버라이딩은 불가능하다.

### 내부 클래스(inner class)
* 클래스 안의 클래스이다.
* 내부클래스에서 외부클래스의 멤버들을 쉽게 접근할 수 있다.
* 클래스 안의 클래스가 되어 바깥에서는 사용할 수 없다.(캡슐화)
#### 내부클래스의 종류와 특징
| 내부 클래스   | 특징                                                                                   |
|----------|--------------------------------------------------------------------------------------|
| 인스턴스 클래스 | 외부 클래스의 인스턴스 멤버처럼 다루어진다.                                                             |
| 스태틱 클래스  | static 클래스만 static 멤버를 정의할 수 있다. (내부클래스에서 static 멤버변수를 사용하려면 static 클래스여야 한다. 상수 제외) |
| 지역 클래스   | 외부 클래스의 메서드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.                                   |
| 익명 클래스   | 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스이다. 1회성으로 쓰고싶을 때 사용한다.                               |

* 내부 클래스에서 외부클래스의 private 멤버도 접근 가능하다.
* 내부 클래스에서 외부클래스의 지역변수는 final이 붙은 상수만 접근 가능하다.

___
참고

https://timing-bravery.tistory.com/2

남궁성의 정석코딩 자바의 정석 기초편 https://www.youtube.com/channel/UC1IsspG2U_SYK8tZoRsyvfg

codestates 교육
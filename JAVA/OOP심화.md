# OOP 심화

* 객체지향 프로그래밍 설계를 지탱하는 핵심개념인 상속성, 캡슐화, 다형성, 추상화가 있다.
* 자바 뿐만 아니라 다른 OOP 설계를 지향하는 모든 언어에 적용되는 핵심 요소이다.

## 1. 상속(Inheritance)
* 기존의 클래스를 확장하여 새로운 클래스를 만드는 것을 말한다.
* 이 때 상속 해준 클래스는 상위 클래스(부모 클래스)라 하고, 상속 받은 클래스를 하위 클래스(자식 클래스)라고 한다.

### 상속의 장점
* 중복된 코드를 줄일 수 있다.
* 유지보수가 편리하다.
* 다형성을 구현할 수 있다.

### 상속 방법
```java
class 자식클래스 extends 부모클래스{ // extends를 이용해 상속받을 수 있다.

}
```
* 자바에서는 1개의 부모 클래스로부터의 단일 상속만 허용된다. (인터페이스의 경우 다중 상속 가능)
* 부모 클래스는 여러개의 자식 클래스에게 상속이 가능하다.


### 메소드 오버라이딩
* 상위 클래스로부터 상속받은 메서드와 동일한 이름의 메서드를 재정의 하는 것이다.
* 메서드의 다형성을 구현할 수 있다.
* 오바라이딩의 3가지 조건이 있다.
  * 메서드의 선언부(메서드 이름, 매개변수, 반환타입)가 상위클래스와 동일해야 한다.
  * 접근 제어자의 범위가 상위 클래스의 메서드보다 같거나 넓어야 한다.
  * 예외는 상위 클래스의 메서드보다 많이 선언할 수 없다.

>super() vs super
> 
> super()
>* this()와 달리 상위클래스의 생성자를 호출하는데 사용된다.
>* 반드시 첫줄에 위치해야 한다.
>
> super
> * this와 달리 상위클래스의 객체를 의미한다.


### Object 클래스
* Object 클래스는 자바의 클래스 상속 계층도에서 최상위에 위치한 상위 클래이며, 자바의 모든 클래스는 Object클래스를 상속 받는다.
* 자바 컴파일러는 아무런 상속을 받지 않는 클래스에 자동적으로 `extends Object`를 추가하여 Object 클래스를 상속받도록 한다.





### 포함(composite) vs 상속
* 포함은 상속처럼 클래스를 재사용 할 수 있는 방법으로, **클래스의 멤버로 다른 클래스 타입의 참조변수를 선언하는 방법**이다.
* 상속 관계를 맺어줄지 포함 관계를 맺어줄지의 기준을 쉽게 생각하는 법은 `~은~이다.(is-a)`관계인지 `~은 ~을 가지고 있다.(has-a)` 관계인지 생각해보는 것이다.

## 2. 캡슐화(Encapsulation)
* 특정 객체 안에 관련된 속성과 기능을 하나의 캡슐로 만들어 데이터를 외부로부터 보호하는 것을 말한다.

### 캡슐화의 장점
* 데이터를 보호할 수 있다.
* 내부적으로만 사용되는 데이터에 대한 불필요한 외부 노출을 방지한다
* 데이터가 변경되더라도 다른객체에 영향을 주지 않기에 독립성을 확보할 수 있다.
* 유지보수와 코드 확장 시 오류의 범위를 최소화할 수 있다.

### 패키지
* 패키지란 특정한 목적을 공유하는 클래스와 인터페이스의 묶음이다.
* 우리가 컴퓨터를 사용할 때 폴더를 만들어 관련된 내용들을 정리해 놓은 것과 같은 느낌이다.
* 하나의 패키지 안에 있는 클래스나 인터페이스 파일들은 모두 그 패키지에 속하게 된다.
```java
package 상위패키지.하위패키지; 
                            
public class ClassName {
    
}
```
* 패키지 명은 보통 소문자로 만든다.
* 같은 클래스명을 갖고 있더라도 다른 패키지에 포함되어 있으면 충돌하지 않는다.
#### import
```java
import 패키지명.클래스명;   //해당 페키지의 클래스를 불러옴
import 패키지명.*;  // 해당 패키지의 모든 클래스들을 불러옴
```

### 접근 제어자

* 접근 제어자를 사용하면 클래스 외부로의 불필요한 데이터 노출을 방지할 수 있다.
* 

|   접근 제어자    |  클래스 내  | 패키지 내  | 다른 패키지의<br>하위 클래스  | 패키지 외  |
|:-----------:|:-------:|:------:|:------------------:|:------:|
|   private   |    O    |   X    |         X          |   X    |
|   default   |    O    |   O    |         X          |   X    |
|  protected  |    O    |   O    |         O          |   X    |
|   public    |    O    |   O    |         O          |   O    |

### setter, getter
* 자바에서 데이터 보호와 은닉을 위해 접근 제어자를 사용한다.
* 객체지향의 캡슐화의 목적을 달성하면서도 데이터의 변경이 필요한 경우에는 setter 메서드와 getter 메서드를 이용하면 된다.
* 일반적으로 메서드명 앞에 `set-`, `get-`을 붙여서 정의한다.
* setter 메서드를 이용하여 데이터 값을 할당할 수 있고, getter 메서드를 이용하여 데이터 값을 불러올 수 있다.
```java
//Setter 메소드
class setterEx {
  private int pirce;

  void setPrice(int num) {
    this.price = price;
  }
}
//Getter 메소드
class getterEx {
  private int price;

  int getPrice() {
    return price;
  }
}
```

## 3. 다형성(Polymorphism)
* 하나의 타입에 여러가지 객체를 대입하여 다양한 결과를 얻어내는 성질이다.
* 자바에서 다형성은 부모 클래스 타입 참조 변수로 여러 자손 클래스의 객체를 참조할 수 있도록 하여 구현하고 있다.
* 참조변수가 사용할 수 있는 멤버 개수가 실제 객체의 멤버 개수보다 같거나 적어야 참조할 수 있다.(자식 타입 참조변수로 부모 클래스 객체를 참조할 수 없다.)
* 만약 자식 타입이 부모 클래스 타입으로 형변환 된 이후에는 참조 변수는 자식객체를 참조하지만, 참조 변수로 접근 가능한 멤버는 부모클래스 멤버로만 한정된다.
  (부모클래스에는 없고 자식클래스에만 있는 멤버에 접근할 수 없다.)

### 다형성의 장점
* 여러 객체의 타입을 하나의 타입으로 관리가 가능하다. (타입을 따로 따로 정의하지 않아도 되므로 코드양이 줄어든다.)
* 유연하면서 유지보수에 용이한 프로그래밍을 구현할 수 있다.

### 참조변수의 형변환
* 자바에서는 참조 변수의 형변환이 가능하며, 서로 상속관계에 있는 클래스 사이에서만 가능하다.
* 쉽게 말하면 형변환을 통해 사용할 수 있는 멤버들을 조절할 수 있다. (다형성)
* ❗ 형변환 시 참조변수가 가리키는 객체가 무엇인지 확인하는것이 중요하다.

#### 1) 자동 형변환
* 부모클래스 참조변수에 자식객체 타입을 대입하면 자동으로 형변환이 일어난다. (Up casting)
* 자동으로 형변환이 되기 때문에 형변환 연산자 `()`를 생략할 수 있다.
* 부모 타입 참조 변수는 자식 객체를 참조하지만, 참조 변수로 접근 가능한 멤버는 부모클래스 멤버로만 한정된다.
  (❗메소드가 자식클래스에서 오버라이딩 되었다면 오버라이딩된 메소드가 대신 호출 됨)

#### 2) 강제 형변환
* 부모타입을 **다시** 자식타입으로 형변환하는 것이다. (Down Casting)
* 자식타입이 부모타입으로 자동 변환 후 다시 자식타입으로 변환할 때 강제 타입 변환을 사용할 수 있다.
* 자동으로 형변환이 되지 않기 떄문에 형변환 연산자`()`를 사용하여 강제 형변환을 수행한다.
  ```java
  Child child = (Child) parent; 
  ```
* 자식타입에 선언된 필드와 메소드를 사용해야 하는 경우 사용된다.
* 강제타입 변환은 부모타입으로 형변환 되어 있는 상태에서만 가능하기 때문에, instanceof 연산자를 사용하여 그 상태를 확인할 수 있다.
  > instanceof 연산자
  >* 참조변수의 형변환이 가능한 지 여부를 boolean타입으로 확인할 수 있는 자바의 문법이다.
  >* 프로젝트의 규모가 커지거나, 소스코드가 너무 길어지는 등 일일이 생성 객체의 타입을 확인하기 어려운 상황에서 유용하다.
  >* ❗instanceof를 사용하면 외부의 객체에서 해당 객체가 어떤 타입인지를 알 수 있기 때문에 캡슐화가 깨질 수 있으므로 무작정 사용하진 말자.
  >```java
  >참조변수 instanceof 타입
  >```
 
## 4. 추상화(Abstraction)
* 기존 클래스들의 공통적인 요소를 뽑아서 상위클래스를 만들어 내는 것이다.

### 추상화 장점
* 중복코드를 줄일 수 있어 코드의 재사용성을 증가시킨다.
* 그로 인해 생산성이 증가하고, 가독성 증가하며, 유지보수에 용이해진다.

### abstract 제어자
* 추상적인이란 뜻으로 클래스와 메서드를 형용하는 키워드로 사용된다. (abstract method, abstract class)
* abstract의 가장 핵심적인 개념은 '미완성'이다.




___
참고

https://blog.naver.com/PostView.nhn?blogId=heartflow89&logNo=220960019390

http://wiki.hash.kr/index.php?title=%EC%BA%A1%EC%8A%90%ED%99%94&mobileaction=toggle_view_mobile

https://hearthole.tistory.com/17

codestates 교육
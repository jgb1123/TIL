# 예외
## item69. 예외는 진짜 예외 상황에만 사용하라
### 예외를 잘못 사용한 예시
```java
try {
    int i = 0;
    while(true)
        range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e) {
}
```
* 위 예시는 전혀 직관적이지 않기 때문에 읽어도 무슨 코드인지 알기 어렵다.
* 위 코드는 무한 루프를 돌다가 배열의 끝에 도달해 `ArrayIndexOutOfBoundsException`이 발생하면 끝을 내는 코드인 것이다.
* 이 코드를 표준적인 관용구대로 작성했으면 훨씬 이해하기 쉬웠을 것이다.
```java
for (Mountain m : range)
    m.climb();
```
### 예외는 예외 상황에서만 사용해야 한다
* 예외는 절대로 일상적인 제어 흐름용으로 쓰여서는 안된다.
* 표준적이고 쉽게 이해되는 관용구를 사용하고, 성능 개선을 목적으로 과하게 복잡하게 만드는 기법은 자제해야 한다.
  * 실제로 성능이 좋아지더라도 자바 플랫폼이 꾸준히 개선되고 있으므로, 최적화로 얻은 상대적인 우위가 오래가지 않을 수도 있다.
  * 반면에, 과하게 복잡하게 만드는 기법에 숨겨진 미묘한 버그로 인해 어려워진 유지보수 문제는 계속 이어진다.
* 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.
* 특정 상태에서만 호출할 수 있는 상태 의존적 메서드를 제공하는 클래스는 상태 검사 메서드도 함께 제공해야 한다.
  * `Iterator` 인터페이스의 `next`와 `hasNext`가 각각 상태 의존적 메서드와 상태 검사 메서드에 해당한다.
  * 상태검사 메서드로 인해 간편하게 작성할 수 있는 코드들이 있다.
  ```java
  for (Iterator<Foo> i = collection.iterator(); i.hasNext(); ) {
    Foo foo = i.next();
    ...
  }
  ```

### 정리
* 예외는 예외 상황에서 쓸 의도로 설계되었다.
* 따라서 정상적인 제어 흐름에서 사용해서는 안되며, 이를 프로그래머에게 강요하는 API를 만들어서도 안된다.


## item70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

### 검사예외
* 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용해야 한다.
* 이것은 검사와 비검사 예외를 구분하는 기본 규칙이다.
* 검사 예외를 던지면 호출자가 그 예외를 `catch`로 잡아 처리하거나, 더 바깥으로 전파하도록 강제하게 된다.
* 메서드 선언에 포함된 검사 예외들은 그 메서드를 호출했을 때 발생할 수 있는 결과임을 API 사용자에게 알려줄 수 있다.
* 물론, 사용자는 예외를 잡기만 하고 별다른 조치를 취하지 않을 수도 있지만 좋지 않은 생각이다.

### 비검사 throwable
* 비검사 `throwable`은 런타임 예외와 에러가 있다.
* 비검사 `throwable`은 프로그램에서 잡을 필요가 없거나, 혹은 통상적으로는 잡지 말아야 한다.
  * 프로그램에서 검사 예외나 에러를 던지는 경우는, 복구가 불가능하거나 더 실행해봐야 득보다는 실이 많은 경우이다.
* 비검사 `throwable`을 잡지 않은 쓰레드는 적절한 오류 메시지를 뱉으며 중단된다.

#### 런타임 에러
* 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용해야 한다.
* 런타임 예외의 대부분은 전제조건을 만족하지 못했을 때 발생한다.
* 하지만 문제가 생겼을 때, 복구할 수 있는 상황인지, 프로그래밍 오류인지가 항상 명확히 구분이 되지는 않는다.
* 예시로, 자원 고갈은 말도 안되는 크기의 배열을 할당해 생긴 프로그래밍 오류일 수도 있고, 진짜로 자원이 부족해서 발생한 문제일 수도 있다.
* 자원이 일시적으로만 부족하거나, 수요가 순간적으로만 몰린 것이라면 충분히 복구할 수 있는 상황일 것이다.
* 따라서 해당 자원 고갈 상황이 복구될 수 있는 것인지는 API설계자에 판단에 달려있다.
* 복구가 가능하다고 믿으면 검사 예외를, 그렇지 않다면 런타임 예외를 사용해야 하며, 확신하기 어렵다면 비검사 예외를 선택하는 편이 나을수도 있다.

#### 에러
* 에러는 보통 JVM이 자원 부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황을 나타낼 때 사용한다.
* 자바 언어 명세가 요구하는 것은 아니지만 업계에 널리 퍼진 규약으로는, `Error` 클래스를 상속해 하위 클래스를 만드는 일은 자제해야 한다.
  * 직접 구현하게 되는 비검사 `throwable`은 모두 `RuntimeException`의 하위 클래스여야 한다.
  * `Error`는 상속하지 말아야 하며, `throw`문으로 직접 던지는 일도 없어야 한다. (AssertionError는 예외)

#### Exception, RuntimeException, Error를 상속하지 않는 throwable
* Exception, RuntimeException, Error를 상속하지 않는 throwable을 만들순 있다.
* 하지만 이러한 throwable은 좋은 점이 하나도 없으므로, 절대 사용하지 말아야 한다.
* 이러한 throwable 정상적인 검사 예외보다 나은점이 하나도 없고, API사용자를 헷갈리게만 만든다.

### 검사 예외는 메서드도 함께 제공해야 한다.
* 예외 또한 어떠한 메서드라도 정의할 수 있는 완벽한 객체이다.
* 예외의 메서드는 주로 그 예외를 일으킨 상황에 관한 정보를 코드 형태로 전달하는데 쓰인다.
  * 이런 메서드가 없으면 프로그래머들은 오류 메시지를 파싱해 정보를 빼내야 하는데, 매우 좋지 않은 습관이다.
  * throwable 클래스들은 대부분 오류 메시지 포맷을 상세히 기술하지 않는데, JVM이나 릴리스에 따라 포맷이 달라질 수 있다는 뜻이다.
  * 따라서 메시지 문자열을 파싱해 얻은 코드는 깨지기 쉽고 다른 환경에서는 동작하지 않을 수 있다.
* 검사 예외는 일반적으로 복구할 수 있는 조건일 때 발생한다.
* 따라서 호출자가 예외 상황에서 벗어나는데 필요한 정보를 알려주는 메서드를 함께 제공해주어야 한다.
* 예시로, 쇼핑몰에서 구입하려는데 카드 잔고가 부족하여 검사 예외가 발생한 경우, 잔고가 얼마나 부족한지를 알려주는 접근자 메서드를 제공해야 한다.

### 정리
* 복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 예외를 던져야 한다.
* 확실하지 않다면 비검사 예외를 던져야 한다.
* 검사 예외도 아니고 런타임 예외도 아닌 `throwable`은 정의하지 말아야 한다.
* 검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공해줘야 한다.

## item71. 필요 없는 검사 예외 사용은 피하라
### 불필요한 검사 예외는 불편한 API를 만든다
* 검사 예외를 싫어하는 프로그래머들도 많지만, 검사 예외를 제대로 활용하면 API와 프로그램의 질을 높일 수 있다.
* 결과를 코드로 반환하거나 비검사 예외를 던지는 것과 달리, 검사 예외는 발생한 문제를 개발자가 처리하여 안전성을 높일 수 있게 해준다.
* 하지만 검사 예외를 과하게 사용하면 오히려 사용하기 불편한 API가 된다.
* 어떤 메서드가 검사 예외를 던질 수 있다고 선언되어 있다면, 이것은 호출하는 코드에서는 catch 블록을 두어 그 예외를 처리하거나 더 바깥으로 던져야 한다.
* 또한 검사 예외를 던지는 메서드는 스트림 안에서 직접 사용할 수 없기 때문에 더더욱 불편해진다.

### 검사 예외를 사용하면 안되는 경우
* API를 제대로 사용해도 발생할 수 있는 예외이거나, 프로그래머가 의미 있는 조치를 취할 수 있는 경우에는 검사 예외를 사용해야 한다.
* 하지만 그렇지 않다면 비검사 예외를 사용하는 것이 좋다.
* 검사 예외가 프로그래머에게 덜어줄 수 있는 부담은 메서드가 단 하나의 검사 예외만 던질 때가 더욱 더 크다.
* 이미 다른 검사 예외도 던지는 상황에서 또 다른 검사 예외를 추가하는 경우라면, catch문 하나 추가하는 선에서 끝이다.
* 검사 예외가 단 하나뿐이라면, 그 예외 때문에 API 사용자는 try 블록을 추가해야 하며, 스트림에서 사용하지도 못하게 된다.

### 검사 예외 사용을 피하는 방법
#### 옵셔널을 반환하는 방법
* 검사 예외 사용을 피할 수 있는 가장 쉬운 방법으로, 적절한 결과 타입을 담은 옵셔널을 반환하는 것이다.
* 검사 예외를 던지는 대신 단순히 빈 옵셔널을 반환하면 된다.
* 이 방식의 단점은 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다.
* 예외를 사용하면 구체적인 예외 타입과 그 타입이 제공하는 메서드들을 활용해 부가정보를 제공할 수 있기 때문이다.
#### 메서드를 분리하여 리팩토링하는 방법
* 검사 예외를 던지는 메서드를 2개로 분리하여 비검사 예외로 바꾸는 방법으로 검사 예외 사용을 피할 수 있다.
* 첫 메서드에서 예외가 던져질지 여부를 boolean 값으로 반환하여 사용하는 방법이다.
* 이 방법은 모든 상황에 적용할 수는 없고, 적용할 수 있는 상황이라면 더 쓰기 편한 API를 제공할 수 있다.
* 코드가 깔끔해지는 것은 아니지만, 더 유연해지긴 한다.
```java
if (obj.actionPermitted(args)) {  // 예외가 던져질지 여부를 체크하는 메서드 
    obj.action(args);
} else {
    // 예외상황에 대처하는 코드
}
```
* 이 메서드가 성공한다는 것을 안다거나, 실패 시 쓰레드를 중단하길 원하면 한줄로 작성할 수도 있다.
```java
obj.action(args);
```
* 물론 외부 동기화 없이 여러 쓰레드가 동시에 접근하거나, 외부 요인에 의해 상태가 변할 수 있으면 이러한 방식은 적절하지 않다.
  * 호출 사이에 객체의 상태가 변할 수 있기 때문이다.

### 정리
* 꼭 필요한 곳에만 사용한다면 검사 예외는 프로그램의 안전성을 높여준다.
* 하지만 남용하게 되면 쓰기 어려운 API만 생겨나게 되므로, API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던져야 한다.
* 복구가 가능하며 호출자가 그 처리를 해주길 바라면, 옵셔널을 반환해도 될지 고민해보고, 옵셔널만으로 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 사용해야 한다.

## item72. 표준 예외를 사용하라
### 코드의 재사용
* 좋은 프로그래머는 더 많은 코드를 재사용한다.
* 예외도 마찬가지로 재사용 하는 것이 좋다.
* 자바 라이브러리는 대부분 API에서 사용하기에 충분한 수의 예외를 제공해준다.

### 표준 예외 사용의 장점
* 표준 예외를 재사용하면 가장 좋은 점은, 직접 작성한 API가 다른 사람이 익히고 사용하기 쉬워진다는 점이다.
  * 이미 많은 프로그래머들에게 익숙해진 규약을 그대로 따르고 있기 때문이다.
* 또한 직접 작성한 API를 사용하는 프로그램도 낯선 예외를 사용하지 않게 되어 읽기 쉽게 된다.
* 게다가 예외 클래스 수가 적을수록 메모리 사용량도 줄어들고, 클래스를 적재하는 시간도 적게 걸린다.

### 자주 사용되는 표준 예외
#### IllegalArgumentException
* 호출자가 인수로 부적절한 값을 넘길 때 던지는 예외이다.
* 예시로 반복 횟수를 지정하는 매개변수에 음수를 건넬 때 이 예외를 사용할 수 있다.

#### IllegalStateException
* 대상 객체의 상태가 호출된 메서드를 수행하기에 적잡하지 않을 때 주로 사용되는 예외이다.
* 예시로, 제대로 초기화되지 않은 객체를 사용하려고 할 때 이 예외를 사용할 수 있다.

#### NullPointerException
* null 값을 허용하지 않는 메서드에 null을 건넬 때 사용되는 예외이다.

#### IndexOutOfBoundsException
* 어떠한 시퀀스의 허용 범위를 넘는 값을 건넬 때 사용되는 예외이다.

#### ConcurrentModificationException
* 단일 쓰레드에서 사용하려고 설계한 객체를 여러 쓰레드가 동시에 수정하려고 할 때 사용되는 예외이다.
* 동시 수정을 확실히 검출할 수 있는 안정된 방법은 없기 때문에, 이 예외는 문제가 생길 가능성을 알려주는 정도의 역할로 쓰인다.

#### UnsupportedOperationException
* 클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때 사용되는 예외이다.
* 대부분 객체는 자신이 정의한 메서드를 모두 지원하기 때문에 흔히 쓰이는 예외는 아니다.
* 보통 구현하려는 인터페이스의 메서드 일부를 구현할 수 없을 때 사용된다.
* 예시로, 원소를 넣을 수만 있는 List 구현체에 remove 메서드를 호출하면 이 예외를 던진다.

### 재사용하지 말아야 할 예외
* `Exception`, `RuntimeException`, `Throwable`, `Error`는 직접 재사용하지 말아야 한다.
* 이 클래스들은 추상 클래스라고 생각해야 한다.
* 이 예외들은 다른 예외들의 상위 클래스이기 때문에, 여러 성격의 예외들을 포괄하는 클래스이므로 안정적으로 테스트할 수 없다.

### 그 외의 예외들
* API 문서를 참고해 해당 예외가 어떤 상황에서 던져지는지 확인해야 한다.
* 예외의 이름 뿐만 아니라, 예외가 던져지는 맥락도 부합할 때만 재사용해야 한다.
* 더 많은 정보를 제공하길 원하는 경우엔 표준 예외를 확장해서 사용하면 된다.
* 예외는 직렬화할 수 있는데, 직렬화에는 많은 부담이 따르기 때문에, 이것은 본인만의 예외를 새로 만들지 않아야 할 이유가 된다.

# 예외
## item69. 예외는 진짜 예외 상황에만 사용하라
### 예외를 잘못 사용한 예시
```java
try {
    int i = 0;
    while(true)
        range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e) {
}
```
* 위 예시는 전혀 직관적이지 않기 때문에 읽어도 무슨 코드인지 알기 어렵다.
* 위 코드는 무한 루프를 돌다가 배열의 끝에 도달해 `ArrayIndexOutOfBoundsException`이 발생하면 끝을 내는 코드인 것이다.
* 이 코드를 표준적인 관용구대로 작성했으면 훨씬 이해하기 쉬웠을 것이다.
```java
for (Mountain m : range)
    m.climb();
```
### 예외는 예외 상황에서만 사용해야 한다
* 예외는 절대로 일상적인 제어 흐름용으로 쓰여서는 안된다.
* 표준적이고 쉽게 이해되는 관용구를 사용하고, 성능 개선을 목적으로 과하게 복잡하게 만드는 기법은 자제해야 한다.
  * 실제로 성능이 좋아지더라도 자바 플랫폼이 꾸준히 개선되고 있으므로, 최적화로 얻은 상대적인 우위가 오래가지 않을 수도 있다.
  * 반면에, 과하게 복잡하게 만드는 기법에 숨겨진 미묘한 버그로 인해 어려워진 유지보수 문제는 계속 이어진다.
* 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.
* 특정 상태에서만 호출할 수 있는 상태 의존적 메서드를 제공하는 클래스는 상태 검사 메서드도 함께 제공해야 한다.
  * `Iterator` 인터페이스의 `next`와 `hasNext`가 각각 상태 의존적 메서드와 상태 검사 메서드에 해당한다.
  * 상태검사 메서드로 인해 간편하게 작성할 수 있는 코드들이 있다.
  ```java
  for (Iterator<Foo> i = collection.iterator(); i.hasNext(); ) {
    Foo foo = i.next();
    ...
  }
  ```

### 정리
* 예외는 예외 상황에서 쓸 의도로 설계되었다.
* 따라서 정상적인 제어 흐름에서 사용해서는 안되며, 이를 프로그래머에게 강요하는 API를 만들어서도 안된다.


## item70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

### 검사예외
* 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용해야 한다.
* 이것은 검사와 비검사 예외를 구분하는 기본 규칙이다.
* 검사 예외를 던지면 호출자가 그 예외를 `catch`로 잡아 처리하거나, 더 바깥으로 전파하도록 강제하게 된다.
* 메서드 선언에 포함된 검사 예외들은 그 메서드를 호출했을 때 발생할 수 있는 결과임을 API 사용자에게 알려줄 수 있다.
* 물론, 사용자는 예외를 잡기만 하고 별다른 조치를 취하지 않을 수도 있지만 좋지 않은 생각이다.

### 비검사 throwable
* 비검사 `throwable`은 런타임 예외와 에러가 있다.
* 비검사 `throwable`은 프로그램에서 잡을 필요가 없거나, 혹은 통상적으로는 잡지 말아야 한다.
  * 프로그램에서 검사 예외나 에러를 던지는 경우는, 복구가 불가능하거나 더 실행해봐야 득보다는 실이 많은 경우이다.
* 비검사 `throwable`을 잡지 않은 쓰레드는 적절한 오류 메시지를 뱉으며 중단된다.

#### 런타임 에러
* 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용해야 한다.
* 런타임 예외의 대부분은 전제조건을 만족하지 못했을 때 발생한다.
* 하지만 문제가 생겼을 때, 복구할 수 있는 상황인지, 프로그래밍 오류인지가 항상 명확히 구분이 되지는 않는다.
* 예시로, 자원 고갈은 말도 안되는 크기의 배열을 할당해 생긴 프로그래밍 오류일 수도 있고, 진짜로 자원이 부족해서 발생한 문제일 수도 있다.
* 자원이 일시적으로만 부족하거나, 수요가 순간적으로만 몰린 것이라면 충분히 복구할 수 있는 상황일 것이다.
* 따라서 해당 자원 고갈 상황이 복구될 수 있는 것인지는 API설계자에 판단에 달려있다.
* 복구가 가능하다고 믿으면 검사 예외를, 그렇지 않다면 런타임 예외를 사용해야 하며, 확신하기 어렵다면 비검사 예외를 선택하는 편이 나을수도 있다.

#### 에러
* 에러는 보통 JVM이 자원 부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황을 나타낼 때 사용한다.
* 자바 언어 명세가 요구하는 것은 아니지만 업계에 널리 퍼진 규약으로는, `Error` 클래스를 상속해 하위 클래스를 만드는 일은 자제해야 한다.
  * 직접 구현하게 되는 비검사 `throwable`은 모두 `RuntimeException`의 하위 클래스여야 한다.
  * `Error`는 상속하지 말아야 하며, `throw`문으로 직접 던지는 일도 없어야 한다. (AssertionError는 예외)

#### Exception, RuntimeException, Error를 상속하지 않는 throwable
* Exception, RuntimeException, Error를 상속하지 않는 throwable을 만들순 있다.
* 하지만 이러한 throwable은 좋은 점이 하나도 없으므로, 절대 사용하지 말아야 한다.
* 이러한 throwable 정상적인 검사 예외보다 나은점이 하나도 없고, API사용자를 헷갈리게만 만든다.

### 검사 예외는 메서드도 함께 제공해야 한다.
* 예외 또한 어떠한 메서드라도 정의할 수 있는 완벽한 객체이다.
* 예외의 메서드는 주로 그 예외를 일으킨 상황에 관한 정보를 코드 형태로 전달하는데 쓰인다.
  * 이런 메서드가 없으면 프로그래머들은 오류 메시지를 파싱해 정보를 빼내야 하는데, 매우 좋지 않은 습관이다.
  * throwable 클래스들은 대부분 오류 메시지 포맷을 상세히 기술하지 않는데, JVM이나 릴리스에 따라 포맷이 달라질 수 있다는 뜻이다.
  * 따라서 메시지 문자열을 파싱해 얻은 코드는 깨지기 쉽고 다른 환경에서는 동작하지 않을 수 있다.
* 검사 예외는 일반적으로 복구할 수 있는 조건일 때 발생한다.
* 따라서 호출자가 예외 상황에서 벗어나는데 필요한 정보를 알려주는 메서드를 함께 제공해주어야 한다.
* 예시로, 쇼핑몰에서 구입하려는데 카드 잔고가 부족하여 검사 예외가 발생한 경우, 잔고가 얼마나 부족한지를 알려주는 접근자 메서드를 제공해야 한다.

### 정리
* 복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 예외를 던져야 한다.
* 확실하지 않다면 비검사 예외를 던져야 한다.
* 검사 예외도 아니고 런타임 예외도 아닌 `throwable`은 정의하지 말아야 한다.
* 검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공해줘야 한다.

## item71. 필요 없는 검사 예외 사용은 피하라
### 불필요한 검사 예외는 불편한 API를 만든다
* 검사 예외를 싫어하는 프로그래머들도 많지만, 검사 예외를 제대로 활용하면 API와 프로그램의 질을 높일 수 있다.
* 결과를 코드로 반환하거나 비검사 예외를 던지는 것과 달리, 검사 예외는 발생한 문제를 개발자가 처리하여 안전성을 높일 수 있게 해준다.
* 하지만 검사 예외를 과하게 사용하면 오히려 사용하기 불편한 API가 된다.
* 어떤 메서드가 검사 예외를 던질 수 있다고 선언되어 있다면, 이것은 호출하는 코드에서는 catch 블록을 두어 그 예외를 처리하거나 더 바깥으로 던져야 한다.
* 또한 검사 예외를 던지는 메서드는 스트림 안에서 직접 사용할 수 없기 때문에 더더욱 불편해진다.

### 검사 예외를 사용하면 안되는 경우
* API를 제대로 사용해도 발생할 수 있는 예외이거나, 프로그래머가 의미 있는 조치를 취할 수 있는 경우에는 검사 예외를 사용해야 한다.
* 하지만 그렇지 않다면 비검사 예외를 사용하는 것이 좋다.
* 검사 예외가 프로그래머에게 덜어줄 수 있는 부담은 메서드가 단 하나의 검사 예외만 던질 때가 더욱 더 크다.
* 이미 다른 검사 예외도 던지는 상황에서 또 다른 검사 예외를 추가하는 경우라면, catch문 하나 추가하는 선에서 끝이다.
* 검사 예외가 단 하나뿐이라면, 그 예외 때문에 API 사용자는 try 블록을 추가해야 하며, 스트림에서 사용하지도 못하게 된다.

### 검사 예외 사용을 피하는 방법
#### 옵셔널을 반환하는 방법
* 검사 예외 사용을 피할 수 있는 가장 쉬운 방법으로, 적절한 결과 타입을 담은 옵셔널을 반환하는 것이다.
* 검사 예외를 던지는 대신 단순히 빈 옵셔널을 반환하면 된다.
* 이 방식의 단점은 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다.
* 예외를 사용하면 구체적인 예외 타입과 그 타입이 제공하는 메서드들을 활용해 부가정보를 제공할 수 있기 때문이다.
#### 메서드를 분리하여 리팩토링하는 방법
* 검사 예외를 던지는 메서드를 2개로 분리하여 비검사 예외로 바꾸는 방법으로 검사 예외 사용을 피할 수 있다.
* 첫 메서드에서 예외가 던져질지 여부를 boolean 값으로 반환하여 사용하는 방법이다.
* 이 방법은 모든 상황에 적용할 수는 없고, 적용할 수 있는 상황이라면 더 쓰기 편한 API를 제공할 수 있다.
* 코드가 깔끔해지는 것은 아니지만, 더 유연해지긴 한다.
```java
if (obj.actionPermitted(args)) {  // 예외가 던져질지 여부를 체크하는 메서드 
    obj.action(args);
} else {
    // 예외상황에 대처하는 코드
}
```
* 이 메서드가 성공한다는 것을 안다거나, 실패 시 쓰레드를 중단하길 원하면 한줄로 작성할 수도 있다.
```java
obj.action(args);
```
* 물론 외부 동기화 없이 여러 쓰레드가 동시에 접근하거나, 외부 요인에 의해 상태가 변할 수 있으면 이러한 방식은 적절하지 않다.
  * 호출 사이에 객체의 상태가 변할 수 있기 때문이다.

### 정리
* 꼭 필요한 곳에만 사용한다면 검사 예외는 프로그램의 안전성을 높여준다.
* 하지만 남용하게 되면 쓰기 어려운 API만 생겨나게 되므로, API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던져야 한다.
* 복구가 가능하며 호출자가 그 처리를 해주길 바라면, 옵셔널을 반환해도 될지 고민해보고, 옵셔널만으로 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 사용해야 한다.

## item72. 표준 예외를 사용하라
### 코드의 재사용
* 좋은 프로그래머는 더 많은 코드를 재사용한다.
* 예외도 마찬가지로 재사용 하는 것이 좋다.
* 자바 라이브러리는 대부분 API에서 사용하기에 충분한 수의 예외를 제공해준다.

### 표준 예외 사용의 장점
* 표준 예외를 재사용하면 가장 좋은 점은, 직접 작성한 API가 다른 사람이 익히고 사용하기 쉬워진다는 점이다.
  * 이미 많은 프로그래머들에게 익숙해진 규약을 그대로 따르고 있기 때문이다.
* 또한 직접 작성한 API를 사용하는 프로그램도 낯선 예외를 사용하지 않게 되어 읽기 쉽게 된다.
* 게다가 예외 클래스 수가 적을수록 메모리 사용량도 줄어들고, 클래스를 적재하는 시간도 적게 걸린다.

### 자주 사용되는 표준 예외
#### IllegalArgumentException
* 호출자가 인수로 부적절한 값을 넘길 때 던지는 예외이다.
* 예시로 반복 횟수를 지정하는 매개변수에 음수를 건넬 때 이 예외를 사용할 수 있다.

#### IllegalStateException
* 대상 객체의 상태가 호출된 메서드를 수행하기에 적잡하지 않을 때 주로 사용되는 예외이다.
* 예시로, 제대로 초기화되지 않은 객체를 사용하려고 할 때 이 예외를 사용할 수 있다.

#### NullPointerException
* null 값을 허용하지 않는 메서드에 null을 건넬 때 사용되는 예외이다.

#### IndexOutOfBoundsException
* 어떠한 시퀀스의 허용 범위를 넘는 값을 건넬 때 사용되는 예외이다.

#### ConcurrentModificationException
* 단일 쓰레드에서 사용하려고 설계한 객체를 여러 쓰레드가 동시에 수정하려고 할 때 사용되는 예외이다.
* 동시 수정을 확실히 검출할 수 있는 안정된 방법은 없기 때문에, 이 예외는 문제가 생길 가능성을 알려주는 정도의 역할로 쓰인다.

#### UnsupportedOperationException
* 클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때 사용되는 예외이다.
* 대부분 객체는 자신이 정의한 메서드를 모두 지원하기 때문에 흔히 쓰이는 예외는 아니다.
* 보통 구현하려는 인터페이스의 메서드 일부를 구현할 수 없을 때 사용된다.
* 예시로, 원소를 넣을 수만 있는 List 구현체에 remove 메서드를 호출하면 이 예외를 던진다.

### 재사용하지 말아야 할 예외
* `Exception`, `RuntimeException`, `Throwable`, `Error`는 직접 재사용하지 말아야 한다.
* 이 클래스들은 추상 클래스라고 생각해야 한다.
* 이 예외들은 다른 예외들의 상위 클래스이기 때문에, 여러 성격의 예외들을 포괄하는 클래스이므로 안정적으로 테스트할 수 없다.

### 그 외의 예외들
* API 문서를 참고해 해당 예외가 어떤 상황에서 던져지는지 확인해야 한다.
* 예외의 이름 뿐만 아니라, 예외가 던져지는 맥락도 부합할 때만 재사용해야 한다.
* 더 많은 정보를 제공하길 원하는 경우엔 표준 예외를 확장해서 사용하면 된다.
* 예외는 직렬화할 수 있는데, 직렬화에는 많은 부담이 따르기 때문에, 이것은 본인만의 예외를 새로 만들지 않아야 할 이유가 된다.

## item73. 추상화 수준에 맞는 예외를 던지라
### 추상화 수준에 맞는 예외를 사용해야 하는 이유
* 수행하려는 일과 관련이 없어 보이는 예외가 발생하여 당황스러운 상황이 생기는 경우가 있다.
* 메서드가 저수준 예외를 처리하지 않고 바깥으로 전파해버릴 때 종종 일어나는 일이다.
* 이러한 문제는 내부 구현 방식을 드러내어 윗 레벨 API를 오염시킨다.
* 또한 다음 릴리스에서 구현 방식을 바꾸면 다른 예외가 발생하여 기존 클라이언트 프로그램을 깨지게 할 수도 있다.

### 예외 번역
* 이 문제를 피하려면 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔서 던져야 한다.
* 이것을 예외 번역(Exception Translation) 이라고 한다.
```java
try {
    ... 
} catch (LowerLevelException e) {
    // 추상화 수준에 맞게 번역
    throw new HigherLevelException(...);
}
```

### 예외 연쇄
* 예외 번역을 할 때, 저수준 예외가 디버깅에 도움이 된다면, 예외 연쇄(Exception Chaining)를 사용하는 것이 좋다.
* 예외 연쇠는 문제의 근본 원인인 저수준 예외를 고수준 예외에 실어 보내는 방식이다.
* 그러면 별도의 접근자 메서드(`getCause`)를 통해 필요하면 언제든 저수준 예외를 꺼내 볼 수 있다.
```java
try {
    ...
} catch {
    throw new HigherLevelException(cause);
}
```
* 고수준 예외의 생성자는 예외 연쇄용으로 설계된 상위 클래스의 생성자에 이 원인을 건내주어 최종적으로 `Throwable` 생성자까지 건네지도록 한다.

```java
class HigherLevelException extends Exception {
    HigherLevelException(Throwable cause) {
        super(cause);
    }
}
```

* 대부분의 표준 예외는 예외 연쇄용 생성자를 갖추고 있으며, 그렇지 않은 예외라고 해도 `Throwable`의 `initCause` 메서드를 이용해 원인을 직접 설정할 수 있다.
* 연쇄는 문제의 원인을 프로그램에서 접근할 수 있게 해주며, 원인과 고수준 예외의 스택 추적 정보를 잘 통합해준다.

### 예외 번역을 남용해서는 안된다.
* 무턱대고 예외를 전파하는 것 보다 예외 번역이 좋은 방법이긴 하지만, 그렇다고 남용해서는 안된다.
* 가능하다면 저수준 메서드가 반드시 성공하도록 하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선이다.
  * 때로는 상위 계층 메서드의 매개변수 값을 아래 계층 메서드로 건네기 전에 미리 검사하는 방법으로 해결할 수 있다.
* 아래 계층에서의 예외를 피할 수 없으면, 상위 계층에서 그 예외를 조용히 처리하여 문제를 API 호출자에까지 전파하지 않는 방법이 있다.
  * 이 경우 발생한 예외는 적절한 로깅 기능을 활용하여 기록해두면 좋다.
  * 그렇게 해놓으면 클라이언트 코드와 사용자에게 문제를 전파하지 않으면서도 프로그래머가 로그를 분석해 추가 조치를 취할 수 있게 해준다.

### 정리
* 아래 계층의 예외를 예방하거나, 스스로 처리할 수 없고 그 예외를 상위 계층에 그대로 노출하기 곤란한 경우엔 예외 번역을 사용해야 한다.
* 이때 예외 연쇄를 사용하면 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서, 근본 원인도 함께 알려줄 수 있기 때문에 오류를 분석하기에 좋다.

## item74. 메서드가 던지는 모든 예외를 문서화하라
### 예외의 문서화
* 메서드가 던지는 예외는 그 메서드를 올바로 사용하는데 아주 중요한 정보이다.
* 그렇기 때문에 각 메서드가 던지는 예외를 문서화하는 데 충분한 시간을 쏟아야 한다.

### 검사 예외의 문서화
* 검사 예외는 항상 따로 선언해야 하며, 각 예외가 발생하는 상황을 자바독의 `throws` 태그를 사용하여 정확히 문서화해야 한다.
* 공통 상위 클래스 하나로 뭉뚱그려 선언하는 일은 해선 안된다.
  * 메서드가 `Exception`이나 `Throwable`을 던진다고 선언해서는 안된다.
  * 메서드 사용자에게 각 예외에 대처할 수 있는 힌트도 주지 못하며, 같은 맥락에서 발생할 여지가 있는 다른 예외들까지 삼켜버릴 수 있다.
  * `main`메서드의 경우, `main`은 오직 JVM만이 호출하므로 `Exception`을 던지도록 선언해도 괜찮다.

### 비검사 예외의 문서화
* 비검사 예외도 검사 예외처럼 꼼꼼히 문서화해두면 좋다.
* 비검사 예외는 일반적으로 프로그래밍 오류를 뜻하는데, 일으킬 수 있는 오류들이 무엇인지 알려주면 프로그래머는 자연스럽게 해당 오류가 나지 않도록 코딩하게 된다.
* 잘 작성된 비검사 예외 문서는 그 메서드를 성공적으로 수행하기 위한 전제조건이 되는 것이다.
  * 즉 `public` 메서드라면 필요한 전제 조건을 문서화해야 하는데, 그 수단으로 가장 좋은 것이 비검사 예외들을 문서화하는 것이다.
* 또한 비검사 예외를 문서로 남기는 것은 인터페이스 메서드에서도 특히 중요하다.
  * 이 조건이 인터페이스의 일반 규약에 속하게 되어 해당 인터페이스를 구현한 모든 구현체가 일관되게 동작하도록 해준다.

### @throws
* 메서드가 던질 수 있는 예외를 각각 `@throws` 태그로 문서화 하되, 비검사 예외는 메서드 선언의 `throws` 목록에 넣진 않는게 좋다.
* 검사냐 비검사냐에 따라 API 사용자가 해야할 일이 달라지기 때문에, 이 두개는 확실히 구분해주는 것이 좋다.
* javadoc은 메서드 선언의 throws 절에 등장하고 메더스 주석의 `@throws` 태그에도 명시한 예외와 `@throws` 태그에만 명시한 예외를 구분해준다.
* 이렇게 하면 프로그래머는 어느 것이 비검사 예외인지를 바로 알 수 있다.

### 비검사 예외의 문서화가 불가능한 경우
* 비검사 예외도 모두 문서화해야 하지만, 현실적으로 불가능할 때가 있다.
* 클래스를 수정하면서 새로운 비검사 예외를 던지게 되어도 소스 호환성과 바이너리 호환성이 그대로 유지되는게 가장 큰 이유이다.
* 예시로, 다른사람이 작성한 클래스를 사용하는 본인이 작성한 메서드가 있고 발생 가능한 모든 예외를 문서화해놓은 상황이라고 가정한다.
* 이 때, 이 외부 클래스가 새로운 비검사 예외를 던지게 되면, 본인이 작성한 메서드 문서에서 언급되지 않은 새로운 비검사 예외를 전파하게 된다.
 
### 클래스에 문서화하는 방법
* 한 클래스에 정의된 많은 메서드가 같은 이유로 예외를 던지는 경우가 있다.
* 그 예외를 각각의 메서드가 아닌 클래스 설명에 추가하는 방법도 있다.
* NPE가 가장 흔한 사례이다.
* 이럴 경우에는 클래스의 문서화 주석에 이 클래스의 모든 메서드는 인수로 null이 넘어오면 NPE를 던진다고 적어놓으면 좋다.

### 정리
* 메서드가 던질 가능성이 있는 모든 예외를 문서화해야 한다.
* 검사 예외든 비검사 예외든 추상 메서드든 구체 메서드든 모두 마찬가지이다.
* 문서화에는 javadoc의 `@throws`태그를 사용하면 된다.
* 검사 예외만 메서드 선언의 `throws` 문에 모두 선언하고, 비검사 예외는 메서드 선언에는 작성하지 않아야 한다.
* 발생 가능한 예외를 문서로 남기지 않으면 다른 사람이 그 클래스나 인터페이스를 사용하기 어렵고, 심지어 사용을 못하게 될 수도 있다.


## item75. 예외의 상세 메시지에 실패 관련 정보를 담으라
### Stack Trace
* 예외를 잡지 못해 프로그램이 실패하면 자바는 그 예외의 스택 추적(Stack Trace) 정보를 자동으로 출력한다.
* 스택 추적은 예외 객체의 `toString` 메서드를 호출해 얻는 문자열로, 보통은 예외의 클래스 이름 뒤에 상세 메시지가 붙는 형태이다.
* 이 정보가 실패 원인을 분석해야하는 사이트 신뢰성 엔지니어 (SRE)가 얻을 수 있는 유일한 정보인 경우가 많다.
* 추가로 그 실패를 재현하기 어려우면 더 자세한 정보를 얻기 어렵거나 불가능해진다.
* 따라서 예외의 `toString` 메서드에 실패 원인에 관한 정보를 가능한 한 많이 담아 반환하는 일은 아주 중요하다.
* 즉, 사후 분석을 위해 실패 순간의 상황을 정확하게 예외의 상세 메시지에 담아야 한다.

### 실패 메시지 작성 요령
* 실패 순간을 포착하려면 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메시지에 담아야 한다.
* 예시로, `IndexOutOfBoundsException`의 상세 메시지는 범위의 최솟값과 최댓값, 그리고 범위를 벗어난 인덱스의 값을 담아야 한다.
* 이러한 정보는 실패에 관한 많은 정보들을 알려주며, 보면 무엇을 고쳐야 할지 분석하는데 큰 도움이 된다.
  * 단, 보안과 관련된 정보는 주의해서 다뤄야 하며, 상세 메시지에 비밀번호나 암호 키 같은 정보까지 담아서는 안된다.
* 관련 데이터를 모두 담아야 하지만 장황할 필요는 없는데, 문제를 분석하는 사람은 스택 추적 뿐만 아니라 관련 문서와 필요한경우 소스코드를 함께 본다.
* 따라서 문서와 소스코드에서 얻을 수 있는 정보는 길게 늘어놔봐야 보기 안좋기만 해진다.

### 예외의 상세 메시지와 최종 사용자에게 보여줄 오류 메시지를 구별해야 한다.
* 예외의 상세 메시지와 최종 사용자에게 보여줄 오류 메시지를 혼동해서는 안된다.
* 최종 사용자에게는 친절한 안내 메시지를 보여줘야 하며, 예외 메시지는 가독성보다는 담긴 내용이 훨씬 중요하다.

### 예외 생성자에서 메시지까지 미리 생성하는 방법
* 실패를 적절히 포착하려면 필요한 정보를 예외 생성자에서 모두 받아 상세 메시지까지 미리 생성해놓는 방법이 있다.
* 예시로, 현재 `IndexOutOfBoundsException` 생성자는 `String`을 받지만, Index와 최솟값 최댓값까지 받는 생성자가 있으면 좋을 것이다.
  * 실제로 Java9에서는 정수 index값을 받는 생성자가 생겨났다.

### 접근자 메서드를 적절히 제공해야 한다.
* 예외는 실패와 관련한 정보를 얻을 수 있는 접근자 메서드를 적절히 제공하는 것이 좋다.
* 포착한 실패 정보는 예외 상황을 복구하는데 유용할 수 있으므로, 접근자 메서드는 비검사 예외보다는 검사 예외에서 더 장점이 드러난다.
* 비검사 예외의 상세 정보에 프로그램적으로 접근하길 원하는 프로그래머는 드물 것이다.
* 하지만 `toString`이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공해야 한다는 일반원칙을 따른다는 관점에서는 비검사 예외라도 접근자 메서드를 제공하는것이 좋을 수 있다.

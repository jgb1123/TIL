# 예외
## item69. 예외는 진짜 예외 상황에만 사용하라
### 예외를 잘못 사용한 예시
```java
try {
    int i = 0;
    while(true)
        range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e) {
}
```
* 위 예시는 전혀 직관적이지 않기 때문에 읽어도 무슨 코드인지 알기 어렵다.
* 위 코드는 무한 루프를 돌다가 배열의 끝에 도달해 `ArrayIndexOutOfBoundsException`이 발생하면 끝을 내는 코드인 것이다.
* 이 코드를 표준적인 관용구대로 작성했으면 훨씬 이해하기 쉬웠을 것이다.
```java
for (Mountain m : range)
    m.climb();
```
### 예외는 예외 상황에서만 사용해야 한다
* 예외는 절대로 일상적인 제어 흐름용으로 쓰여서는 안된다.
* 표준적이고 쉽게 이해되는 관용구를 사용하고, 성능 개선을 목적으로 과하게 복잡하게 만드는 기법은 자제해야 한다.
  * 실제로 성능이 좋아지더라도 자바 플랫폼이 꾸준히 개선되고 있으므로, 최적화로 얻은 상대적인 우위가 오래가지 않을 수도 있다.
  * 반면에, 과하게 복잡하게 만드는 기법에 숨겨진 미묘한 버그로 인해 어려워진 유지보수 문제는 계속 이어진다.
* 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.
* 특정 상태에서만 호출할 수 있는 상태 의존적 메서드를 제공하는 클래스는 상태 검사 메서드도 함께 제공해야 한다.
  * `Iterator` 인터페이스의 `next`와 `hasNext`가 각각 상태 의존적 메서드와 상태 검사 메서드에 해당한다.
  * 상태검사 메서드로 인해 간편하게 작성할 수 있는 코드들이 있다.
  ```java
  for (Iterator<Foo> i = collection.iterator(); i.hasNext(); ) {
    Foo foo = i.next();
    ...
  }
  ```

### 정리
* 예외는 예외 상황에서 쓸 의도로 설계되었다.
* 따라서 정상적인 제어 흐름에서 사용해서는 안되며, 이를 프로그래머에게 강요하는 API를 만들어서도 안된다.


## item70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

### 검사예외
* 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용해야 한다.
* 이것은 검사와 비검사 예외를 구분하는 기본 규칙이다.
* 검사 예외를 던지면 호출자가 그 예외를 `catch`로 잡아 처리하거나, 더 바깥으로 전파하도록 강제하게 된다.
* 메서드 선언에 포함된 검사 예외들은 그 메서드를 호출했을 때 발생할 수 있는 결과임을 API 사용자에게 알려줄 수 있다.
* 물론, 사용자는 예외를 잡기만 하고 별다른 조치를 취하지 않을 수도 있지만 좋지 않은 생각이다.

### 비검사 throwable
* 비검사 `throwable`은 런타임 예외와 에러가 있다.
* 비검사 `throwable`은 프로그램에서 잡을 필요가 없거나, 혹은 통상적으로는 잡지 말아야 한다.
  * 프로그램에서 검사 예외나 에러를 던지는 경우는, 복구가 불가능하거나 더 실행해봐야 득보다는 실이 많은 경우이다.
* 비검사 `throwable`을 잡지 않은 쓰레드는 적절한 오류 메시지를 뱉으며 중단된다.

#### 런타임 에러
* 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용해야 한다.
* 런타임 예외의 대부분은 전제조건을 만족하지 못했을 때 발생한다.
* 하지만 문제가 생겼을 때, 복구할 수 있는 상황인지, 프로그래밍 오류인지가 항상 명확히 구분이 되지는 않는다.
* 예시로, 자원 고갈은 말도 안되는 크기의 배열을 할당해 생긴 프로그래밍 오류일 수도 있고, 진짜로 자원이 부족해서 발생한 문제일 수도 있다.
* 자원이 일시적으로만 부족하거나, 수요가 순간적으로만 몰린 것이라면 충분히 복구할 수 있는 상황일 것이다.
* 따라서 해당 자원 고갈 상황이 복구될 수 있는 것인지는 API설계자에 판단에 달려있다.
* 복구가 가능하다고 믿으면 검사 예외를, 그렇지 않다면 런타임 예외를 사용해야 하며, 확신하기 어렵다면 비검사 예외를 선택하는 편이 나을수도 있다.

#### 에러
* 에러는 보통 JVM이 자원 부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황을 나타낼 때 사용한다.
* 자바 언어 명세가 요구하는 것은 아니지만 업계에 널리 퍼진 규약으로는, `Error` 클래스를 상속해 하위 클래스를 만드는 일은 자제해야 한다.
  * 직접 구현하게 되는 비검사 `throwable`은 모두 `RuntimeException`의 하위 클래스여야 한다.
  * `Error`는 상속하지 말아야 하며, `throw`문으로 직접 던지는 일도 없어야 한다. (AssertionError는 예외)

#### Exception, RuntimeException, Error를 상속하지 않는 throwable
* Exception, RuntimeException, Error를 상속하지 않는 throwable을 만들순 있다.
* 하지만 이러한 throwable은 좋은 점이 하나도 없으므로, 절대 사용하지 말아야 한다.
* 이러한 throwable 정상적인 검사 예외보다 나은점이 하나도 없고, API사용자를 헷갈리게만 만든다.

### 검사 예외는 메서드도 함께 제공해야 한다.
* 예외 또한 어떠한 메서드라도 정의할 수 있는 완벽한 객체이다.
* 예외의 메서드는 주로 그 예외를 일으킨 상황에 관한 정보를 코드 형태로 전달하는데 쓰인다.
  * 이런 메서드가 없으면 프로그래머들은 오류 메시지를 파싱해 정보를 빼내야 하는데, 매우 좋지 않은 습관이다.
  * throwable 클래스들은 대부분 오류 메시지 포맷을 상세히 기술하지 않는데, JVM이나 릴리스에 따라 포맷이 달라질 수 있다는 뜻이다.
  * 따라서 메시지 문자열을 파싱해 얻은 코드는 깨지기 쉽고 다른 환경에서는 동작하지 않을 수 있다.
* 검사 예외는 일반적으로 복구할 수 있는 조건일 때 발생한다.
* 따라서 호출자가 예외 상황에서 벗어나는데 필요한 정보를 알려주는 메서드를 함께 제공해주어야 한다.
* 예시로, 쇼핑몰에서 구입하려는데 카드 잔고가 부족하여 검사 예외가 발생한 경우, 잔고가 얼마나 부족한지를 알려주는 접근자 메서드를 제공해야 한다.

### 정리
* 복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 예외를 던져야 한다.
* 확실하지 않다면 비검사 예외를 던져야 한다.
* 검사 예외도 아니고 런타임 예외도 아닌 `throwable`은 정의하지 말아야 한다.
* 검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공해줘야 한다.

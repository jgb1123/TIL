# 일반적인 프로그래밍 원칙
## item57. 지역변수의 범위를 최소화하라
### 지역변수의 선언 위치
* 지역변수의 범위를 줄이는 가장 좋은 방법은 가장 처음에 쓰일 때 선언하는 방법이다.
* 사용하려면 아직 멀었는데 미리 선언부터 해버리면 가독성이 떨어진다.
* 실제로 사용하는 시점에서는 타입과 초깃값이 기억나지 않을 수도 있다.
* 지역변수를 생각없이 선언하다 보면 변수가 쓰이는 범위보다 너무 앞서 선언하거나, 다 쓴 뒤에도 여전히 살아 있는 경우가 많다.
* 실수로 의도한 범위 앞이나 뒤에서 그 변수를 사용하면 좋지 않은 결과로 이어질 수 있다.

### 지역변수의 초기화 시점
* 모든 지역변수는 선언과 동시에 초기화해야 한다.
* 만약 초기화에 필요한 정보가 충분하지 않다면 충분해질 때까지 선언을 미뤄야 한다.
* try-catch문은 이 규칙에서 예외이며, 변수를 초기화하는 표현식에서 검사 예외를 던질 가능성이 있으면 try 블록 안에서 초기화해야 한다.
* 변수 값을 try 블록 바깥에서도 사용해야 한다면 try 블록 앞에서 선언해야 한다.

### while문보다 for문을 사용하는 것이 좋다.
* while문보다 for문을 사용하면 지역변수 범위를 좁게 가져갈 수 있다.
* 반복 변수의 값을 반복문이 종료된 뒤에도 써야 하는 상황이 아니라면 while 문보다는 for 문을 쓰는 것이 좋다.
* 아래 두 예시에서, while문은 버그가 발생할 수 있고, for문은 컴파일 시점에서 오류를 발견할 수 있다.
```java
Iterator<Element> i = c.iterator();
while (i.hasNext()) {
    doSomething(i.next());
}
...
Iterator<Element> i2 = c2.iterator();
while (i.hasNext()) {   // 실수로 i사용으로 버그 발생 가능
    doSomethingElse(i2.next());
}
```

```java
for (Iterator<Element> i = c.tierator(); i.hasNext()) {
    Element e = i.next();
    ...
}

for (Iterator<Element> i2 = c2.tierator(); i.hasNext()) { // 컴파일 에러
Element e2 = i2.next();
    ...
}
```

* 또한 for문은 while문보다 짧기 때문에 가독성도 좋다.


### 메서드를 작게 유지하고 한 가지 기능에 집중해야 한다.
* 한 메서드에서 여러가지 기능을 처리한다면 그 중에서 한 기능과 관련된 지역변수라도 다른 기능을 수행하는 코드에서 접근할 수 있다.
* 그렇기 때문에 메서드를 기능별로 분리하면 지역변수의 범위를 최소화할 수 있다.

## item58. 전통적인 for 문보다는 for-each 문을 사용하라

### 전통적인 for문의 문제점
```java
for (int i = 0; i < a.length; i++) {
    // a[i]와 같이 사용된 로직
}
```
* 반복자와 인덱스 변수는 코드를 지저분하게만 하는 경우가 있다.
* 또한 혹시라도 잘못된 변수를 사용했을 때 컴파일러가 잡아주지도 않는다.
* 게다가 컬렉션이냐 배열이냐에 따라 코드의 형태가 상당히 달라지기 때문에 주의해야 한다.

### for-each문의 장점
```java
for (Element e : elements){
    // e를 사용한 로직
}
```
* 반복자와 인덱스 변수를 사용하지 않기 때문에 코드가 깔끔해지며 오류가 날 일도 없다.
* 컬렉션을 중첩해 순회해야 하는 경우 for-each문의 장점이 커진다.
* 가독성이 좋아지며 요소를 잘못 사용해 버그를 발생시킬 가능성이 줄어든다.

### for-each문을 사용하지 못하는 상황
* 파괴적인 필터링
    * 컬렉션을 순회하며 선택된 요소를 제거해야 한다면 반복자의 `remove` 메서드를 호출해야 한다.
    * 자바 8부터는 Collection의 removeIf 메서드를 사용해 컬렉션을 명시적으로 순회하는 일을 피할 수 있다.
* 변형
    * 리스트나 배열을 순회하면서 그 원소의 값 일부나, 혹은 전체를 교체해야 한다면 리스트의 반복자나 배열의 인덱스를 사용해야 한다.
* 병렬 반복
    * 여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 한다.

### Iterable
* for-each문은 컬렉션과 배열은 물론 `Iterable` 인터페이스를 구현한 객체라면 무엇이든 순회할 수 있다.
* `Iterable`을 처음부터 직접 구현하는것은 까다롭지만, 원소들의 묶음을 표현해야 하는 상황이라면 `Iterable`을 구현하는 쪽을 고민해봐야 한다.
* `Iterable`을 구현하면 그 타입을 사용하는 프로그래머가 for-each문을 사용할 때마다 아주 편하게 사용할 수 있다.

### 정리
* 전통적인 for 문과 비교했을 때 for-each 문은 명료하고 유연하면서 버그를 예방해준다.
* 성능 저하도 없기 때문에 사용 가능한 모든 곳에서 for문이 아닌 for-each문을 사용해야 한다.

## item59. 라이브러리를 익히고 사용하라
### 라이브러리를 사용해야 하는 이유
```java
static Random rnd = new Random();

static int random(int n) {
    return Math.abs(rnd.nextInt()) % n;
}
```
* 무작위 정수를 생성하고 싶을 때, 많은 프로그래머들은 위와같은 메서드를 만들어 사용하곤 한다.
* 랜덤 메서드를 제대로 짜려면, 의사난수 생성기, 정수론, 2의 보수 계산 등에 대한 지식이 있어야 한다.
* 하지만 위 코드에서는 이미 `Random.nextInt(int)`가 이러한 작업들을 미리 다 해두었다.
* 해당 메서드의 자세한 동작 방식은 자세히 몰라도 되며, 알고리즘에 능숙한 개발자가 설계와 구현과 검증에 시간을 들여 개발해놓은 것이다.

> `Random`
>
> * 자바 7부터는 `Random`을 더 이상 사용하지 않는게 좋다
> * `ThreadLocalRandom`으로 대체하면 대부분 잘 작동하며, `Random`보다 더 고품질의 무작위 수를 생성할 뿐 아니라 속도도 더 빠르다.
> * 포크-조인 풀이나 병렬 스트림에서는 `SplittableRandom`을 사용하면 된다.

#### 라이브러리 사용의 장점
* 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과, 먼저 사용한 다른 프로그래머들의 경험을 손쉽게 활용할 수 있다.
* 핵심적인 일과 크게 관련없는 문제를 해결하느라 시간을 허비하지 않아도 된다.
    * 프로그래머들은 애플리케이션 기능 개발에 집중하고 싶어한다.
* 또한 따로 노력하지 않아도 성능이 지속해서 개선된다.
    * 사용자가 많으며 업계 표준 벤치마크를 사용해 성능을 확인하기 때문에 표준 라이브러리 제작자들은 더 나은 방법을 꾸준히 모색하기 때문이다.
* 기능이 점점 많아진다.
    * 라이브러리에 부족한 부분이 있다면 개발자 커뮤니티에서 이야기가 나오고 논의된 후 다음 릴리스에 해당 기능이 추가되곤 한다.
* 작성한 코드가 많은 사람에게 익숙한 코드가 된다.
    * 다른 개발자들이 더 읽기 좋아지며, 유지보스하기 좋고 재활용하기 쉬운 코드가 된다.

### 라이브러리를 잘 사용하고 있지 않은 이유?
* 많은 프로그래머들이 라이브러리를 사용하지 않고 직접 구현해 사용하고 있다.
* 그 이유는 라이브러리에 그러한 기능이 있는지 모르기 때문일 것이다.
* 실제로도 메이저 릴리스마다 주목할만한 수많은 기능들이 라이브러리에 추가된다.
* 자바는 메이저 릴리스마다 새로운 기능을 설명하는 웹페이지를 공시하는데, 한번 쯤 읽어보면 좋다.
* 라이브러리가 너무 방대하기 때문에 모든 API문서를 공부하기는 벅차겠지만, 적어도 `java.lang`, `java.util`, `java.io`와 그 하위 패키지들에는 익숙해져야 한다.
* 다른 라이브러리들은 필요할 때마다 익히면 되고, 라이브러리는 아주 빠르게 성장하고 있기 때문에 모든 기능을 요약하는것은 힘들다.

### 정리
* 아주 특별한 나만의 기능이 아니라면, 누군가 이미 라이브러리 형태로 구현해놓았을 가능성이 크다.
* 그런 라이브러리가 있다면 쓰면 되고, 있는지 잘 모르겠으면 찾아보면 된다.
* 일반적으로 라이브러리의 코드는 직접 작성한 것보다 품질이 좋고 계속해서 개선될 가능성도 크다.
* 라이브러리 코드는 개발자 각자가 작성하는 것보다 주목을 훨씬 많이 받으므로 코드 품질도 그만큼 높아진다.

## item60. 정확한 답이 필요하다면 float과 double은 피하라
### float과 double타입은 정확한 결과를 계산할 수 없다.
* `float`과 `double` 타입은 과학과 공학 계산용으로 설계되었다.
* 이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 근사치로 계산하도록 세심하게 설계되어있다.
* 따라서 정확한 결과가 필요할 때는 사용하면 안된다.
* `float`과 `double` 타입은 특히 금융 관련 계산과는 맞지 않는다.
* 0.1 혹은 10의 음의 거듭 제곱수를 표현할 수 없기 때문이다.
```java
System.out.println(1.03 - 0.42);      // 0.6100000000000001을 출력한다.
System.out.println(1.00 - 9 * 0.10);  // 0.09999999999999998을 출력한다.
```
* 따라서 금융 계산에는 BigDecimal, int, long 을 사용해야 한다.

### BigDecimal, int, long을 사용하라
* `double` 타입을 `BigDecimal`로 교체만 해도 정확한 계산을 할 수 있다.
* 하지만 `BigDecimal`에는 단점이 있다.
* 기본 타입보다 쓰기가 훨씬 불편하며, 훨씬 느리다.
* 단발성 계산이라면 느리다는 문제는 무시할 수 있지만, 쓰기 불편하다는 점은 어쩔 수 없다.
* `BigDecimal` 대신 `int`나 `long` 타입을 쓸 수 있다.
* 그럴 경우 다룰 수 있는 값의 크기가 제한되고, 소수점을 직접 관리해야 한다.

### 정리
* 정확한 답이 필요한 계산에는 `float`이나 `double`을 사용하면 안된다.
* 소수점 추적은 시스템에 맞기고, 코딩 시 불편함이나 성능 저하를 신경쓰지 않겠다면 `BigDecimal`을 사용하면 된다.
* 성능이 중요하고, 소수점을 직접 추적할 수 있고, 숫자가 너무 크지 않다면 `int`나 `long`을 사용하면 된다.
* 9자리 십진수로 표현할 수 있다면 `int`를 사용하고, 18자리 십진수로 표현할 수 있다면 `long`을 사용하고, 18자리를 넘어가면 `BigDecimal`을 사용하면 된다.

## item61. 박싱된 기본 타입보다는 기본 타입을 사용하라
### 기본 타입과 박싱된 기본 타입
* 자바의 데이터 타입은 크게 기본타입과 참조타입으로 나눌 수 있다.
* 각각의 기본 타입에는 대응하는 참조 타입이 하나씩 있으며, 이를 박싱된 기본 타입이라고 한다. (`Integer`, `Double`, `Boolean` 등)
* 오토박싱과 오토언박싱 덕분에 두 타입을 크게 구분하지 않고 사용할 수 있지만, 차이가 사라지는것은 아니다.
* 둘 사이에는 분명한 차이가 있기 때문에 어떤 타입을 사용하는지는 상당히 중요하다.

### 기본타입과 박싱된 기본타입의 차이
#### 식별성
* 기본 타입은 값만 가지고 있지만, 박싱된 기본 타입은 값에 더해 식별성이란 속성을 갖는다.
* 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다.

#### null
* 기본 타입의 값은 언제나 유효하지만, 박싱된 기본 타입은 유효하지 않은 값인 null을 가질 수 있다.

#### 메모리
* 기본 타입이 박싱된 기본타입보다 시간과 메모리 사용면에서 더 효율적이다.

### 박싱된 기본타입에서 `==`를 사용할 시 생기는 문제
```java
Comparator<Integer> naturalOrder = (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
```
* `naturalOrder.compare(new Integer(42), new Integer(42))`를 출력해보면, 두 `Integer` 인스턴스의 값이 42로 같으므로 0을 출력해야 하지만, 실제로는 1을 출력한다.
* 위 비교자에서 `(i == j)`가 이뤄 질 때 겍체 참조의 식별성을 검사하게 된다.
* 서로 다른 `Integer` 인스턴스라면 값이 같더라도 이 비교의 결과는 false가 되고, 비교자는 1을 반환한다.
* 이처럼 박싱된 기본 타입에 `==` 연산자를 사용하면 오류가 난다.

* 실무에서 기본 타입을 다루는 비교자가 필요하다면 `Comparator.naturalOrder()`를 사용하면 된다.
* 비교자를 직접 만들면 비교자 생성 메서드나 기본 타입을 받는 정적 `compare`메서드를 사용해야 한다.

### 박싱된 기본 타입의 박싱이 풀리는 문제
```java
public class Unbelievable {
    static Integer i;
    
    public static void main(String[] args) {
        if (i == 42)
            System.out.println("TEST");
    }
}
```
* 위 예시는 `i == 42`를 검사할 때 NPE를 던진다.
* i가 `int`가 아닌 `Integer`이며, 다른 참조 타입 필드와 마찬가지로 i의 초깃값도 null이기 때문이다.
* `i == 42`는 `Integer`와 `int`를 비교하는 것이다.
* 거의 예외 없이 기본타입과 박싱된 기본타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀리며, null참조를 언박싱하면 NPE 가 발생한다.

### 성능이 느려지는 문제
```java
public static void main(String[] args) {
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i;
    }
    System.out.println(sum);
}
```
* 위 예씨는 지역변수 sum을 박싱된 기본타입으로 선언하여 느려졌다.
* 오류나 경고 없이 컴파일 되지만, 박싱과 언박싱이 반복해서 일어나 체감될 정도로 성능이 느려진다.

### 박싱된 기본타입을 써야하는 상황
* 컬렉션의 원소, 키, 값으로 사용한다.
* 컬렉션은 기본타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본 타입을 써야 한다.
* 즉, 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로는 박싱된 기본 타입을 써야 한다.
* 자바 언어가 타입 매개변수로 기본 타입을 지원하지 않기 때문이다.
* 리플렉션을 통해 메서드를 호출할 때에도 박싱된 기본 타입을 사용해야 한다.

### 정리
* 기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 가능하면 기본타입을 사용하는 것이 좋다.
* 기본 타입은 간단하고 빠르다.
* 박싱된 기본 타입을 서야 한다면 주의를 기울여 사용해야 하며, 오토 박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애주지는 않는다.
* 두 박싱된 기본 타입을 `==` 연산자로 비교하면 식별성 비교가 이뤄지는데, 이는 작성하면서 의도하지 않았을 가능성이 크다.
* 같은 연산에서 기본 타입과 박싱된 기본 타입을 혼용하면 언박싱이 이뤄지며, 언박싱 과정에서 NPE를 던질 수 있다.
* 기본 타입을 박싱하는 작업은 필요없는 객체를 생성하는 부작용을 나을 수 있다.

## item62. 다른 타입이 적절하다면 문자열 사용을 피하라
### 문자열?
* 문자열을 텍스트를 표현하도록 설계 되었다.
* 그런데 문자열은 워낙 흔하고, 자바가 잘 지원해주어 원래 의도하지 않은 용도로 쓰이는 경우가 많다.

### 문자열은 다른 값 타입을 대신하기에 적합하지 않다.
* 많은 사람이 파일, 네트워크, 키보드 입력으로부터 데이터를 받을 때 주로 문자열을 사용하지만, 입력받을 데이터가 진짜 문자열일 때만 그렇게 사용하는게 좋다.
* 받는 데이터가 수치형이라면 `int`, `float`, `BigInteger` 등 적당한 수치 타입으로 변환해야 한다.
* Y/N 질문의 답이라면 적절한 열거 타입이나 `boolean`으로 변환해야 한다.
* 기본 타입이든 참조 타입이든 적절한 값 타입이 있다면 그것을 사용하고, 없다면 새로 하나 만들면 된다.

### 문자열은 열거 타입을 대신하기에 적합하지 않다.
* 상수를 열거할 때는 문자열보다는 열거 타입이 월등히 좋다.

### 문자열은 혼합 타입을 대신하기에 적합하지 않다.
* 여러 요소가 혼합된 데이터를 하나의 문자열로 표현하는 것은 대체로 좋지 않은 방법이다.
* 혹여라도 두 요소를 구분해주는 문자가 두 요소 중 하나에서 쓰여버리면 혼란스러운 결과를 초래한다.
* 각 요소를 개별로 접근하려면 문자열을 파싱해야 해서 느리고, 귀찮으며, 오류 가능성도 커진다.
* 적절한 `equals`, `toStrig`, `compareTo` 메서드를 제공할 수 없으며, String이 제공하는 기능에만 의존해야 한다.
* 차라리 전용 클래스를 새로 만드는 편이 낫고, 이런 클래스는 보통 private 정적 멤버 클래스로 선언한다.

### 문자열은 권한을 표현하기에 적합하지 않다.
* 권한을 문자열로 표현하는 경우가 종종 있다.
* 예시로, 쓰레드 지역변수 기능을 설계한다고 했을 때, 클라이언트가 제공한 문자열 키로 쓰레드별 지역변수를 식별하는 방법이 있다.
```java
public class ThreadLocal {
    private ThreadLocal() { }
    
    // 현 쓰레드의 값을 키로 구분해 저장
    public static void set(String key, Object value);
    
    // 현 쓰레드의 값을 반환
    public static Object get(String key);
} 
```
* 위 방식의 문제는 쓰레드 구분용 문자열 키가 전역 이름공간에서 공유된다는 점이다.
* 각 클라이언트가 고유한 키를 제공해야 하는데, 만약 두 클라이언트가 같은 키를 쓰기로 결정한다면 의도치 않게 같은 변수를 공유하게 된다.
* 또한 보안도 취약한데, 악의적인 클라이언트라면 의도적으로 같은 키를 사용하여 다른 클라이언트의 값을 가져올수도 있는 것이다.

* 위와같은 문제를 문자열 대신 위조할 수 없는 키를 사용하면 해결된다.
```java
public class ThreadLocal {
    private ThreadLocal() { }
    
    public static class Key {
        Key() { }
    }
    
    // 위조 불가능한 고유 키 생성
    public static Key getKey() {
        return new Key;
    }
    
    public static void set(Key key, Object value);
    public static Object get(Key key);
} 
```
* 위 예시는 이전의 문자열 기반 API의 문제를 모두 해결해주지만, 개선할 부분은 있다.
* set과 get은 이제 정적 메서드일 이유가 없기 때문에 Key 클래스의 인스턴스 메서드로 바꾸면 된다.
* 그러면 Key는 쓰레드 지역변수를 구분하기 위한 키가 아니라, 그 자체가 쓰레드 지역변수가 된다.
* 또한 ThreadLocal을 매개변수화 타입으로 선언하여 타입 안전하게 만들수 있다.

```java
public final class ThreadLocal<T> {
    public ThreadLocal();
    public void set(T value);
    public T get();
}
```

### 정리
* 더 적합한 데이터 타입이 있거나, 새로 작성할 수 있다면 문자열을 쓰고 싶은 유혹을 뿌리쳐야 한다.
* 문자열은 잘못 사용하면 번거롭고, 덜 유연하며, 느리고, 오류 가능성도 크다.
* 문자열을 잘못 사용하는 흔한 예로는, 기본 타입, 열거 타입, 혼합 타입 등이 있다.

## item63. 문자열 연결은 느리니 주의하라
### 문자열 연결은 느리다
* 문자열 연결 연산자 `+`는 여러 문자열을 하나로 합쳐주는 편리한 수단이다.
* 그런데 한줄짜리 출력값 혹은 작고 크기가 고정된 객체의 문자열 표현을 만들 때라면 괜찮지만, 본격적으로 사용하기 시작하면 성능 정하를 감내하기 어렵다.
* 문자열 연결 연산자로 문자열 n개를 있는 시간은 n의 제곱에 비례한다.
* 문자열은 불변이라서 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야 하므로 성능저하는 발생할 수 밖에 없다.

### StringBuilder를 사용하라
* 성능을 포기하고 싶지 않다면 String 대신 `StringBuilder`를 사용하면 된다.
* 자바 6 이후 문자열 연결 성능을 다방면으로 개선했지만, `StringBuilder`와의 성능 차이는 여전히 크다.

### 정리
* 성능에 신경을 써야 한다면 많은 문자열을 연겨할 때는 문자열 연결 연산자 `+`를 사용하면 안된다.
* 대신 `StringBuilder`의 `append` 메서드를 사용하면 된다.
* 문자 배열을 사용하거나, 문자열을 하나씩 처리하는 방법도 있다.

## item64. 객체는 인터페이스를 사용해 참조하라
### 객체는 인터페이스를 사용해 참조해야 한다.
* item51에서는 매개변수 타입으로 클래스가 아니라 인터페이스를 사용하라고 했다.
* 이 개념을, 객체는 클래스가 아닌 인터페이스로 참조하라 까지 확장할 수 있다.
* 적합한 인터페이스만 있다면 매개변수뿐만 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언해야 한다.
* 객체의 실제 클래스를 사용해야 할 상황은 오직 생성자로 생성할 때 뿐이다.

### 인터페이스를 사용하 참조하는 예시
* 다음은 `Set` 인터페이스를 구현한 `LinkedHashSet` 변수를 사용하는 좋은 예시와 나쁜 예시이다.
```java
// 좋은 예시
Set<Son> sonSet = new LinkedHashSet<>();

// 나쁜 예시
LinkedHashSet<Son> sonSet = new LinkedHashSet();
```

### 인터페이스를 사용한 참조의 장점
* 인터페이스 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해진다.
* 나중에 구현 클래스를 교체하고자 한다면 그저 새 클래스의 생성자를 호출해주기만 하면 된다.
```java
Set<Son> sonSet = newHashSet<>(); 
```
* 다른 코드는 전혀 손대지 않아도, 새로 구현한 클래스로의 교체가 가능해진다.

### 구현 클래스 변경 시 주의할 점
* 주의할 점은, 원래의 클래스가 인터페이스의 일반 규약 이외의 특별한 기능을 제공하며, 주변 코드가 이 기능에 기대어 동작해야 한다면 새로운 클래스도 반드시 같은 기능을 제공해야 한다.
* 예를들면 `LinkedHashSet`이 따르는 순서 정책을 가정하고 동작하는 상황에서, 이것을 `HashSet`으로 바꾸면 문제가 될 수 있다.
* `HashSet`은 반복자의 순회 순서를 보장하지 않기 때문이다.

### 구현 타입을 바꾸게 되는 이유
* 원래 것보다 성능이 좋거나 멋진 신기능을 제공하기 떄문일 수 있다.
* 예시로, `HashMap`을 참조하던 변수가 있을 때, 이를 `EnumMap`으로 바꾸면 속도도 빨라지고, 순회 순서도 키의 순서와 같아진다.
* 하지만 `EnumMap`은 키가 열거 타입일 때만 사용할 수 있다.
* 하지만 키 타입과 상관없이 사용할 수 있는 `LinkedHashMap`으로 바꾼다면 성능은 비슷하게 유지하면서 순회 순서를 예측할 수 있다.

### 변수를 구현 타입으로 선언할 경우 생기는 문제점
* 선언 타입과 구현 타입을 동시에 바꿀 수 있으니 변수를 구현 타입으로 선언해도 괜찮을거라 생각할 수도 있다.
* 하지만 자칫하면 프로그램이 컴파일되지 않는다.
* 예시로, 클라이언트에서 기존 타입에서만 제공하는 메서드를 사용했거나, 기존 타입을 사용해야 하는 다른 메서드에 그 인스턴스를 넘기는 경우, 새로운 코드에서는 컴파일되지 않을 것이다.
* 변수를 인터페이스 타입으로 선언하면 이런 일은 발생하지 않는다.

### 적합한 인터페이스가 없는 경우
#### `String`과 `BigInteger 같은 값 클래스들
* 값 클래스를 여러 가지로 구현될 수 있다고 생각하고 설계하는 일은 거의 없다.
* 따라서 final인 경우가 많으며, 상응하는 인터페이스가 별도로 존재하는 경우가 드물다.
* 이런 값 클래스는 매개변수, 변수, 필드, 반환 타입으로 사용해도 무방하다.

#### 클래스 기반으로 작성된 프레임워크가 제공하는 객체들
* 특정 구현 클래스보다는 기반클래스(보통 추상클래스)를 사용해 참조하는 것이 좋다.
* `OutputStream` 등 `java.io` 패키지의 여러 클래스들이 이렇다.

#### 인터페이스에는 없는 특별한 메서드를 제공하는 클래스들
* 예를 들어 `PriorityQueue` 클래스는 `Queue` 인터페이스에는 없는 `comparator` 메서드를 제공해야 한다.
* 클래스 타입을 직접 사용하는 경우는 이런 추가 메서드를 꼭 사용해야 하는 경우로 최소화해야 하며, 절대 남발해선 안된다.

#### 적합한 인터페이스가 없는 경우의 최선책
* 적합한 인터페이스가 없다면 클래스의 계층 구조 중 필요한 기능을 만족하는 가장 덜 구체적인 상위의 클래스를 타입으로 사용하는 것이 좋다.

## item65. 리플렉션보다는 인터페이스를 사용하라
### 리플렉션?
* `java.util.reflect`의 리플렉션 기능을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다.
* Class 객체가 주어지면 그 클래스의 생성자, 메서드, 필드에 해당하는 Constructor, Method, Field 인스턴스를 가져올 수 있다.
* 이 인스턴스들로는 그 클래스의 멤버 이름, 필드 타입, 메서드 시그니처 등을 가져올 수 있으며, 클래스의 인스턴스를 생성하거나, 메서드를 호출하거나, 필드에 접근할 수 있다.
* 예시로, `Method.invoke`는 어떤 클래스의 어떤 객체가 가진 어떤 메서드라도 호출할 수 있게 해준다.
  * 일반적인 보안 제약사항은 준수해야 한다.
* 또한 리플렉션을 이용하면 컴파일 당시에 존재하지 않던 클래스도 이용할 수 있다.

### 리플렉션의 단점
* 컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다.
  * 예외 검사도 마찬가지이며, 프로그램이 리플렉션 기능을 써서 존재하지 않거나 접근할 수 없는 메서드를 호출하려고 하면 런타임 오류가 발생한다.
* 리플렉션을 이용하면 코드가 지저분해지고 장황해진다.
* 성능이 떨어진다
  * 리플렉션을 통한 메서드 호출은 일반 메서드 호출보다 훨씬 느리다.
* 이러한 단점 때문에, 리플렉션을 서야 하는 복잡한 애플리케이션에서도 리플렉션 사용을 점차 줄여나아가고 있다.
* 따라서, 리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피하고 이점만 취할 수 있다.
* 컴파일 타임에 없는 클래스를 사용해야만 하는 프로그램은, 비록 컴파일타임이라도 적절한 인터페이스나 상위 클래스를 이용할 수 있을 것이다.
* 이런 경우에는 리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해 사용하면 된다.

### 리플렉션의 단점 예시
```java
public static void main(String[] args) {
    // 클래스 이름을 Class 객체로 변환한다.
    Class<? extends Set<String>> cl = null;
    
    try {
        cl = (Class<? exteds Set<String>>) Class.forName(args[0]); // 비검사 형변환
    } catch (ClassNotFoundException e) {
        fatalError("클래스를 찾을 수 없습니다.");
    }
    
    // 생성자를 얻는다.
    Constructor<? extends Set<String>> cons = null;
    try {
        cons = cl.getDeclaredConstructor();
    } catch (NoSuchMethodException e) {
        fatalError("매개변수 없는 생성자를 찾을 수 없습니다.");
    }
    
    // 집합의 인스턴스를 만든다
    Set<String> s = null;
    try {
        s = cons.newInstance();
    } catch (IllegalAccessException e) {
        fatalError("생성자에 접근할 수 없습니다.");
    } catch (InstantiationException e) {
        fatalError("클래스를 인스턴스화할 수 없습니다.");
    } catch (InvocationTargetException e) {
        fatalError("생성자가 예외를 던졌습니다: " + e.getCause());
    } catch (ClassCastException e) {
        fatalError("Set을 구현하지 않은 클래스입니다.");
    }
    
    s.addAll(Arrays.asList(args).subList(1, args.length));
    System.out.println(s);
}

private static void fatalError(String msg) {
    System.err.println(msg);
    System.exit(1);
}
```
* 위 예시는 리플렉션의 단점을 보여주는 예시이다.
* 런타임에 총 여섯가지나 되는 예외를 던질 수 있는데, 이 모든 것들은 인스턴스를 리플렉션 없이 생성한다면 컴파일 타임에 잡아낼 수 있는 예외들이다.
* 또한 클래스 이름만으로 인스턴스를 생성해내기 위해 무려 25줄이나 되는 코드를 작성해야 했다.
  * 리플렉션이 아니라면 생성자 호출 한 줄로 끝났을 것이다.
* 리플렉션 예외를 각각 잡는 대신 모든 리플렉션 예외의 상위 클래스인 `ReflectiveOperationException`을 잡도록 하여 코드의 길이를 줄일 수도 있긴 하다. (Java7 부터 지원)

### 리플렉션의 사용 용도
* 리플렉션은 런타임에 존재하지 않을 수도 있는 다른 클래스, 메서드, 필드와의 의존성을 관리할 때 적합하다.
* 이 방법은 버전이 여러 개 존재하는 외부 패키지를 다룰 때 유용하다.
* 가장 오래된 버전만을 지원하도록 컴파일 한 후, 이후 버전의 클래스와 메서드 등은 리플렉션으로 접근하는 방식이다.
* 이렇게 하면 접근하려는 새로운 클래스나 메서드가 런타임에 존재하지 않을 수 있다는 사실을 반드시 감안해야 한다.
* 따라서 같은 목적을 이룰 수 있는 대체 수단을 이용하거나, 기능을 줄여 동작하는 등의 적절한 조치를 취해야 한다.

### 정리
* 리플렉션은 복잡한 특수 시스템을 개발할 때 필요한 좋은 기능이지만, 단점도 많다.
* 컴파일타임에는 알 수 없는 클래스를 사용하는 프로그램을 작성한다면 리플렉션을 사용해야 할 것이다.
* 하지만 되도록 객체 생성에만 사용하고, 생성한 객체를 이용할 때에는 적절한 인터페이스나 컴파일 타임에 알 수 있는 상위 클래스로 형변환해야 한다.

## item66. 네이티브 메서드는 신중히 사용하라
### 자바 네이티브 인터페이스 (JNI, Java Native Interface)
* 자바 네이티브 인터페이스는 자바 프로그램이 네티이브 메서드를 호출하는 기술이다.
* 네이티브 메서드란 C나 C++ 같은 네이티브 프로그래밍 언어로 작성한 메서드를 말한다.
* 전통적으로 네이티브 메서드의 주요 쓰임새들은 세가지이다.
  * 레지스트리 같은 플랫폼 특화 기능을 사용한다.
  * 네이티브 코드로 작성된 기존 라이브러리를 사용한다. (예시로, 레거시 데이터를 사용하는 레거시 라이브러리)
  * 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.

### 플랫폼 특화 기능
* 플랫폼 특화 기능을 활용하려면 네이티브 메서드를 사용해야 한다.
* 자바가 발전하면서 OS같은 하부 플랫폼의 기능들을 점차 흡수하고 있다.
* 따라서 네이티브 메서드를 사용할 필요가 계속 줄어들고 있다.
* 예시로 Java9는 새로 process API를 추가해 OS 프로세스에 접근하는 길을 열어주었다.
* 또한 대체할 만한 자바 라이브러리가 없는 네이티브 라이브러리를 사용해야 할 때에도 네이티브 메서드를 사용해야 한다.

### 성능 개선 목적
* 자바 초기 시절이라면 이야기가 다르지만, JVM은 그동안 많은 발전을 해왔다.
* 대부분의 작업에서 지금의 자바는 다른 플랫폼에 견줄만한 성능을 보인다.
* 예시로 `java.math`가 처음 추가된 1.1시절 BigInteger는 C로 작성한 고성능 라이브러리에 의지했는데, 자바 3때 순수 자바로 다시 구현되면서 세심히 튜닝된 결과 원래의 네이티브 구현보다도 더 빨라졌다.
* 네이티브 라이브러리 쪽은 GNU 다중 정밀 연산 라이브러리(GMP)를 필두로 개선 작업이 계속 되어왔다.
* 고성능의 다중 정밀 연산이 필요한 자바 프로그래머라면 네이티브 메서드를 통해 GMP를 사용하는걸 고려해봐도 좋다.

### 네이티브 메서드의 단점
* 네이티브 언어가 안전하지 않으므로 네이티브 메서드를 사용하는 애플리케이션도 메모리 훼손 오류로부터 더 이상 안전하지 않다.
* 자바보다 플랫폼을 많이 타기 때문에 이식성도 낮다.
* 디버깅도 더어렵다.
* 주의해서 사용하지 않으면 오히려 속도가 느려질 수도 있다.
* GC가 네이티브 메모리는 자동 회수하지 못하고, 심지어 추적조차 할 수 없다.
* 자바 코드와 네이티브 코드의 경계를 넘나들 때마다 비용이 발생한다.
* 네이티브 메서드와 자바 코드 사이의 glue code라고 하는 접착 코드를 작성해야 하는데, 귀찮으면서 가독성도 떨어진다.

### 정리
* 네이티브 메서드를 사용하려거든 다시 한번 더 생각해봐야 한다.
* 네이티브 메서드가 성능을 개선해주는 일은 많지 않다.
* 저수준 자원이나 네이티브 라이브러리를 사용해야만 해서 어쩔 수 없더라도, 네이티브 코드는 최소한만 사용하고 철저히 테스트해야 한다.
* 네이티브 코드 안에 숨은 단 하나의 버그가 애플리케이션 전체를 훼손할 수 있다.

# 메서드
## item49. 매개변수가 유효한지 검사하라
### 매개변수 검사는 가능한한 빠르게 진행해야 한다.
* 메서드와 생성자 대부분은 입력 매개변수와 값이 특정 조건을 만족하기를 바란다.
* 이런 제약은 반드시 문서화해야 하며, 메서드 몸체가 시작되기 전에 검사해야 한다.
* 오류는 가능한 한 빨리 발생한 곳에서 잡아야 한다.
* 오류를 발생한 즉시 잡지 못하면 해당 오류를 감지하기 어려워지고, 감지하더라도 오류의 발생 지점을 찾기 어려워진다.
* 메서드 몸체가 실행되기 전에 매개변수를 확인한다면 잘못된 값이 넘어왔을 때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있다.
* 매개변수 검사를 제대로 하지 못하면 몇몇 문제가 생길 수 있다.
  * 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.
  * 메서드가 잘 수행되지만 잘못된 결과를 반환한다.
  * 메서드는 문제없이 수행됐지만 어떤 객체를 이상한 상태로 만들어 놓아서 미래의 알 수 없는 시점에 이 메서드와는 관련없는 오류를 낼 수 있다.
* 즉 매개변수 검사에 실패하면 실패 원자성(failure atomicity)을 어기는 결과를 낳을 수 있다.

### public과 protected 메서드는 매개변수 값이 잘못 됐을 때 던지는 예외를 문서화해야 한다.
* `@throws` 자바독 태그를 사용하면 된다.
* 매개변수의 제약을 문서화한다면 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야 한다.
* 이러한 간단한 방법으로 API 사용자가 제약을 지킬 가능성을 높일 수 있다.

### 메서드가 직접 사용하지는 않으나, 나중에 쓰기 위해 저장하는 매개변수는 더 신경써서 검사해야 한다.
* 예시로, 만약 null 검사를 생략했다면 이 매개변수를 나중에 쓰다가 NPE가 발생하면 해당 매개변수를 어디서 가져왔는지 추적하기가 어려워진다.
* 생성자 매개변수의 유효성 검사의 경우, 클래스 불변식을 어기는 객체가 만들어지지 않게 하는 데 꼭 필요하다.

### 메서드 매개변수 유효성 검사의 예외 케이스
* 유효성 검사 비용이 지나치게 높거나 실용적이지 않거나, 계산 과정에서 암묵적으로 검사가 수행되는 경우이다.
* 예를 들면 `Collections.sort(List)`처럼 객체 리스트를 정렬하는 메서드의 경우, 리스트 안의 객체들은 모두 상호 비교될 수 있어야 하며 정렬 과정에서 이 비교가 이뤄진다.
* 만약 상호 비교될 수 없는 타입의 객체가 들어있다면 그 객체를 비교할 때 `ClassCastException`을 던질 것이다.
* 즉 리스트 안의 모든 객체가 상호 비교될 수 있는지 검사해봐야 별로 얻는 이익이 없다.
* 그래도 이러한 암묵적 유효성 검사에 너무 의존하면 실패 원자성을 해칠 수 있으니 주의해야 한다.

### 매개변수 유효성 검사에 실패 후 잘못된 예외를 던지는 경우
* 계산 중 잘못된 매개변수 값을 사용해 발생한 예외와 API 문서에서 던지기로 한 예외가 다를 수 있다.
* 이러한 경우에는 예외번역(exception translate)를 사용하여 API 문서에 기재된 예외로 번역해줘야 한다. 

### 정리
* 메서드나 생성자를 작성할 때 그 매개변수들에 어떤 제약이 있을지 생각해야 한다.
* 그 제약들을 문서화하고 메서드 코드 시작 부분에서 명시적으로 검사하는 습관을 갖고 있어야 한다.

## item50. 적시에 방어적 복사본을 만들라
### 자바는 안전하다 생각하고 방심하면 안된다.
* 자바는 안전한 언어로, 네이티브 메서드를 사용하지 않으니 C, C++ 같이 안전하지 않은 언어에서 흔히 볼 수 있는 버퍼 오버런, 배열 오버런, 와일드 포인터 같은 메모리 충돌 오류에서 안전하다.
* 자바로 작성한 클래스는 시스템의 다른 부분에서 무슨 짓을 하든 그 불변식이 지켜진다.
* 메모리 전체를 하나의 거대한 배열로 다루는 언어에서는 누릴 수 없는 장점이다.
* 하지만 이러한 자바라고 해도 다른 클래스로부터의 침범을 아무런 노력 없이 막을 수 있는 것은 아니다.
* 그렇기 때문에 클라이언트가 우리의 불변식을 깨뜨리려 혈안이 되어있다고 가정하고 방어적으로 프로그래밍을 해야 한다.

### 불변식을 지키지 못하는 예제
* 어떠한 객체든 그 객체의 허락 없이는 외부에서 내부를 수정하는 일은 불가능하지만, 자기도 모르게 내부를 수정하도록 허락하는 경우가 많이 생긴다.

```java
public final class Period {
    private final Date start;
    private final Date end;
    
    public Period(Date start, Date end) {
        if (start.compareTo(end) > 0)
            throw new IllegalArgumentException(start + "가 " + end + "보다 늦다.");
        this.start = start;
        this.end = end;
    }
  
    public Date start() {
        return start;
    }
    
    public Date end() {
        return end;
    }
    ...
}
```
* 위 예시는 불변처럼 보이지만 `Date`가 가변이라는 사실을 이용하면 불변식을 깰 수 있다.

```java
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
end.setYear(78);
```

* 자바 8이후로는 `Date` 대신 불변인 `Instant` 혹은 `LocalDateTime`, `ZonedDateTime`을 사용하면 되긴 한다.
  * `Date`는 오래된 API이기 때문에 새로운 코드를 작성할 때는 더이상 사용하면 안된다.
* 하지만 Date처럼 가변인 값 타입을 사용하던 시절이 워낙 길었기 때문에 여전히 많은 API와 내부 구현에 그 잔재들이 남아있다.
* 따라서 이러한 외부 공격으로 부터 내부를 보호하려면 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사해야 한다.

### 불변식을 지키기 위해 매개변수의 방어적 복사본을 만들어라
* 불변식을 지키기 위해 인스턴스 안에서 원본이 아닌 복사본을 사용하면 된다.

```java
public Period(Date start, Date end) {
    this.start = new Date(start.getTime());
    this.end = new Date(end.getTime());
    
    if (this.start.compareTo(this.end) > 0)
        throw enw IllegalArgumentException(this.start + "가 " +this.end + "보다 늦다.");
}
```

* 위 예시와 같이 생성자를 작성하면 이전의 공격은 더이성 `Period` 객체에 위협이 되지 않는다.
* 매개변수의 유효성 검사를 하기 전에 방어적 복사본을 만들고, 이 복사본을 통해 유효성을 검사한다.
  * 멀티 스레딩 환경이라면 원본 객체와 유효성 검사한 후 복사본을 만드는 그 찰나의 순간에 다른 스레드가 우너본 객체를 수정할 위험이 있기 때문이다.
  * 이를 검사시점/사용시점(time-of-check/time-of-use) 공격 혹은 TOCTOU 공격이라고 한다.
* 또한 `Date`의 `clone` 메서드를 사용하지 않았다.
  * `Date`는 `final`이 아니므로 `clone`이 `Date`가 정의한 게 아닐 수 있다.
  * 즉, `clone`이 악의를 가진 하위 클래스의 인스턴스를 반환할 수도 있다.
  * 이 하위 클래스는 start와 end 필드의 참조를 private 정적 리스트에 담아뒀다가 공격자에게 이 리스트에 접근하는 길을 열어줄 수도 있다.
  * 이러한 공격을 막기 위해선 매개변수가 제 3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 `clone`을 사용하면 안된다.
```java
public Date start() {
    return new Date(start.getTime());
}

public Date end() {
    return new Date(end.getTime());
}
```
* 추가로 위 예시와 같이 접근자 메서드가 내부의 가변 정보를 직접 드러내지 않도록, 가변 필드의 방어적 복사본을 반환하면 된다.
  * 생성자와 달리 접근자 메서드에서는 방어적 복사에 `clone`을 사용해도 된다.
  * `Period`가 가지고 있는 `Date`객체는 `java.util.Date`임이 확실하기 때문이다. (신뢰할 수 없는 하위 클래스가 아님)
  * 그럼에도 불구하고 인스턴스를 복사하는 데에는 일반적으로 생성자나 정적 팩토리를 쓰는게 좋다.

### 매개변수의 방어적 복사는 불변 객체를 만들기 위해서만 사용되는 것은 아니다.
* 메서드든 생성자든 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야 할 때, 항상 그 객체가 잠재적으로 변경될 수 있는지를 생각해봐야 한다.
* 변경될 수 있는 객체라면 그 객체가 클래스에 넘겨진 뒤 임의로 변경되어도 그 클래스가 문제없이 동작하는지를 따져봐야 한다.
* 이를 확신할 수 없다면 복사본을 만들어 저장해야 한다.
* 내부 객체를 클라이언트에 건네주기 전 방어적 복사본을 만드는 이유도 마찬가지이다.
* 클래스가 불변이든 가변이든 가변인 내부 객체를 클라이언트에 반환할 때는 반드시 심사숙고해야 한다.
* 확실히 안심할 수 없다면 방어적 복사본을 만들어서 반환해야 한다.
* 예시로, 길이가 1 이상인 배열은 무조건 가변이기 때문에 내부에서 사용하는 배열을 반환할 때에는 항상 방어적 복사를 수행해야 한다.

### 방어적 복사의 주의점
* 방어적 복사에는 성능 저하가 따르고, 또 항상 쓸 수 있는것도 아니다.
* 호출자가 컴포넌트 내부를 수정하지 않으리라 확신하면 방어적 복사를 생략할 수 있다.
  * 이러한 상황에서도 호출자가 해당 매개변수나 반환값을 수정하지 말아야 함을 명확히 문서화하는 것이 좋다.
* 또한 다른 패키지에서 사용한다고 해서 넘겨받은 가변 매개변수를 항상 방어적으로 복사해 저장해야 하는 것은 아니다.
  * 메서드나 생성자의 매개변수로 넘기는 행위가 그 객체의 통제권을 명백히 이전함을 뜻하기도 한다.
  * 방어적 복사를 생략해도 되는 상황은 해당 클래스와 그 클라이언트가 상호 신뢰할 수 있을때나, 불변식이 깨지더라도 그 영향이 오직 호출한 클라이언트로 국한될 때로 한정해야 한다.

### 정리
* 클래스가 클라이언트로부터 받거나 혹은 클라리언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다.
* 복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사를 수행하는 대신 해당 구성요소를 수정했을 때의 책임이 클라이언트에 있음을 문서에 명시해야 한다.
# 메서드
## item49. 매개변수가 유효한지 검사하라
### 매개변수 검사는 가능한한 빠르게 진행해야 한다.
* 메서드와 생성자 대부분은 입력 매개변수와 값이 특정 조건을 만족하기를 바란다.
* 이런 제약은 반드시 문서화해야 하며, 메서드 몸체가 시작되기 전에 검사해야 한다.
* 오류는 가능한 한 빨리 발생한 곳에서 잡아야 한다.
* 오류를 발생한 즉시 잡지 못하면 해당 오류를 감지하기 어려워지고, 감지하더라도 오류의 발생 지점을 찾기 어려워진다.
* 메서드 몸체가 실행되기 전에 매개변수를 확인한다면 잘못된 값이 넘어왔을 때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있다.
* 매개변수 검사를 제대로 하지 못하면 몇몇 문제가 생길 수 있다.
  * 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.
  * 메서드가 잘 수행되지만 잘못된 결과를 반환한다.
  * 메서드는 문제없이 수행됐지만 어떤 객체를 이상한 상태로 만들어 놓아서 미래의 알 수 없는 시점에 이 메서드와는 관련없는 오류를 낼 수 있다.
* 즉 매개변수 검사에 실패하면 실패 원자성(failure atomicity)을 어기는 결과를 낳을 수 있다.

### public과 protected 메서드는 매개변수 값이 잘못 됐을 때 던지는 예외를 문서화해야 한다.
* `@throws` 자바독 태그를 사용하면 된다.
* 매개변수의 제약을 문서화한다면 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야 한다.
* 이러한 간단한 방법으로 API 사용자가 제약을 지킬 가능성을 높일 수 있다.

### 메서드가 직접 사용하지는 않으나, 나중에 쓰기 위해 저장하는 매개변수는 더 신경써서 검사해야 한다.
* 예시로, 만약 null 검사를 생략했다면 이 매개변수를 나중에 쓰다가 NPE가 발생하면 해당 매개변수를 어디서 가져왔는지 추적하기가 어려워진다.
* 생성자 매개변수의 유효성 검사의 경우, 클래스 불변식을 어기는 객체가 만들어지지 않게 하는 데 꼭 필요하다.

### 메서드 매개변수 유효성 검사의 예외 케이스
* 유효성 검사 비용이 지나치게 높거나 실용적이지 않거나, 계산 과정에서 암묵적으로 검사가 수행되는 경우이다.
* 예를 들면 `Collections.sort(List)`처럼 객체 리스트를 정렬하는 메서드의 경우, 리스트 안의 객체들은 모두 상호 비교될 수 있어야 하며 정렬 과정에서 이 비교가 이뤄진다.
* 만약 상호 비교될 수 없는 타입의 객체가 들어있다면 그 객체를 비교할 때 `ClassCastException`을 던질 것이다.
* 즉 리스트 안의 모든 객체가 상호 비교될 수 있는지 검사해봐야 별로 얻는 이익이 없다.
* 그래도 이러한 암묵적 유효성 검사에 너무 의존하면 실패 원자성을 해칠 수 있으니 주의해야 한다.

### 매개변수 유효성 검사에 실패 후 잘못된 예외를 던지는 경우
* 계산 중 잘못된 매개변수 값을 사용해 발생한 예외와 API 문서에서 던지기로 한 예외가 다를 수 있다.
* 이러한 경우에는 예외번역(exception translate)를 사용하여 API 문서에 기재된 예외로 번역해줘야 한다. 

### 정리
* 메서드나 생성자를 작성할 때 그 매개변수들에 어떤 제약이 있을지 생각해야 한다.
* 그 제약들을 문서화하고 메서드 코드 시작 부분에서 명시적으로 검사하는 습관을 갖고 있어야 한다.

## item50. 적시에 방어적 복사본을 만들라
### 자바는 안전하다 생각하고 방심하면 안된다.
* 자바는 안전한 언어로, 네이티브 메서드를 사용하지 않으니 C, C++ 같이 안전하지 않은 언어에서 흔히 볼 수 있는 버퍼 오버런, 배열 오버런, 와일드 포인터 같은 메모리 충돌 오류에서 안전하다.
* 자바로 작성한 클래스는 시스템의 다른 부분에서 무슨 짓을 하든 그 불변식이 지켜진다.
* 메모리 전체를 하나의 거대한 배열로 다루는 언어에서는 누릴 수 없는 장점이다.
* 하지만 이러한 자바라고 해도 다른 클래스로부터의 침범을 아무런 노력 없이 막을 수 있는 것은 아니다.
* 그렇기 때문에 클라이언트가 우리의 불변식을 깨뜨리려 혈안이 되어있다고 가정하고 방어적으로 프로그래밍을 해야 한다.

### 불변식을 지키지 못하는 예제
* 어떠한 객체든 그 객체의 허락 없이는 외부에서 내부를 수정하는 일은 불가능하지만, 자기도 모르게 내부를 수정하도록 허락하는 경우가 많이 생긴다.

```java
public final class Period {
    private final Date start;
    private final Date end;
    
    public Period(Date start, Date end) {
        if (start.compareTo(end) > 0)
            throw new IllegalArgumentException(start + "가 " + end + "보다 늦다.");
        this.start = start;
        this.end = end;
    }
  
    public Date start() {
        return start;
    }
    
    public Date end() {
        return end;
    }
    ...
}
```
* 위 예시는 불변처럼 보이지만 `Date`가 가변이라는 사실을 이용하면 불변식을 깰 수 있다.

```java
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
end.setYear(78);
```

* 자바 8이후로는 `Date` 대신 불변인 `Instant` 혹은 `LocalDateTime`, `ZonedDateTime`을 사용하면 되긴 한다.
  * `Date`는 오래된 API이기 때문에 새로운 코드를 작성할 때는 더이상 사용하면 안된다.
* 하지만 Date처럼 가변인 값 타입을 사용하던 시절이 워낙 길었기 때문에 여전히 많은 API와 내부 구현에 그 잔재들이 남아있다.
* 따라서 이러한 외부 공격으로 부터 내부를 보호하려면 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사해야 한다.

### 불변식을 지키기 위해 매개변수의 방어적 복사본을 만들어라
* 불변식을 지키기 위해 인스턴스 안에서 원본이 아닌 복사본을 사용하면 된다.

```java
public Period(Date start, Date end) {
    this.start = new Date(start.getTime());
    this.end = new Date(end.getTime());
    
    if (this.start.compareTo(this.end) > 0)
        throw enw IllegalArgumentException(this.start + "가 " +this.end + "보다 늦다.");
}
```

* 위 예시와 같이 생성자를 작성하면 이전의 공격은 더이성 `Period` 객체에 위협이 되지 않는다.
* 매개변수의 유효성 검사를 하기 전에 방어적 복사본을 만들고, 이 복사본을 통해 유효성을 검사한다.
  * 멀티 스레딩 환경이라면 원본 객체와 유효성 검사한 후 복사본을 만드는 그 찰나의 순간에 다른 스레드가 우너본 객체를 수정할 위험이 있기 때문이다.
  * 이를 검사시점/사용시점(time-of-check/time-of-use) 공격 혹은 TOCTOU 공격이라고 한다.
* 또한 `Date`의 `clone` 메서드를 사용하지 않았다.
  * `Date`는 `final`이 아니므로 `clone`이 `Date`가 정의한 게 아닐 수 있다.
  * 즉, `clone`이 악의를 가진 하위 클래스의 인스턴스를 반환할 수도 있다.
  * 이 하위 클래스는 start와 end 필드의 참조를 private 정적 리스트에 담아뒀다가 공격자에게 이 리스트에 접근하는 길을 열어줄 수도 있다.
  * 이러한 공격을 막기 위해선 매개변수가 제 3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 `clone`을 사용하면 안된다.
```java
public Date start() {
    return new Date(start.getTime());
}

public Date end() {
    return new Date(end.getTime());
}
```
* 추가로 위 예시와 같이 접근자 메서드가 내부의 가변 정보를 직접 드러내지 않도록, 가변 필드의 방어적 복사본을 반환하면 된다.
  * 생성자와 달리 접근자 메서드에서는 방어적 복사에 `clone`을 사용해도 된다.
  * `Period`가 가지고 있는 `Date`객체는 `java.util.Date`임이 확실하기 때문이다. (신뢰할 수 없는 하위 클래스가 아님)
  * 그럼에도 불구하고 인스턴스를 복사하는 데에는 일반적으로 생성자나 정적 팩토리를 쓰는게 좋다.

### 매개변수의 방어적 복사는 불변 객체를 만들기 위해서만 사용되는 것은 아니다.
* 메서드든 생성자든 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야 할 때, 항상 그 객체가 잠재적으로 변경될 수 있는지를 생각해봐야 한다.
* 변경될 수 있는 객체라면 그 객체가 클래스에 넘겨진 뒤 임의로 변경되어도 그 클래스가 문제없이 동작하는지를 따져봐야 한다.
* 이를 확신할 수 없다면 복사본을 만들어 저장해야 한다.
* 내부 객체를 클라이언트에 건네주기 전 방어적 복사본을 만드는 이유도 마찬가지이다.
* 클래스가 불변이든 가변이든 가변인 내부 객체를 클라이언트에 반환할 때는 반드시 심사숙고해야 한다.
* 확실히 안심할 수 없다면 방어적 복사본을 만들어서 반환해야 한다.
* 예시로, 길이가 1 이상인 배열은 무조건 가변이기 때문에 내부에서 사용하는 배열을 반환할 때에는 항상 방어적 복사를 수행해야 한다.

### 방어적 복사의 주의점
* 방어적 복사에는 성능 저하가 따르고, 또 항상 쓸 수 있는것도 아니다.
* 호출자가 컴포넌트 내부를 수정하지 않으리라 확신하면 방어적 복사를 생략할 수 있다.
  * 이러한 상황에서도 호출자가 해당 매개변수나 반환값을 수정하지 말아야 함을 명확히 문서화하는 것이 좋다.
* 또한 다른 패키지에서 사용한다고 해서 넘겨받은 가변 매개변수를 항상 방어적으로 복사해 저장해야 하는 것은 아니다.
  * 메서드나 생성자의 매개변수로 넘기는 행위가 그 객체의 통제권을 명백히 이전함을 뜻하기도 한다.
  * 방어적 복사를 생략해도 되는 상황은 해당 클래스와 그 클라이언트가 상호 신뢰할 수 있을때나, 불변식이 깨지더라도 그 영향이 오직 호출한 클라이언트로 국한될 때로 한정해야 한다.

### 정리
* 클래스가 클라이언트로부터 받거나 혹은 클라리언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다.
* 복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사를 수행하는 대신 해당 구성요소를 수정했을 때의 책임이 클라이언트에 있음을 문서에 명시해야 한다.

## item51. 메서드 시그니처를 신중히 설계하라
### 메서드 이름을 신중히 짓자
* 항상 표준 명명 규칙을 따라야 한다.
* 이해할 수 있고 같은 패키지에 속한 다른 이름들과 일관되게 짓는 게 최우선 목표이다.
* 그 다음 목표는 개발자 커뮤니티에서 널리 받아들여지는 이름을 사용하는 것이다.
* 긴 이름은 피해야 하며, 애매하면 자바 라이브러리의 API 가이드를 참조하면 된다.
  * 자바 라이브러리가 워낙 방대하다 보니 일관되지 않은 이름도 많지만 대부분은 납득할 만한 수준이다.

### 편의 메서드를 너무 많이 만들지 마라
* 모든 메서드는 각각 자신의 소임을 다해야 한다.
* 메서드가 너무 많은 클래스는 익히고, 사용하고, 문서화하고, 테스트하고, 유지보수하기가 어렵다.
* 인터페이스도 마찬가지이며, 메서드가 너무 많으면 이를 구현하는 사람과 사용하는 사람 모두를 고통받게 한다.
* 클래스나 인터페이스는 자신의 각 기능을 완벽히 수행하는 메서드로 제공해야 한다.
* 아주 자주 쓰일 경우에만 별도의 약칭 메서드를 둬야 하며, 확신이 서지 않으면 만들지 않아야 한다.

### 매개변수 목록은 짧게 유지하자
* 매개변수는 4개 이하가 좋으며, 일단 4개가 넘어가면 매개변수를 전부 기억하기가 쉽지 않다.
* 만든 API에 이 제한을 넘는 메서드가 많다면 프로그래머들은 API문서를 옆에 끼고 개발해야 한다.
* IDE를 사용한다면 수고를 많이 덜 수 있지만 그래도 매개변수 수는 적은 것이 좋다.
* 같은 타입의 매개변수 여러개가 연달아 나오는 경우는 특히 안좋다.
* 사용자가 그 매개변수 순서를 기억하기도 어렵고, 실수로 순서를 바꿔 입력해도 그대로 컴파일되고 실행되며, 의도와 다르게 동작한다.

#### 여러 메서드로 분리하는 방법
* 여러 메서드로 분리된 메서드 각각은 원래 매개변수 목록의 부분집합을 받는다. 
* 잘못하면 메서드가 너무 많아질 수 있지만 오히려 메서드 수를 줄여주는 효과도 있다.

#### 매개변수 여러개를 묶어주는 도우미 클래스를 만드는 방법
* 일반적으로 이런 도우미 클래스는 정적 멤버 클래스로 둔다.
* 특히 잇따른 매개변수 몇 개를 독립된 하나의 개념으로 볼 수 있을 때 추천되는 방법이다.

#### 객체 생성에 사용한 빌더 패턴을 메서드 호출에 응용하는 방법
* 모든 매개변수를 하나로 추상화한 객체를 정의하고, 클라이언트에서 이 객체의 세터 메서드를 호출해 필요한 값을 설정하게 하는 방법이다.
* 각 세터 메서드는 매개변수 하나 혹은 연관된 몇 개만 설정하게 한다.
* 클라이언트는 먼저 필요한 매개변수를 다 설정한 다음, execute 메서드를 호출해 앞서 설정한 매개변수들의 유효성 검사를 진행한 후 설정이 완료된 객체를 넘겨 원하는 계산을 수행하도록 한다.

### 매개변수의 타입으로는 클래스보다는 인터페이스가 더 낫다
* 매개변수로 적합한 인터페이스가 있다면 그 인터페이스를 직접 사용해야 한다.
* 예시로 메서드에 `HashMap`을 넘길 일은 전혀 없고 대신 `Map`을 사용해야 한다.
* 그러면 `HashMap` 뿐만 아니라 어떤 `Map`구현체도 인수로 건넬 수 있다.
* 인터페이스 대신 클래스를 사용하면 클라이언트에게 특정 구현체만 사용하도록 제한하는 꼴이며, 혹시라도 입력 데이터가 다른 형태로 존재한다면 명시된 특정 구현체의 객체로 옮겨 담느라 비싼 복사 비용이 들게 된다.

### boolean보다는 원소 2개짜리 열거 타입이 낫다
* 열거 타입을 사용하면 코드를 읽고 쓰기가 더 쉬워지며, 나중에 선택지를 추가하기도 쉽다.
  * 메서드 이름상 boolean을 받아야 의미가 더 명확할 때에는 예외이다.

```java
public enum TemperatureScale { FAHRENHEIT, CELSIUS }
```

* 온도계 클래스의 정적 팩토리 메서드가 이 열거 타입을 입력받아 적합한 온도계 인스턴스를 생성해준다고 해보면, `Thermometer.newInstance(true)` 보단 `Thermometer.newInstance(TemperatureScale.CELSIUS)`가 훨씬 명확하다.
* 또한 나중에 캘빈온도도 지원해야 한다면 열거 타입에 `KELVIN`을 추가하면 된다.
* 또한 온도 단위에 대한 의존성을 개별 열거 타입 상수의 메서드 안으로 리팩토링해서 넣을수도 있다. 
  * 예시로, double 값을 받아 섭씨온도로 변환해주는 메서드를 열거 타입 상수 각각에 정의할 수 있다.

## item52. 다중정의는 신중히 사용하라
### 다중정의의 문제점을 드러내는 예시
```java
static class CollectionClassifier {
    public static String classify(Set<?> s) {
        return "집합";
    }

    public static String classify(List<?> lst) {
        return "리스트";
    }

    public static String classify(Collection<?> c) {
        return "그 외";
    }
    
    public static void main(String[] args) {
        Collection<?>[] collections = {
            new HashSet<String>(),
            new ArrayList<BigInteger>(),
            new HAshMap<String, String>().values()    
        };
        
        for (Collection<?> c : collections)
            System.out.println(classify(c));
    }
}
```
* 위 예시는 `"집합"`, `"리스트"`, `"그 외"`를 차례로 출력할 것 같지만, 실제로 수행해보면 `"그 외"`만 세번 연달아 출력한다.
* 다중정의된 세 `classify` 중 어느 메서드를 호출할지가 컴파일 타임에 정해져 버리기 때문이다.
  * 컴파일타임에는 for문 안의 `c`는 항상 `Collection<?>` 타입이다.
* 이렇게 동작하는 이유는 재정의한 메서드는 동적으로 선택되고, 다중정의한 메서드는 정적으로 선택되기 때문이다.

### 다중정의, 재정의 메서드의 호출 방식 차이
* 메서드를 재정의했다면 해당 객체의 런타임 타입이 어떤 메서드를 호출할지의 기준이 된다.
  * 메서드를 재정의한 다음 하위클래스의 인스턴스에서 그 메서드를 호출하면 재정의한 메서드가 실행된다.
  * 즉 컴파일타임에 그 인스턴스의 타입이 무엇이었냐는 상관이 없다.
* 다중정의된 메서드 사이에서는 객체의 런타임 타입은 전혀 중요하지 않다.
  * 선택은 컴파일타임에 오직 매개변수의 컴파일타임 타입에 의해 이뤄진다.

### 다중정의는 조심히 사용해야 한다
* 재정의한 메서드는 프로그래머가 기대한 대로 동작하지만, 다중정의한 메서드는 이러한 기대를 가볍게 무시할 수도 있다.
* 헷갈릴 수 있는 코드는 작성하지 않는 것이 좋고, 특히 공개 API라면 더더욱 신경써야 한다.
* API 사용자가 매개변수를 넘기면서 어떤 다중정의 메서드가 호출될지를 모른다면 프로그램이 오동작하기 쉽다.
* 런타임에 이상하게 동작할 것이며, API 사용자들은 문제를 찾아내느라 긴 시간을 허비할수도 있다.
* 따라서 다중정의가 혼동을 일으키는 상황은 피해야 한다.

### 다중정의를 안전하게 사용하는 방법
* 안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 않아야 한다.
* 특히 가변인수를 사용하는 메서드라면 다중정의를 아예 사용하지 말아야 한다.
* 이 간단한 규칙만 지켜도 어떤 다중정의 메서드가 호출될지 헷갈릴 일은 없다.
* 다중정의하는 대신 메서드 이름을 다르게 지어주는 방법도 있기 때문에 지키기 어려운 규칙도 아니다.

### 다중정의의 함정
#### 오토박싱
```java
Set<Integer> set = new TreeSet<>();
List<Integer> list = new ArrayList<>();

...

for (int i = 0; i < 3; i++) {
    set.remove(i);
    list.remove(i);
}
```
* `set.remove(i)`의 시그니처는 `remove(Object)`이다.
  * 다중정의된 다른 메서드가 없기 때문에 기대한대로 동작한다.
* 하지만 `list.remove(i)`는 다중정의된 `remove(int index)`를 선택한다.
  * 이 문제를 해결하기 위해선 올바른 다중 정의 메서드를 선택하게 하면 된다.
  * `list.remove`의 인수를 `Integer`로 형변환하거나, `Integer.valueOf`를 이용해 i를 `Integer`로 변환 후 `list.remove`에 전달하면 된다.
* 제네릭 도입 전 자바 4까지의 `List`에서는 `Object`와 `int`는 근본적으로 달라서 문제가 없었지만, 제네릭과 오토박싱이 등장하면서 두 메서드의 매개변수 타입이 더는 근본적으로 다르지 않게 되었다.

#### 람다와 메서드 참조
```java
// 1. Thread의 생성자 호출
new Thread(System.out::println).start();

// 2. ExecutorService의 submit 메서드 호출
ExecutorService exec = Executors.newCachedThreadPool();
exec.submit(System.out::println);
```
* 위 두 예시는 비슷하긴 하지만 2번의 경우 컴파일 오류가 발생한다.
* 바로 `submit` 다중정의 메서드 중에는 `Callable<T>`를 받는 메서드도 있기 때문이다.
  * 참조된 메서드 `println`과 호출한 메서드 `submit` 모두 다중정의가 되어있기 때문에, 다중정의 메서드를 찾는 메서드는 기대처럼 동작하지 않는다.
* 다중정의된 메서드들이 함수형 인터페이스를 인수로 받을 때, 비록 서로 다른 함수형 인터페이스라도 인수의 위치가 같으면 혼란이 생긴다.
* 즉, 메서드를 다중정의할 때, 서로 다른 함수명 인터페이스라도 같은 위치의 인수로 받아서는 안된다.

#### String
* `String`은 자바 4시절부터 `contentEquals(StringBuffer)` 메서드를 가지고 있었다.
* 자바 5에서 `StringBuffer`, `StringBuilder`, `String`, `CharBuffer`등의 비숫한 부류의 타입을 위한 공통 인터페이스로 `CharSequence`가 등장하였다.
* 자연스럽게 `String`에도 `CharSequence`를 받은 `contentEquals`가 다중정의 되었다.
* 다행이 이 두 메서드는 같은 객체를 입력하면 완전히 같은 작업을 수행해주긴 한다.
  * 어떤 다중정의 메서드가 불리는지 몰라도 기능이 똑같다.
* 이렇게 하는 가장 일반적인 방법은 상대적으로 더 특수한 다중정의 메서드에 덜 특수한 다중정의 메서드로 포워드하는 것이다.
* 다중정의로 2개 이상의 타입을 지원할 때 아래와 같이 명시적 캐스팅으로 인수 포워딩을 하여 정상 동작을 유도할 수 있다.
```java
public boolean contentEquals(StringBuffer sb) {
    return contentEquals((CharSequence) sb);
}
```
* 이렇게 자바 라이브러리는 다중정의의 문제점을 잡기위해 노력하고 있지만, `String`클래스의 `valueOf(char[])`과 `valueOf(Object)`는 같은 객체를 건네더라도 전혀 다른일을 수행한다.

### 정리
* 프로그래밍 언어가 다중정의를 허용한다고 해서 다중정의를 꼭 활용하라는 뜻은 아니다.
* 일반적으로 매개변수 수가 같을 때는 다중정의를 피하는 것이 좋다.
* 상황에 따라 이 규칙을 지치기 어려울 수도 있는데, 그럴 때에는 헷갈릴 만한 매개변수는 형변환하여 정확한 다중정의 메서드가 선택되도록 해야 한다.
* 이것이 불가능하다면, 같은 객체를 입력받는 다중정의 메서드들이 모두 동일하게 동작하도록 만들어야 한다.
* 그렇지 못하면 프로그래머들은 다중정의된 메서드나 생성자를 효과적으로 사용하지 못할 것이며, 의도대로 동작하지 않는 이유를 찾고 이해하기도 어렵다.

## item53. 가변 인수는 신중히 사용하라
### 가변인수?
* 가변인수 메서드는 명시한 타입의 인수를 0개 이상 받을 수 있다.
* 가변인수 메서드를 호출하면 가장 먼저 인수의 개수와 길이가 같은 배열을 만들고, 인수들을 이 배열에 저장하여 가변인수 메서드에 건네준다.
* 인수 개수는 런타임에 배열의 길이로 알 수 있다.

### 인수가 1개 이상이어야 하는 경우 - 잘못된 예시
```java
static int min(int... args) {
    if (args.length == 0)
        throw new IllegalArgumentException("인수는 1개 이상 필요합니다.");
    int min = args[0];
    for (int i = 1; i < args.length; i++)
        if (args[i] < min)
            min = args[i];
    return min
} 
```
* 가변인수를 사용할 때 인수가 1개 이상이어야 할 때도 있는데, 위와 같이 사용하면 문제점이 있다.
* 인수를 0개만 넣어 호출하면 컴파일타임이 아닌 런타임에 실패한다는 점이다.
* 또한 코드도 지저분해진다.
* 또한 args 유효성 검사를 명시적으로 해야 하고, min의 초기값을 `Integer.MAX_VALUE`로 설정하지 않으면 `for-each`문도 사용할 수 없다.

### 인수가 1개 이상이어야 하는 경우 - 좋은 예시
```java
static int min(int firstArg, int... remainingArgs) {
    int min = firstArg;
    for (int arg : remainingArgs)
        if (arg < min)
            min = arg;
    return min;
}
```
* 매개변수 2개를 받도록 하면 이전 코드의 단점들이 해결된다.
* 첫 번째로는 평범한 매개변수를 받고, 가변인수는 두 번째로 받으면 된다.
* 위 예시는, 가변인수의 인수 개수가 정해지지 않았을 때 매우 유용하다.

### 가변인수 사용 시, 성능에 민감한 경우에서의 해결책
* 가변인수 메서드는 호출될 때마다 배열을 새로 하나 할당하고 초기화한다.
* 이 비용을 감당할 수는 없지만 가변인수의 유연성이 필요할 때 선택할 수 있는 좋은 패턴이 있다.
* 예로, 메서드 호출의 95%가 인수를 3개 이하로 사용한다고 하면, 인수가 0개인 것부터 4개인 것까지 총 5개를 다중정의하면 된다.
```java
public void foo() { }
public void foo(int a1) { }
public void foo(int a1, int a2) { }
public void foo(int a1, int a2, int a3) { }
public void foo(int a1, int a2, int a3, int... rest) { }
```
* 마지막 다중정의 메서드가 인수 4개 이상인 5%의 호출을 담당하게 된다.
* 즉 메서드 호출 중 5%만이 배열을 생성하게 된다.
* 성능이 굉장히 중요한 상황에서는 위와같은 해결책이 많은 도음이 된다.
* 예시로 EnumSet의 정적 팩토리도 이 방법을 사용해 열거 타입 집합 생성 비용을 최소화한다.

### 정리
* 인수 개수가 일정하지 않은 메서드를 정의해야 한다면 가변인수는 반드시 필요하다.
* 메서드를 정의할 때 필수 매개변수는 가변인수 앞에 두고, 가변인수를 사용할 때는 성능 문제까지 고려해야 한다.

## item54. null이 아닌, 빈 컬렉션이나 배열을 반환하라
### null 반환의 문제점
* 가끔씩 컬렉션이나 배열같은 컨테이너가 비어있다고 null을 반환하는 코드들이 있다.
* 굳이 컨테이너가가 비어있다고해서 특별히 취급할 이유는 없다.
* 굳이 컨테이너가 비어있다고 null을 반환하는 메서드를 사용하면 클라이언트는 아래와 같은 방어 코드를 넣어줘야 한다.
```java
List<Cheese> cheeses = shop.getCheeses();
if (cheeses != null && cheeses.contains(Cheese.STILTON))
    // 다음 실행 로직
```
* 클라이언트에서 이 방어적인 코드를 뺴먹으면 오류가 발생할 수도 있다.

### 성능적 관점에서의 주장
* 빈 컨테이너를 할당하는 데도 비용이 들기 때문에 null을 반환하는 쪽이 낫다는 주장도 있다.
* 하지만 이 부분은 두 가지 부분에서 틀린 주장이다.
  * 성능 분석 결과 이 할당이 성능 저하의 주범이라고 확인되지 않는 한, 이 정도의성능 차이는 신경 쓸 수준이 못된다.
  * 빈 컬렉션과 배열은 굳이 새로 할당하지 않고도 반환할 수 있다.
* 가능성은 작지만 사용하는 패턴에 따라 빈 컬렉션 할당이 성능을 눈에 띄게 떨어뜨릴수도 있긴 하지만, 간단한 해법이 있다.
* 불변 객체는 자유롭게 공유해도 안전하며, `Collections.emptyList` 메서드가 그러한 예시이다.
  * 필요에 따라 `Collections.emptySet`, `Collections.emptyMap`을 사용하면 된다.
  * 최적화이기 때문에 성능이 중요한 상황일 때만 사용하면 된다. 
* 배열에서도 마찬가지로, 길이가 0인 빈 배열을 반환해야 하는 경우에도, 길이가 0짜리 배열을 미리 생성해두고 매번 그 배열을 반환하면 된다.
  * 길이가 0인 배열은 모두 불변이기 때문이다.
* 또한 배열에서는 toArray에 넘기는 배열을 미리 할당하는 것은 추천되지 않으며, 오히려 성능이 떨어진다는 연구 결과도 있다.

### 정리
* null이 아닌 빈 배열이나 컬렉션을 반환해야 한다.
* null을 반환하는 API는 사용하기도 어렵고 오류 처리 코드도 늘어나며, 그렇다고 성능면에서 우수한 것도 아니다.

## item55. 옵셔널 반환은 신중히 하라
### Optional 등장 전
* Java8 이전에는 메서드가 특정 조건에서 값을 반환할 수 없을 때 취할 수 있는 선택지가 두가지 있었지만, 두가지 모두 허점이 있다.
* 예외를 던진다
  * 예외는 정말 예외적인 상황에서만 사용해야 하며, 예외를 생성할 때 사용해야 한다.
  * 또한 예외를 생성할 때 스택 추적 전체를 캡처하므로 비용도 만만치 않다.
* null을 반환한다.
  * null을 반환하는 메서드를 호출하면, 별도의 null 처리 코드를 추가해야 한다.
  * null 처리를 하지 않으면 언젠가 NPE가 발생할 수 있다.
  
### Optional의 등장
* Java8 이후에 `Optional<T>`이 등장하게 되었다.
* `Optional<T>`는 null이 아닌 T 타입 참조를 하나 담거나, 아무것도 담지 않을 수 있다.
* 아무것도 담지 않은 `Optional`은 비었다고 말하며, 값을 담은 `Optional`은 비지 않았다고 말한다.
* `Optional`은 원소를 최대 1개 가질 수 있는 불변 컬렉션이다.(`Collection<T>`를 구현하지는 않았지만 원칙적으로는 그렇다)
* 메서드에서 `Optional<T>`를 반환하도록 하면, 유효한 반환값이 없을 때에는 빈 결과를 반환하는 메서드가 만들어진다.
* `Optional`을 반환하는 메서드는 예외를 던지는 메서드보다 유연하고 사용하기도 쉬우며, null을 반환하는 메서드보다 오류 가능성이 적다.

### Optional 반환 사용 예시
```java
public static <E extends Comparable<E>> Optional<E> max(Collection<e> c) {
    if (c.isEmpty())
        return Optional.empty();
    E result = null;
    for (E e : c)
        if (result == null || e.compareTo(result) > 0)
            result = Objects.requireNonNull(e);
    return Optional.of(result);
}
```
* `Optional`을 반환하도록 구현하기는 간단하며, 적절한 정적 팩토리를 사용해 옵셔널을 생성해주기만 하면 된다.
* 빈 옵셔널은 `Optional.empty()`로 만들고, 값이 든 옵셔널은 `Optional.of(value)`로 생성한다.
  * `Optional.of(value)`에 null을 넣으면 NPE가 발생한다.
  * null값도 허용하는 `Optional`dmf aksemffuaus `Optional.ofNullable(value)`를 사용하면 된다.
* 옵셔널을 반환하는 메서드에서는 절대 null을 반환하면 안된다.
  * `Optional`을 도입한 의미가 완전히 없어진다.

### Optional의 사용 방법
* `Optional`은 검사 예외와 취지가 비슷하다.
  * 값이 없을 수도 있음을 API 사용자에게 명확히 알려준다.
  * 비검사 예외를 던지거나, null을 반환한다면 API 사용자가 그 사실을 인지하지 못해 문제가 발생할 수 있다.
  * 하지만 검사 예외를 던지면 클라이언트에서는 반드시 이에 대처하는 코드를 작성해넣어야 한다.
* 이와 비슷하게, 메서드가 `Optional`을 반환한다면 클라이언트는 값을 받지 못했을 때 취할 행동을 선택해야 한다.
* 그 중 하나는 기본값을 설정하는 방법이다.
  ```java
  String lastWordInLexicon = max(words).orElse("단어 없음");
  ```
* 또는 상황에 맞는 예외를 던질수도 있다.
  ```java
  Toy myToy = max(toys).orElseThrow(TemperTantrumException::new);
  ```
* `Optional`에 항상 값이 있다고 확신하면 그냥 바로 값을 꺼내 사용하는 방법도 있다.
  ```java
  Element lastNobleGas = max(Elements.NOBLE_GASES).get();
  ```
* 기본값을 설정하는 비용이 아주 커서 부담이 될 때에는, `Supplier<T>`를 인수로 받는 `orElseGet`을 사용하면 초기 설정 비용을 낮출 수 있다.
* 여전히 적합한 메서드를 찾지 못했다면 `isPresent`를 사용하면 되며, 값이 존재하면 true를 없으면 false를 반환한다.
  ```java
  Optional<ProcessHandle> parentProcess = ph.parent();
  System.out.println("부모 PID: " + (parentProcess.isPresent() ? 
        String.valueOf(parentProcess.get().pid()) : "N/A"));
  ```
* 그 외에 `filter`, `map`, `flatMap`, `ifPresent`와 같은 메서드들도 있다.
  ```java
  System.out.println("부모 PID: " + ph.parent().map(h -> String.valueOf(h.pid())).orElse("N/A"));
  ```

* `Stream`을 사용한다면 옵셔널들을 `Stream<Optional<T>>로 받아서 채워진 `Optional`들의 값을 뽑아 `Stream<T>`에 담아 처리하는 방법도 있다.  
  ```java
  streamOfOptionals
    .filter(Optional::isPresent)
    .map(Optional::get) 
  ```
  
* Java9에서는 `Optional`에 `stream()`메서드가 추가되었으며, `Optional`을 `Stream`으로 반환해준다.
  ```java
  streamOfOptionals
    .flatMap(Optional::stream)
  ```
  
### Optional 반환 시 주의사항
* `Collection`, `Stream`, `Array`, `Optional` 같은 컨테이너 타입은 옵셔널로 감싸면 안된다.
  * 빈 `Optional<List<T>>`를 반환하기 보다는 빈 `List<T>`를 반환하는게 좋다.
  * 빈 컨테이너를 그대로 반환하면 클라이언트에 옵셔널 처리 코드를 넣지 않아도 된다.
* 즉, 결과가 없을 수 있고, 클라이언트가 이 상황을 특별하게 처리해야 할때만 `Optional<T>`를 반환해야 한다.
* `Optional<T>`를 반환하는데에는 대가가 따른다.
  * `Optional`도 새로 할당해야 하고 초기화해야 하는 객체이며, 그 안에서 값을 꺼내려면 메서드를 호출해야 하므로 그만큼 비용이 소비된다.
* 그러므로 성능이 중요한 상황에서는 `Optional`을 사용하는것이 맞지 않을 수 있다.
* 박싱된 기본 타입을 담는 `Optional`은 값을 2번이나 감싸는 것이기 때문에 기본 타입 보다 무거울 수 밖에 없다.
* 그래서 java에서는 int, long, double 전용 `Optional` 클래스들을 따로 만들어두었다. 
* 따라서 박싱된 기본 타입(int, long, double)을 담은 `Optioanl`을 반환해서는 안된다.

### Optional은 반환값 이외의 용도로 사용은 거의 하지 않는다
* `Optional`을 반환과 관련하여 사용하는 것을 제외하고, 대부분의 `Optional`사용은 적절치 않다.
* `Optional`을 `Map`의 값으로 사용하면 절대 안된다.
  * `Map`안에 키가 없다는 사실을 나타내는 방법이 두가지가 된다. (키 자체가 없는 경우, 키는 있지만 그 키가 속이 빈 `Optional`인 경우)
  * 쓸대없이 복잡성만 높이기 때문에 혼란과 오류 가능성을 키을 수 있다.
* 즉, `Optional`을 컬렉션의 키, 값, 원소나 배열의 원소로 사용하는게 적절한 상황은 거의 없다.
* `Optional`을 인스턴스 필드에 저장해 두는게 필요한 경우들도 있긴 하다.
  * 클래스에서 인스턴스의 필드 중 상당수가 필수가 아닌 경우, 또한 그 필드들이 기본타입이라 값이 없음을 나타낼 수 없는 경우에는 `Optional`을 사용하는 것도 좋은 방벙비다.

### 정리
* 값을 반환하지 못할 가능성이 있고, 호출할 때마다 반환값이 없을 가능성을 염두에 둬야 하는 메서드라면 `Optional`을 반환해야 할 상황일 수 있다.
* 하지만 `Optional` 반환에는 성능 저하가 뒤따르기 때문에, 성능에 민감한 메서드라면 null을 반환하거나 예외를 던지는 방법이 나을 수도 있다.
* 또한 `Optional`은 반환값 이외의 용도로 쓰는 경우는 매우 드물다.

## item56. 공개된 API 요소에는 항상 문서화 주석을 작성하라
### javadoc
* API를 쓸모 있게 하려면 잘 작성된 문서도 함께 있어야 한다.
* 전통적으로 API문서는 사람이 직접 작성하기 때문에 코드가 변경되면 매번 함께 수정해줘야 하는데, 자바에서는 javadoc이라는 유틸리티가 이 귀찮은 작업을 도와준다.
* javadoc은 소스코드 파일에서 문서화 주석이라는 특수한 형태로 기술된 설명을 추려 API문서로 변환해준다.
* javadoc은 문서화 주석을 HTML로 변환하므로, 문서화 주석 안의 HTML 요소들이 최종 HTML문서에 반영된다.
  * 드물게는 자바독 설명에 HTML table까지 집어넣는 개발자도 있다.
* 문서화 주석을 작성하는 규칙은 공식 명세에는 없지만, 업계 표준 API라고 할수 있다.
* 자바 버전이 올라가면서 추가된 중요한 javadoc 태그로는, Java5의 `@literal`, `@code`, Java8의 `@implSpec`, java9의 `@index`가 있다.

### 공개된 모든 클래스, 인터페이스, 메서드, 필드 선언에 문서화 주석을 달아야 한다.
* API를 올바로 문서화하기 위해서는 공개된 모든 클래스, 인터페이스, 메서드, 필드 선언에 문서화 주석을 달아야 한다.
* 직렬화할 수 있는 클래스라면 직렬화 형태에 관해서도 적어야 한다.
* 문서화 주석이 없다면 자바독도 그저 공개 API요소들의 선언만 나열해주는게 전부이다.
* 기본 생성자에는 문서화 주석을 달 방법이 없으니 공개 클래스는 절대 기본 생성자를 사용하면 안된다.
* 유지보수까지 고려한다면 대다수의 공개되지 않은 클래스, 인터페이스, 생성자, 메서드, 필드에도 문서화 주석을 달아야 한다.

### 메서드의 주석 작성 요령 
* 메서드용 문서화 주석에는 해당 메서드와 클라이언트 사이의 규약을 명료하게 기술해야 한다.
* 상속용으로 설계된 클래스의 메서드가 아니라면 무엇을 하는지 기술해야 한다.
  * how가 아닌 what을 기술해야 한다.
* 문서화 주석에는 클라이언트가 해당 메서드를 호출하기 위한 전제조건을 모두 나열해야 한다.
* 또한 메서드가 성공적으로 수행된 후에 만족해야 하는 사후조건도 모두 나열해야 한다.
* 일반적으로 전제조건은 `@throws`태그로 비검사 예외를 선언하여 암시적으로 기술한다.
  * 비검사 예외 하나가 전제조건 하나와 연결되는 것이다.
* 또한 `@param` 태그를 이용해 그 조건에 영향받는 매개변수에 기술할수도 있다.
* 뿐만아니라 부작용도 문서화 해야 하며, 여기서 부작용은 사후조건으로 명확히 나타나지는 않지만 시스템의 상태에 어떠한 변화를 가져오는 것을 뜻한다.
  * 예시로, 백그라운드 쓰레드를 시작시키는 메서드라면 그 사실을 문서에 밝혀야 한다.
* 완벽히 기술하려면 모든 매개변수에 `@param` 태그를, 반환타입이 void가 아니라면 `@return`태그를, 발생할 가능성이 있는 모든 예외에 `@throws` 태그를 달아야 한다.
#### @ImplSpec
* 클래스를 상속용으로 설계할 때는 자기사용 패턴(self-use pattern)에 대해서도 문서에 남겨 다른 프로그래머에게 그 메서드를 올바로 재정의하는 법을 알려줘야 한다.
* 자기사용 패턴은 Java8에서 추가된 `@implSpec` 태그로 문서화한다.
* `@ImplSpec` 주석은 해당 메서드와 하위 클래스 사이의 계약을 설명하며, 하위 클래스들이 그 메서드를 상속하거나 super 키워드를 이용해 호출할 때 그 메서드가 어떻게 동작하는지를 명확하게 인지하고 사용하도록 해줘야 한다.
* 자바독 명령줄에서 `-tag "implSpec:a:Implementation Requirements:` 스위치를 켜주지 않으면 `@implSpec`태그를 무시해버린다.

#### @literal
* API설명에 `<`, `>`, `&` 등의 HTML 메타문자를 포함시키려면 특별한 처리가 필요하다
* 가장 좋은 방법은 `{@literal}` 태그로 감싸는 것이다.
* 이 태그는 HTML 마크업이나 자바독 태그를 무시하게 해주며, `{@code}` 태그와 비슷하지만 코드 폰트로 렌더링하지는 않는다.
```
*  {@literal |r| < 1}이면 기하 수열이 생긴다.
```
* 위 예시에서는 사실 `<` 기호만 감싸도 상관 없지만, 그렇게 하면 코드에서의 문서화 주석을 읽기 어려워진다.
* 문서화 주석은 코드에서건 변환된 API문서에서건 읽기 쉬워야 한다.
* 양쪽을 모두 만족하지 못하겠다면 API문서에서의 가독성이 우선되기는 해야 한다.

### 요약 설명
* 각 문서화 주석의 첫 번째 문장은 해당 요소의 요약설명으로 간주된다.
* 요약 설명은 반드시 대상의 기능을 고유하게 기술해야 한다.
* 헷갈리지 않으려면 한 클래스 안에서 요약 설명이 같은 멤버가 둘 이상이면 안된다.
* 다중정의된 메서드가 있다면 특히 더 조심해야 하며, 다중정의된 메서드들의 설명은 같은 문장으로 시작하는게 자연스럽겠지만 문서화 주석에서는 허용되지 않는다.
* 요약 설명에서는 마침표(`.`)에 주의해야 한다.
  * 요약 설명은 첫 마침표까지만 되며, 중간에 `그는 Mr. JGB입니다.`등과 같은 단어를 만나면 `그는 Mr.` 까지가 요약 설명이 된다.
  * 요약 설명이 끝나는 판단 기준은 처음 발견되는 `<마침표><공백><다음문장>` 패턴이다. (다음문장은 영어 소문자가 아닌 문자)
* 요약 설명은 완전한 문장이 되는 경우가 드물기 때문에, 메서드와 생성자의 요약 설명은 해당 메서드와 생성자의 동작을 설명하는 동사구여야 한다.

### @index
* Java9 부터는 자바독이 생성한 HTML 문서에 검색 기능이 추가되어 많은 API 문서들을 누비는 일이 수월해 졌다.
* API 문서 페이지에서 검색창에 키워드를 입력하면 관련 페이즈들이 드롭다운 메뉴로 나타난다.
* 클래스, 메서드, 필드 같은 API 요소의 색인은 자동으로 만들어지며, 원한다면 `{@index}` 태그를 사용해 API에서 중요한 용어를 추가로 색인화할 수 있다.
```
* 이 메서드는 {@index IEEE 754} 표준을 준수한다.
```

### 문서화 주석에서 제네릭, 열거 타입, 애너테이션을 주의해야 한다.
* 제네릭 타입이나 제네릭 메서드를 문서화할 때는 모든 타입 매개변수에 주석을 달아야 한다.
* 열거 타입을 문서화할 때는 상수들에도 주석을 달아야 한다.
  * 열거 타입 자체와 그 열거 타입의 public 메서드도 달아야 한다.
* 애너테이션 타입을 문서화할 때는 멤버들에도 모두 주석을 달아야 한다.
  * 애너테이션 타입 자체에도 달아야 하며, 필드 설명은 명사구로 한다.
  * 애너테이션 타입의 요약 설명은 동사구로 한다.

### 패키지 설명, 모듈 시스템의 주석
* 패키지를 설명하는 문서화 주석은 `package-info.java` 파일에 작성한다.
  * 패키지 선언을 반드시 포함해야 하고, 패키지 선언 관련 애너테이션을 추가로 포함할 수도 있다.
* Java9 부터 지원하는 모듈 시스템도 `module-info.java` 파일에 작성하면 된다.

### 쓰레드 안전성과 직렬화 가능성에 대한 주석
* 클래스 혹은 정적 메서드가 쓰레드 안전하던 말던 쓰레드 안전 수준을 반드시 API 설명에 포함해야 한다.
* 또한 직렬화할 수 있는 클래스라면 직렬화 형태도 API 설명에 기술해야 한다.

### javadoc 주석 상속
* javadoc은 메서드 주석을 상속시킬 수 있는데, 문서화 주석이 없는 API 요소를 발견하면 javadoc이 가장 가까운 문서화 주석을 찾아준다.
* 이때 상위 클래스보다 그 클래스가 구현한 인터페이스를 먼저 찾는다.
* 또한 `{@inheritDoc}` 태그를 사용해 상위 타입의 문서화 주석 일부를 상속할 수도 있다.
* 클래스는 자신이 구현한 인터페이스의 문서화 주석을 재사용할 수 있다는 뜻이다.

### API 문서화 주석으로 충분하지 않을 경우
* 예를 들면 여러 클래스가 상호작용하는 복잡한 API라면 문서화 주석 외에도 전체 아키텍처를 설명하는 별도의 설명들이 필요한 경우가 많다.
* 이런 설명 문서가 있으면 관련 클래스나 패키지 문서화 주석에서 그 문서의 링크를 제공해주면 좋다.

### 정리
* 문서화 주석은 API를 문서화하는 가장 훌륭하고 효과적은 방법이다.
* 공개 API라면 빠짐없이 설명을 달아야 하며, 표준 규약을 일관되게 지켜야 한다.
* 문서화 주석에 임의의 HTML 태그를 사용할 수 있음을 기억해야 한다.
  * HTML 메타 문자는 특별하게 취급해야 한다.
* 잘 쓰인 문서인지를 확인하는 유일한 방법은 자바독 유틸리티가 생성한 웹페이지를 읽어보는 것이다.
  * 다른 사람이 사용할 API라면 반드시 모든 API 요소를 검토해야 하며, 생성된 API 문서를 읽어보면 고쳐야 할 부분이 눈에 들어온다.
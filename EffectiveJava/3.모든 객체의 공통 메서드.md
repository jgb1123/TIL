# 모든 객체의 공통 메서드

## item10. eqauls는 일반 규약을 지켜 재정의하라
* equals 메서드는 재정의하기 쉬워보이지만, 자칫하면 끔찍한 결과를 초래하기도 한다.
* 이러한 문제를 해결하는 가장 쉬운 방법은, 아예 재정의를 하지 않는 방법이다.
* 그냥 두면 그 클래스의 인스턴스는 오직 자기 자신과만 같게 된다.

### equals를 재정의하지 않는게 좋은 경우
#### 각 인스턴스가 본질적으로 고유한 경우
* 값을 표현하는게 아니라 동작하는 개체를 표현하는 클래스가 여기에 해당한다.
* Thread가 좋은 예시로, equals 메서드는 이러한 클래스에 딱 맞게 구현되어 있다.
#### 인스턴스의 논리적 동치성을 검사할일이 없는 경우
* java.util.regex.Pattern은 equals를 재정의해서 두 Pattern의 인스턴스가 같은 정규표현식을 나타내는지를 검사하는 방법도 있다. (논리적 동치성을 검사)
* 하지만 설계자는 클라이언트가 이 방식을 원하지 않았거나 애초에 필요하지 않다고 판단할 수 있는데, 후자로 판단한 경우 기본 equals만으로도 해결된다.
#### 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는 경우
* 대부분의 Set구현체는 AbstractSet이 구현한 eqauls를 상속받아 쓰고, List구현체들은 AbstractList로부터, Map구현체들은 AbstractMap으로부터 상속받아서 그대로 사용한다.
#### 클래스가 private이거나 package-private이고 eqauls 메서드를 호출할 일이 없는 경우
* eqauls가 실수로라도 호출되는걸 막고 싶으면 아래와 같이 막을 수 있다.
```java
@Ovveride
public boolean equals(Obejct o) {
    throw new AssertionError();
}   
```
   
### equals를 재정의해야 하는 경우
#### 객체 식별성이 아니라 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 경우이다.
* 주로 값 클래스들이 여기에 해당되며, 두 값 객체를 equals로 비교하는 프로그래머는 객체가 같은지가 아니라 값이 같은지를 알고 싶어한다.
* eqauls가 논리적 동치성을 확인하도록 재정의해두면 그 인스턴스는 값을 비교하길 원하는 프로그래머의 기대에도 부응하며, 또한 Map의 키와 Set의 원소로도 사용할 수 있게 된다.

#### 값 클래스라 해도 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장해야 하는 인스턴스 통계 클래스인 경우
* Enum도 여기에 해당하며, 이러한 클래스는 어차피 논리적으로 같은 인스턴스가 2개 이상 만들어지지 않으니 논리적 동치성과 객체 식별성이 사실상 똑같다.
* 따라서 Ojbect의 eqauls가 논리적 동치성까지 확인해준다고 볼 수 있다.

### equals 재정의 규약
* 반사성(reflexivity): null이 아닌 모든 참조값 x에 대해 x.equals(x)는 true이다.
* 대칭성(sysmetry): null이 아닌 모든 참조값 x, y에 대해 x.eqauls(y)가 true이면 y.equals(x)도 true이다.
* 추이성(transitivity): null이 아닌 모든 참조값 x,y,z에 대해 x.equals(y)가 true이고 y.eqauls(z)도 true면 x.equals(z)도 true이다.
* 일관성(consistency): null이 아닌 모든 참조값 x, y에 대해 x.equals(y)를 반복해서 호출하면 항상 true 이거나, 항상 false이다.
* null-아님: null이 아닌 모든 참조값 x에 대해 x.eqauls(null)은 false이다.

### 올바른 equals 메서드 구현 방법
#### == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
* 자기 자신이면 true를 반환한다.
* 단순한 성능 최적화용으로, 비교 작업이 복잡한 상황일 때 값어치를 한다.

#### instanceof 연산자로 입력이 올바른 타입인지 확인한다.
* 그렇지 않다면 false를 반환한다.
* 올바른 타입은 eqauls가 정의된 클래스인 것이 보통이지만, 가끔은 그 클래스가 구현한 특정 인터페이스가 될 수도 있다.
* 또한 어떤 인터페이스는 자신을 구현한 서로다른 클래스끼리도 비교할 수 있도록 equals 규약을 수정하기도 한다.
* 이런 인터페이스를 구현한 클래스라면 equals에서 클래스가 아닌 해당 인터페이스를 사용해야 한다.
* 예시로 List, Map, Map.Entry등의 컬렉션 인터페이스들이 있다.

#### 입력을 올바른 타입으로 형변환한다.
* 이전에 instanceof 검사를 했기 때문에 이 단계는 100% 성공한다.

#### 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사한다.
* 모든 피륻가 일치하면 true를, 하나라도 다르면 false를 반환한다.
* 인터페이스를 사용했다면 입력의 필드 값을 가져올 때도 그 인터페이스의 메서드를 사용해야 한다.
* 타입이 클래스라면 접근 권한에 따라 해당 필드에 직접 접근할 수도 있다.

### eqauls 구현 시 주의사항
* eqauls를 재정의할 때는 hashcode도 반드시 재정의 해야한다.
* 또한 너무 복잡하게 해결하려고 하지 말고, 필드들의 동치성만 검사해도 eqauls 규약을 어렵지 않게 지킬 수 있다.
* Obejct외의 타입을 매개변수로 받는 eqauls 메서드를 정의하지 않아야 한다.
  * 해당 메서드는 Object.eqauls를 오버라이딩 한게 아니라 오버로딩 한 것에 불과하다.

### 정리
* 꼭 필요한 경우가 아니라면 eqauls를 재정의하지 않는게 좋다.
* 많은 경우에 Object equals가 원하는 비교를 정확히 수행해준다.
* 재정의해야 할 때에는 그 클래스의 핵심 필드 모두를 빠짐없이 다섯가지 규약을 확실히 지켜가며 비교해야 한다.

## item11. equals를 재정의하려거든 hashCode도 재정의하라
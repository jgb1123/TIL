# 모든 객체의 공통 메서드

## item10. eqauls는 일반 규약을 지켜 재정의하라
* equals 메서드는 재정의하기 쉬워보이지만, 자칫하면 끔찍한 결과를 초래하기도 한다.
* 이러한 문제를 해결하는 가장 쉬운 방법은, 아예 재정의를 하지 않는 방법이다.
* 그냥 두면 그 클래스의 인스턴스는 오직 자기 자신과만 같게 된다.

### equals를 재정의하지 않는게 좋은 경우
#### 각 인스턴스가 본질적으로 고유한 경우
* 값을 표현하는게 아니라 동작하는 개체를 표현하는 클래스가 여기에 해당한다.
* Thread가 좋은 예시로, equals 메서드는 이러한 클래스에 딱 맞게 구현되어 있다.
#### 인스턴스의 논리적 동치성을 검사할일이 없는 경우
* java.util.regex.Pattern은 equals를 재정의해서 두 Pattern의 인스턴스가 같은 정규표현식을 나타내는지를 검사하는 방법도 있다. (논리적 동치성을 검사)
* 하지만 설계자는 클라이언트가 이 방식을 원하지 않았거나 애초에 필요하지 않다고 판단할 수 있는데, 후자로 판단한 경우 기본 equals만으로도 해결된다.
#### 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는 경우
* 대부분의 Set구현체는 AbstractSet이 구현한 eqauls를 상속받아 쓰고, List구현체들은 AbstractList로부터, Map구현체들은 AbstractMap으로부터 상속받아서 그대로 사용한다.
#### 클래스가 private이거나 package-private이고 eqauls 메서드를 호출할 일이 없는 경우
* eqauls가 실수로라도 호출되는걸 막고 싶으면 아래와 같이 막을 수 있다.
```java
@Ovveride
public boolean equals(Obejct o) {
    throw new AssertionError();
}   
```
   
### equals를 재정의해야 하는 경우
#### 객체 식별성이 아니라 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 경우이다.
* 주로 값 클래스들이 여기에 해당되며, 두 값 객체를 equals로 비교하는 프로그래머는 객체가 같은지가 아니라 값이 같은지를 알고 싶어한다.
* eqauls가 논리적 동치성을 확인하도록 재정의해두면 그 인스턴스는 값을 비교하길 원하는 프로그래머의 기대에도 부응하며, 또한 Map의 키와 Set의 원소로도 사용할 수 있게 된다.

#### 값 클래스라 해도 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장해야 하는 인스턴스 통계 클래스인 경우
* Enum도 여기에 해당하며, 이러한 클래스는 어차피 논리적으로 같은 인스턴스가 2개 이상 만들어지지 않으니 논리적 동치성과 객체 식별성이 사실상 똑같다.
* 따라서 Ojbect의 eqauls가 논리적 동치성까지 확인해준다고 볼 수 있다.

### equals 재정의 규약
* 반사성(reflexivity): null이 아닌 모든 참조값 x에 대해 x.equals(x)는 true이다.
* 대칭성(sysmetry): null이 아닌 모든 참조값 x, y에 대해 x.eqauls(y)가 true이면 y.equals(x)도 true이다.
* 추이성(transitivity): null이 아닌 모든 참조값 x,y,z에 대해 x.equals(y)가 true이고 y.eqauls(z)도 true면 x.equals(z)도 true이다.
* 일관성(consistency): null이 아닌 모든 참조값 x, y에 대해 x.equals(y)를 반복해서 호출하면 항상 true 이거나, 항상 false이다.
* null-아님: null이 아닌 모든 참조값 x에 대해 x.eqauls(null)은 false이다.
# 람다와 스트림
## item42. 익명 클래스보다는 람다를 사용하라
### 익명클래스
* 예전에는 자바에서 함수 타입을 표현할 때 추상메서드를 하나만 담은 인터페이스(혹은 추상클래스)를 사용했다.
* 이런 인터페이스는 함수 객체라고 하며 특정 함수나 동작을 나타내는데 사용햇다.
* 1997년 JDK 1.1이 등장하면서 함수 객체를 만드는 주요 수단은 익명클래스가 되었었다.
* 함수 객체를 사용하는 과거 객체 지향 디자인 패턴에는 익명클래스면 충분했었다.
* 하지만 익명 클래스 방식은 코드가 너무 길기 때문에 자바는 함수형 프로그래밍에 적합하지 않았다.

### 람다식
* 자바 8에서 추상메서드 하나짜리 인터페이스는 특별한 대우를 받게 되었다.
* 함수형 인터페이스라 부르는 이 인터페이스들의 인스턴스를 람다식을 사용해 만들 수 있게 되었다.
* 람다는 함수나 익명 클래스와 개념은 비슷하지만 코드는 훨씬 간결하다.
```java
Collections.sort(words,
    (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```
* 위 람다식에서 람다, 매개변수와 반환값의 타입은각각 `(Comparator<String>)`, `String`, `int` 이지만 코드에서는 표시되어있지 않다.
* 컴파일러가 문맥을 살펴 타입을 추론해주었기 때문이다.
* 상황에 따라 컴파일러가 타입을 결정하지 못할 수도 있는데, 그럴 때에는 직접 명시해야 한다.
* 따라서 타입을 명시해야 코드가 더 명확할 때만 제외하고는 람다의 모든 매개변수 타입은 생략해도 된다.

#### 위 예시를 더 간결하게 만든 예시 
```java
Collections.sort(words, comparingInt(String::length));
```
* 람다 자리에 비교자 생성 메서드를 사용하면 코드는 더 간결하게 만들 수 있다.

```java
words.sort(comparingInt(String::length));
```
* 자바 8에 List 인터페이스에 추가된 sort 메서드를 사용하면 더더욱 짧아진다.

### 람다식의 장점이 보이는 예시
```java
public enum Operation {
    PLUS("+") {
        public double apply(double x, double y) { return x + y; }
    },
    MINUS("-") {
        public double apply(double x, double y) { return x - y; }
    },
    ...
}
```
* 위와같이 열거 타입의 인스턴스 필드를 이용하여 상수별로 다르게 동작하는 코드를 만들 수 있다.
* 위 예시를 람다로 구현하면 훨씬 간결하고 깔끔해진다.

```java
public enum Operation {
    PLUS ("+", (x, y) -> x + y),
    MINUS ("-", (x, y) -> x - y),
    ...
}
```
### 람다 사용 시 주의할 점
* 람다는 이름이 없고 문서화도 하지 못한다.
* 따라소 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다.
* 보통 람다는 1줄일 때가 가장 좋고, 길어야 3줄 안에 끝내는 것이 좋다.
* 그 이상 넘어가면 가독성이 심하게 나빠지며, 만약 람다가 길거나 읽기 어렵다면 람다를 쓰지 않는 쪽으로 리팩토링 하는것이 좋다.
* 람다도 익명 클래스처럼 직렬화 형태가 구현별로 다를 수 있기 때문에 람다를 직렬화하는 일은 극히 조심해야 한다.
  * 익명클래스의 인스턴스도 마찬가지이다.

### 람다 vs 익명클래스
* 람다로 대체할 수 없는 곳이 있다.
* 람다는 함수형 인터페이스에서만 쓰인다.
  * 추상 클래스의 인스턴스를 만들 때 람다를 쓸 수 없으며, 익명 클래스를 써야 한다.
  * 비슷하게 추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때도 익명클래스를 쓸 수 있다.
* 또한 람다는 자신을 참조할 수 없다.
  * 람다에서의 this는 바깥 인스턴스를 가리키지만, 익명 클래스에서의 this는 익명클래스의 인스턴스 자신을 가리킨다.

### 정리
* 자바 8에서 작은 함수 객체를 구현하는 데 적합한 람다가 도입되었다.
* 익명 클래스는 함수형 인터페이스가 아닌 타입의 인스턴스를 만들 때만 사용하면 된다.
* 람다는 작은 함수 객체를 아주 쉽게 표현할 수 있기 때문에 자바에서는 쉽지 않던 함수형 프로그래밍의 문을 열었다.

## item43. 람다보다는 메서드 참조를 사용하라
### 메서드 참조
* 람다가 익명클래스보다 나은 점 중 가장 큰 특징은 간결함이다.
* 그런데 자바에서는 함수 객체를 람다보다도 더 간결하게 만드는 방법이 있는데, 바로 메서드 참조이다.

### 메서드 참조 예시
```java
map.merge(key, 1, (count, incr) -> count + incr);
```
* 이 코드는 키가 맵 안에 없다면 키와 숫자 1을 매핑하고, 이미 있다면 기존 매핑값을 증가시키는 코드이다.
* 이코드는 이미 충분히 간결하고 깔끔해 보이지만, 아직 매개변수인 count와 incr은 크게 하는 일 없이 공간을 차지하고 있다.
* 자바 8이 되면서 Integer 클래스는 이 람다와 기능이 같은 정적 메서드인 sum을 제공하며, 따라서 람다 대신 이 메서드의 참조를 전달하면 똑같은 결과를 얻을 수 있다.
```java
map.merge(key, 1, Integer::sum); 
```

### 람다와 메서드 참조
* 매개변수가 늘어날수록 메서드 참조로 제거할 수 있는 코드 양도 늘어난다.
  * 하지만 어떤 람다에서는 매개변수의 이름 자체가 좋은 가이드가 되기도 한다.
  * 람다는 길이는 더 길지만 메서드 참조보다 읽기 쉽고 유지보수도 쉬울 수 있다.
* 람다로 할 수 없는 일이면 메서드 참조로도 할 수 없다.
* 메서드 참조를 사용하는 편이 보통은 더 짧고 간결하기 때문에 람다로 구현했을 때 너무 길거나 복잡하면 메서드 참조가 좋은 대안이 되어줄 수 있다.
  * 람다로 작성할 코드를 새로운 메서드에 담은 후, 람다 대신 그 메서드 참조를 사용하는 식이다.
  * 메서드 참조에는 기능을 잘 드러내는 일므을 지어줄 수 있고, 친절한 설명을 문서로 남길수도 있다.

### 메서드 참조보다 람다가 더 간결한 경우
* IDE들은 람다를 메서드참조로 대체하라고 권하지만, 보통은 IDE의 권고를 따르는게 이득이겠지만 항상 그런 것은 아니다.
* 때로는 람다가 메서드 참조보다 간결할 때가 있으며, 주로 메서드와 람다가 같은 클래스에 있을 경우 그렇다.

```java
service.execute(CoshThisClassNameIsHumongous::action);
```

```java
service.execute(() -> action());
```
* 위 예시에서 보면 메서드 참조는 더 짧지도 않고 더 명확하지도 않다.
* 대표적인 예시로 `java.util.function` 패키지가 제공하는 제네릭 정적 팩토리 메서드인 `Function.identity()`를 사용하기 보다는 똑같은 기능의 `(x -> x)`를 직접 사용하는것이 좋다.

### 메서드 참조의 유형
* 정적 메서드를 가리키는 메서드 참조
  ```java
  // 메서드참조
  Integer::parseInt
  // 람다
  str -> Integer.parseInt(str)
  ```
* 수신 객체(receiving object, 참조대상 인스턴스)를 특정하는 한정적 인스턴스 메서드 참조
  ```java
  // 메서드참조
  Instant.now()::isAfter
  // 람다
  Instant then = Instant.now();
  t -> then.isAfter(t);
  ```
  * 근본적으로는 정적 참조와 비슷하다.
* 수신 객체를 특정하지 않는 비한정적 인스턴스 메서드 참조
  ```java
  // 메서드참조
  String::toLowerCase
  // 람다
  str -> str.toLowerCase()
  ```
  * 함수 객체를 적용하는 시점에 수신 객체를 알려준다.
* 클래스 생성자를 가리키는 메서드 참조
  ```java
  // 메서드참조
  TreeMap<K,V>::new
  // 람다
  () -> new TreeMap<K,V>()
  ```
* 배열 생성자를 가리키는 메서드 참조
  ```java
  // 메서드참조
  int[]::new
  // 람다
  len -> new int[len]
  ```
### 정리 
* 메서드 참조는 람다보다 간단한 좋은 대안이 될 수 있다.
* 메서드 참조를 쓰는 것이 더 짧고 명확하다면 메서드 참조를 쓰고, 그렇지 않으면 람다를 사용해야 한다.
# 람다와 스트림
## item42. 익명 클래스보다는 람다를 사용하라
### 익명클래스
* 예전에는 자바에서 함수 타입을 표현할 때 추상메서드를 하나만 담은 인터페이스(혹은 추상클래스)를 사용했다.
* 이런 인터페이스는 함수 객체라고 하며 특정 함수나 동작을 나타내는데 사용햇다.
* 1997년 JDK 1.1이 등장하면서 함수 객체를 만드는 주요 수단은 익명클래스가 되었었다.
* 함수 객체를 사용하는 과거 객체 지향 디자인 패턴에는 익명클래스면 충분했었다.
* 하지만 익명 클래스 방식은 코드가 너무 길기 때문에 자바는 함수형 프로그래밍에 적합하지 않았다.

### 람다식
* 자바 8에서 추상메서드 하나짜리 인터페이스는 특별한 대우를 받게 되었다.
* 함수형 인터페이스라 부르는 이 인터페이스들의 인스턴스를 람다식을 사용해 만들 수 있게 되었다.
* 람다는 함수나 익명 클래스와 개념은 비슷하지만 코드는 훨씬 간결하다.
```java
Collections.sort(words,
    (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```
* 위 람다식에서 람다, 매개변수와 반환값의 타입은각각 `(Comparator<String>)`, `String`, `int` 이지만 코드에서는 표시되어있지 않다.
* 컴파일러가 문맥을 살펴 타입을 추론해주었기 때문이다.
* 상황에 따라 컴파일러가 타입을 결정하지 못할 수도 있는데, 그럴 때에는 직접 명시해야 한다.
* 따라서 타입을 명시해야 코드가 더 명확할 때만 제외하고는 람다의 모든 매개변수 타입은 생략해도 된다.

#### 위 예시를 더 간결하게 만든 예시 
```java
Collections.sort(words, comparingInt(String::length));
```
* 람다 자리에 비교자 생성 메서드를 사용하면 코드는 더 간결하게 만들 수 있다.

```java
words.sort(comparingInt(String::length));
```
* 자바 8에 List 인터페이스에 추가된 sort 메서드를 사용하면 더더욱 짧아진다.

### 람다식의 장점이 보이는 예시
```java
public enum Operation {
    PLUS("+") {
        public double apply(double x, double y) { return x + y; }
    },
    MINUS("-") {
        public double apply(double x, double y) { return x - y; }
    },
    ...
}
```
* 위와같이 열거 타입의 인스턴스 필드를 이용하여 상수별로 다르게 동작하는 코드를 만들 수 있다.
* 위 예시를 람다로 구현하면 훨씬 간결하고 깔끔해진다.

```java
public enum Operation {
    PLUS ("+", (x, y) -> x + y),
    MINUS ("-", (x, y) -> x - y),
    ...
}
```
### 람다 사용 시 주의할 점
* 람다는 이름이 없고 문서화도 하지 못한다.
* 따라소 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다.
* 보통 람다는 1줄일 때가 가장 좋고, 길어야 3줄 안에 끝내는 것이 좋다.
* 그 이상 넘어가면 가독성이 심하게 나빠지며, 만약 람다가 길거나 읽기 어렵다면 람다를 쓰지 않는 쪽으로 리팩토링 하는것이 좋다.
* 람다도 익명 클래스처럼 직렬화 형태가 구현별로 다를 수 있기 때문에 람다를 직렬화하는 일은 극히 조심해야 한다.
  * 익명클래스의 인스턴스도 마찬가지이다.

### 람다 vs 익명클래스
* 람다로 대체할 수 없는 곳이 있다.
* 람다는 함수형 인터페이스에서만 쓰인다.
  * 추상 클래스의 인스턴스를 만들 때 람다를 쓸 수 없으며, 익명 클래스를 써야 한다.
  * 비슷하게 추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때도 익명클래스를 쓸 수 있다.
* 또한 람다는 자신을 참조할 수 없다.
  * 람다에서의 this는 바깥 인스턴스를 가리키지만, 익명 클래스에서의 this는 익명클래스의 인스턴스 자신을 가리킨다.

### 정리
* 자바 8에서 작은 함수 객체를 구현하는 데 적합한 람다가 도입되었다.
* 익명 클래스는 함수형 인터페이스가 아닌 타입의 인스턴스를 만들 때만 사용하면 된다.
* 람다는 작은 함수 객체를 아주 쉽게 표현할 수 있기 때문에 자바에서는 쉽지 않던 함수형 프로그래밍의 문을 열었다.

## item43. 람다보다는 메서드 참조를 사용하라
### 메서드 참조
* 람다가 익명클래스보다 나은 점 중 가장 큰 특징은 간결함이다.
* 그런데 자바에서는 함수 객체를 람다보다도 더 간결하게 만드는 방법이 있는데, 바로 메서드 참조이다.

### 메서드 참조 예시
```java
map.merge(key, 1, (count, incr) -> count + incr);
```
* 이 코드는 키가 맵 안에 없다면 키와 숫자 1을 매핑하고, 이미 있다면 기존 매핑값을 증가시키는 코드이다.
* 이코드는 이미 충분히 간결하고 깔끔해 보이지만, 아직 매개변수인 count와 incr은 크게 하는 일 없이 공간을 차지하고 있다.
* 자바 8이 되면서 Integer 클래스는 이 람다와 기능이 같은 정적 메서드인 sum을 제공하며, 따라서 람다 대신 이 메서드의 참조를 전달하면 똑같은 결과를 얻을 수 있다.
```java
map.merge(key, 1, Integer::sum); 
```

### 람다와 메서드 참조
* 매개변수가 늘어날수록 메서드 참조로 제거할 수 있는 코드 양도 늘어난다.
  * 하지만 어떤 람다에서는 매개변수의 이름 자체가 좋은 가이드가 되기도 한다.
  * 람다는 길이는 더 길지만 메서드 참조보다 읽기 쉽고 유지보수도 쉬울 수 있다.
* 람다로 할 수 없는 일이면 메서드 참조로도 할 수 없다.
* 메서드 참조를 사용하는 편이 보통은 더 짧고 간결하기 때문에 람다로 구현했을 때 너무 길거나 복잡하면 메서드 참조가 좋은 대안이 되어줄 수 있다.
  * 람다로 작성할 코드를 새로운 메서드에 담은 후, 람다 대신 그 메서드 참조를 사용하는 식이다.
  * 메서드 참조에는 기능을 잘 드러내는 일므을 지어줄 수 있고, 친절한 설명을 문서로 남길수도 있다.

### 메서드 참조보다 람다가 더 간결한 경우
* IDE들은 람다를 메서드참조로 대체하라고 권하지만, 보통은 IDE의 권고를 따르는게 이득이겠지만 항상 그런 것은 아니다.
* 때로는 람다가 메서드 참조보다 간결할 때가 있으며, 주로 메서드와 람다가 같은 클래스에 있을 경우 그렇다.

```java
service.execute(CoshThisClassNameIsHumongous::action);
```

```java
service.execute(() -> action());
```
* 위 예시에서 보면 메서드 참조는 더 짧지도 않고 더 명확하지도 않다.
* 대표적인 예시로 `java.util.function` 패키지가 제공하는 제네릭 정적 팩토리 메서드인 `Function.identity()`를 사용하기 보다는 똑같은 기능의 `(x -> x)`를 직접 사용하는것이 좋다.

### 메서드 참조의 유형
* 정적 메서드를 가리키는 메서드 참조
  ```java
  // 메서드참조
  Integer::parseInt
  // 람다
  str -> Integer.parseInt(str)
  ```
* 수신 객체(receiving object, 참조대상 인스턴스)를 특정하는 한정적 인스턴스 메서드 참조
  ```java
  // 메서드참조
  Instant.now()::isAfter
  // 람다
  Instant then = Instant.now();
  t -> then.isAfter(t);
  ```
  * 근본적으로는 정적 참조와 비슷하다.
* 수신 객체를 특정하지 않는 비한정적 인스턴스 메서드 참조
  ```java
  // 메서드참조
  String::toLowerCase
  // 람다
  str -> str.toLowerCase()
  ```
  * 함수 객체를 적용하는 시점에 수신 객체를 알려준다.
* 클래스 생성자를 가리키는 메서드 참조
  ```java
  // 메서드참조
  TreeMap<K,V>::new
  // 람다
  () -> new TreeMap<K,V>()
  ```
* 배열 생성자를 가리키는 메서드 참조
  ```java
  // 메서드참조
  int[]::new
  // 람다
  len -> new int[len]
  ```
### 정리 
* 메서드 참조는 람다보다 간단한 좋은 대안이 될 수 있다.
* 메서드 참조를 쓰는 것이 더 짧고 명확하다면 메서드 참조를 쓰고, 그렇지 않으면 람다를 사용해야 한다.

## item44. 표준 함수형 인터페이스를 사용하라
### 필요한 용도에 맞는게 있다면 직접 구현하지 말고 표준 함수형 인터페이스를 활용하라
* API가 다루는 개념의 수가 줄어들기 때문에 익히기도 더 쉬워진다.
* 또한 표준 함수형 인터페이스들은 유용한 디폴트 메서드들을 많이 제공하기 때문에 다른 코드와의 호환성도 좋아진다.

### java.util.function의 인터페이스
* `java.util.function` 패키지에는 총 43개의 인터페이스들이 담겨있다.
* 전부 기억해놓긴 어려워도 기본 인터페이스 6개만 잘 기억해두면 나머지들을 충분히 유추해낼 수 있다.
* `Operator` : 인수가 1개인 `UnaryOperator`와 2개인 `BinaryOperator`로 나뉘며 반환값과 인수의 타입이 같은 함수를 뜻한다.
* `Predicate` : 인수 하나를 받아 boolean을 반환하는 함수를 뜻한다.
* `Fuction` : 인수와 반환 타입이 다른 함수를 뜻한다.
* `Supplier` : 인수를 받지 않고 값을 반환하는 함수를 뜻한다.
* `Consumer` : 인수를 하나 받고 반환값은 없는 함수를 뜻한다.

#### 기본타입 변형 인터페이스
* 기본 인터페이스에는 기본 타입인 int, long, double용으로 각 3개씩 변형이 생겨난다.
* 기본 인터페이스는 기본 타입인 int, long, double용으로 각 3개씩 변형이 생겨난다.
* 이름도 기본 인터페이스의 이름 앞에 해당 기본 타입 이름을 붙여 지어져있다.
* int를 받는 `Predicate`는 `IntPredicate`이고, long을 받아 long을 반환하는 `BinaryOperator`는 `LongBinaryOperator`가 된다.

#### 반환타입 매개변수화 변형 인터페이스
* 변형들 중에서 `Function`만 반환타입이 매개변수화 되었는데, `LongFunction<int[]>`은 long 인수를 받아 int[]을 반환한다.
* `Function` 인터페이스에는 기본 타입을 반환하는 변형이 9개가 있는데, 인수와 같은 타입을 반환하는 함수는 `UnaryOperator`이므로 `Fucntion` 인터페이스의 변형은 입력과 결과의 타입이 항상 다르다.
* 입력과 결과 타입이 모두 기본 타입이면 접두어로 `SrtToResult`와같이 사용한다. (6개)
  * 예시로 `LongToIntFunction`은 long을 받아 int를 반환한다.
* 또 입력이 객체 참조이고 결과가 int, long ,double인 변형들은 접두어로 `ToResult`를 사용한다. (3개)
  * 예시로 `ToLongFunction<int[]>`은 int[]인수를 받아 long을 반환한다.

#### 인수를 2개씩 받는 변형 인터페이스
* 기본 함수형 인터페이스 중 3개에는 인수를 2개씩 받는 변형이 있다.
* `BiPredicate<T,U>`, `BiFunction<T,U,R>`, `BiConsumer<T,U>`이다.
* `BiFunction`은 다시 기본 타입을 반환하는 세 변형 `ToIntBiFunction<T,U>`, `ToLongBiFunction<T,U>`, `ToDoubleBiFunction<T,U>`이 있다.
* `Consumer`에도 객체 참조와 기본 타입하나 총 인수 2개를 받는 변형인 `ObjIntConsumer<T>`, `ObjLongConsumer<T>`, `ObjDoubleConsumer<T>` 가 있다.

#### boolean을 반환하도록 한 변형 인터페이스
* `BooleanSupplier` 인터페이스는 boolean을 반환하도록 한 `Supplier`의 변형이다.
* 표준 함수형 인터페이스 중 boolean을 이름에 명시한 유일한 인터페이스이긴 하지만, `Predicate`와 그 변형 4개도 boolean 값을 반환한다.

### 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지 말아라
* 동작은 하게 되지만 `박싱된 기본 타입 대신 기본 타입을 사용하라`라는 item61의 개념에 위배된다.
* 계산량이 많을 때는 성능이 많이 느려질 수 있다.

### 직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface 애너테이션을 사용하라
* 이 애너테이션을 사용하는 이유는 `@Override`를 사용하는 이유와 비슷하다.
* 해당 클래스의 코드나 설명 문서를 읽을 사람에게 그 인터페이스가 람다용으로 설계된 것임을 알려준다.
* 해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일되게 해준다.
* 그 결과 유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막아준다.

### 함수형 인터페이스 API 사용 시 주의사항
* 서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들을 다중 정의하면 안된다.
* 클라이언트에게 불필요하게 모호함을 안겨주며, 이 모호함으로 인해 문제가 발생할 수도 있다.
* 예시로 `ExecutorService`의 submit 메서드는 `Callable<T>`를 받는 것과 `Runnable`을 받는 것을 다중정의 했다.
* 올바른 메서드를 알려주기 위해 형변환해야 할 때가 자주 생긴다.
* 이러한 문제를 피하기 위한 가장 쉬운 방법은 서로 다른 함수형 인터페이스를 같은 위치의 인수로 사용하는 다중정의를 피하는 것이다.

### 정리
* 자바도 람다를 지원하며, API를 설계할 때 람다도 염두에 두어야 한다.
* 입력값과 반환값에 함수형 인터페이스 타입을 활용하면 좋다.
* 보통은 `java.util.function` 패키지의 표준 함수형 인터페이스를 사용하는것이 가장 좋은 선택이다.
  * 흔치는 않지만 직접 새로운 함수형 인터페이스를 만들어 쓰는 편이 나을수도 있긴 하다.

## item45. 스트림은 주의해서 사용하라
### Stream?
* 스트림 API는 다량의 데이터 처리작업을 위해 자바 8에서 추가되었다.
* 스트림은 데이터 원소의 유한 혹은 무한 스퀀스를 뜻한다.
* 스트림 파이프라인은 이 원소들로 수행하는 연산 단계를 표현하는 개념이다.
* 스트림의 원소들은 어디로부터든 올 수 있다.
  * 컬렉션, 배열, 파일, 정규표현식 패턴 matcher, 난수 생성기, 다른 Stream
* 스트림 안의 데이터 원소들은 객체 참조나 기본 타입값이다.
  * 기본 타입값으로는 int, long, double 세가지를 지원한다.

### Stream PipeLine
* 스트림 파이프라인은 소스 스트림에서 시작해 종단 연산으로 끝이 나며, 그 사이에 하나 이상의 중간 연산이 있을 수 있다.
* 각 중간 연산은 스트림을 어떠한 방식으로 변환하는데, 중간 연산들은 모두 한 스트림을 다른 스트림으로 변환하며, 변환된 스트림의 원소 타입은 변환전 스트림의 원소 타입과 같을수도 있고 다를수도 있다.
* 종단 연산은 마지막 중간 연산이 내놓은 스트림에 최후의 연산을 가한다.
  * 원소를 정렬해 컬렉션이 담거나, 특정 원소 하나를 선택하거나, 모든 원소를 출력하는 등
* 스트림 파이프라인은 지연평가 된다.
  * 평가는 종단 연산이 호출될 때 이뤄지며, 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않는다.
  * 이러한 지연 평가가 무한 스트림을 다룰 수 있게 해준다.
* 종단 연산이 없는 스트림 파이프라인은 아무 일도 하지 않는 명령어인 no-op과 같기 때문에 종단 연산을 빼먹어선 안된다.
* 스트림 API는 메서드 연쇄를 지원하는 플루언트 API이다.
  * 파이프 라인 하나를 구성하는 여러 개를 연결해 표현식 하나로 만들 수 있따.
* 스트림 파이프라인은 순차적으로 수행되며, 파이프라인을 병렬로 실행하려면 파이프라인을 구성하는 스트림 중 하나에서 parallel 메서드를 호출해주기만 하면 되지만, 효과를 볼 수 있는 상황은 별로 없다.

### 스트림 사용 시 주의사항
* 스트림 API는 다재다능하기 때문에 어떠한 계산이라도 할 수 있다.
* 하지만 스트림을 쓰는것이 꼭 좋지만은 않다.
* 스트림을 제대로 사용하면 프로그램이 짧고 깔끔해지지만, 잘못 사용하면 읽기 어렵고 유지보수도 힘들어진다.
* 스트림을 언제써야 하는지를 규정하는 확고한 규칙은 없지만, 참고할만한 정보는 있다.

#### 스트림을 적절히 사용해라
* 스트림을 과용하면 프로그램이 읽거나 유지보수하기 어려워지므로 적당히 사용하여 절충 지점을 찾아야 한다.
* 기존 코드는 스트림을 사용하도록 리팩토링 해보고, 새 코드가 더 나아 보일때 반영해야 한다.
* char 값들을 처리할 때에는 스트림을 사용하지 않는 것이 좋다.

#### 스트림을 사용하지 못하는 상황
* 코드블록에서는 범위 안의 지역변수를 읽고 수정할 수 있다.
  * 람다에서는 final이거나 사실상 final인 변수만 읽을 수 있고 지역 변수를 수정하는건 불가능하다.
* 코드블록에서는 return문을 사용해 메서드를 빠져나가거나, break나 continue문으로 블록 바깥의 반복문을 종료하거나 반복을 한번 건너 뛸 수 있고, 메서드 선언에 명시된 검사 예외를 던질수도 있다.
  * 람다는 이러한 것들을 할 수 없다.

#### 스트림을 사용하기 좋은 상황
* 원소들의 시퀀스를 일관되게 변환한다.
* 원소들의 시퀀스를 필터링한다.
* 원소들의 시퀀스를 하나의 연산을 사용해 결합한다.
* 원소들의 시퀀스를 컬렉션에 모은다.
* 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다.

#### 스트림을 사용하기 어려운 상황 
* 한 데이터가 파이프라인의 여러 단계를 통과할 때 이 데이터의 각 단계에서의 값들에 동시에 접근하기 어려운 경우엔 스트림을 사용하기 어렵다.
* 스트림 파이프라인은 일단 한 값을 다른 값에 매핑하고 나면 원래의 값은 잃는 구조이기 때문이다.
* 원래 값과 새로운 값의 쌍을 저장하는 객체를 사용해 매핑하는 우회방법도 있긴 하지만, 올바른 해법은 아니다.

#### 정리
* 스트림을 사용해야 멋지게 처리할 수 있는 일이 있으며, 반복 방식이 더 알맞은 일도 있다.
* 또한 대부분의 작업들은 이 둘을 조합했을 때 가장 멋지게 해결된다.
* 어느 쪽을 선택하는 확고한 규칙은 없지만 참고할만한 더 좋은 방향은 있다.
* 어느 쪽이 나은지가 확연히 드러나는 경우가 많겠지만, 아니더라도 방법은 있는데, 둘 다 해보고 더 나은 쪽을 선택하면 된다.

## item46. 스트림에서는 부작용 없는 함수를 사용하라
### 스트림은 side effect가 없도록 사용해야 한다.
* 스트림 패러타임의 핵심은 계산을 일련의 변환으로 재구성하는 부분이다.
* 이때 각 변환 단계는 가능한 한 이전 단계의 결과를 받아 처리하는 순수 함수여야 한다.
  * 순수 함수는 오직 입력만이 결과에 영향을 주는 함수를 뜻하며, 다른 가변 상태를 참조하지 않고 함수 스스로도 다른 상태를 변경하지 않는다.
* 이렇게 하려면 스트림 연산에 건네는 함수 객체는 모두 side effect가 없어야 한다.

### 잘못된 스트림 코드
```java
Map<String, Long> freq = new HashMap<>();
try (Stream<String> words = new Scanner(file).tokens()){
    words.forEach(word -> {
        freq.merge(word.toLowerCase(), 1L, Long::sum);
    });
}
```
* forEach는 연산 결과를 보여주는 역할을 가진 종단 연산인데, 위 예시는 외부 상태인 freq를 수정하고 있다.
* 함수 스스로 외부 상태를 변경하고 연산 결과를 보여주는 일을 하고 있는 것이다.
* 이것은 스트림처럼 보이는 반복문일 뿐이다.

### 좋은 스트림 코드
```java
Map<String, Long> freq = new HashMap<>();
try (Stream<String> words = new Scanner(file).tokens()){
    freq = words.collect(groupingBy(String::toLowerCase, counting()))
}
```
* 위 예시는 스트림 API를 제대로 사용한 예시며, 짧고 명확하다.
* forEach는 종단 연산 중 기능이 가장 적고 가장 덜 스트림답다.
* 대놓고 반복적이기 때문에 병렬화도 할 수 없다.
* forEach 연산은 스트림 계산 결과를 보고할 때만 사용하고, 계산하는 데에는 쓰지 않아야 한다.

### collector
* collector는 `java.util.stream.Collectors` 클래스의 메서드를 사용하는데, 스트림의 원소들을 축소해 객체 하나에 모아주는 역할을 한다.
* collector가 생성하는 객체는 일반적으로 컬렉션이며, collector를 사용하면 스트림의 원소를 손쉽게 컬렉션으로 모을 수 있다.
* collector는 총 세가지로, toList(), toSet(), toCollection(collectionFactory)이다.

### toList()
```java
List<String> topTen = freq.keySet().stream()
    .sorted(comparing(freq::get).reversed())
    .limit(10)
    .collect(toList());
```
* 위 예시처럼 스트림 원소를 List로 모아준다.
* 위 예시는 `Collectors`를 정적 임포트하여 사용하는데, 이러면 가독성이 좋아진다.
  * `collect(Collectors.toList())`->`collect(toList())`

### toMap()
#### toMap(keyMapper, valueMapper)
* 스트림 원소를 key에 매핑하는 함수와 값에 매핑하는 함수를 인수로 받는다.

```java
private static final Map<String, Operation> stringToEnum = 
    Stream.of(values()).collect(
        toMap(Object::toString, e -> e));
```
* 이러한 `toMap()`은 스트림의 각 원소가 고유한 키에 매핑되어 있을 때 적합하다.

#### toMap(keyMapper, valueMapper, mergeFunction)
* 같은 키를 공유하는 값들이 있는 경우 병합 함수를 통해 기존 값에 합쳐진다.
* 어떤 키와 그 키에 연관된 원소들 중 하나를 골라 연관짓는 맵을 만들 때 유용하다.
```java
Map<Artist, Album> topHits = albums.collect(
    toMap(Album::artist, a -> a, maxBy(comparing(Album::sales)))); 
```

#### toMap(keyMapper, valueMapper, mergeFunction, Map의 구현체)
* 마지막 인수로 맵 팩토리를 받는다.
* `EnumMap`이나 `TreeMap`처럼 원하는 특정 맵 구현체를 직접 지정할 수 있다.
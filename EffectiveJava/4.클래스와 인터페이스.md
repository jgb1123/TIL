# 클래스와 인터페이스
## item15. 클래스와 멤버의 접근 권한을 최소화하라
### 정보의 은닉, 캡슐화
* 어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼는지 이다.
* 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨 구현과 API를 깔끔히 분리한다.
* 오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다.
* 이러한 개념을 정보은닉, 캡슐화라고 하며 소프트웨어 설계의 근간이 되는 원리이다.

### 정보 은닉의 장점
* 시스템 개발 속도를 높인다.
  * 여러 컴포넌트를 병렬로 개발할 수 있다.
* 시스템 관리 비용을 낮춘다.
  * 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고 다른 컴포넌트로 교체하는 부담이 적다
* 정보 은닉 자체가 성능을 높여주지는 않지만 성능 최적화에 도움을 준다.
  * 완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한다음 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있다.
* 소프트웨어 재사용성을 높인다.
  * 외부에 거의 의존하지 않고 독자적으로 동작할 수 있는 컴포넌트라면 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크다.
* 큰 시스템을 제작하는 난이도를 낮춰준다.
  * 시스템 전체가 아직 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있다.

### 탑레벨 클래스와 인터페이스에서의 정보 은닉
* 탑레벨 클래스와 인터페이스에 부여할 수 있는 접근 수준은 default와 public 두가지이다.
* 패키지 외부에서 쓸 이유가 없다면 default로 선언해야 한다.
* 그러면 API가 아닌 내부 구현이 되어 언제든 수정 가능하다.
* 클라이언트에 아무런 피해 없이 다음 릴리스에서 수정, 교체, 제거할 수 있다.
* 반면에 public으로 선언하면 API가 되므로 하위호환을 위해 영원히 관리해줘야만 한다.
* 따라서 public일 필요가 없는 클래스의 접근 수준을 default로 좁혀야 한다.
* public 클래스는 그 패키지의 API인 반면 default는 내부 구현에 속하기 때문이다.

### 멤버에서의 정보 은닉
* 클래스의 공개 API를 설계한 후, 그 외의 모든 멤버는 private으로 만들어야 한다.
  * 오직 같은 패키지의 다른 클래스가 접근해야 하는 멤버에 안하여 default로 풀어줘야 한다.
  * 권한을 풀어주는 일을 너무 자주하게 되면 시스템에서 컴포넌트를 더 분해해야 하는 것은 아닌지 고민해봐야 한다.
* private과 default 멤버는 모두 해당 클래스의 구현에 해당하므로 보통은 공개 API에 영향을 주지 않는다.
  * 단 Serializable을 구현한 클래스에서는 그 필드들도 의도치 않게 공개 API가 될 순 있다.
* public 클래스에서는 멤버의 접근 수준을 default에서 protected로 바꾸는 순간 그 멤버에 접근할 수 있는 대상의 범위가 엄청나게 넓어진다.
  * 즉 public 클래스의 protected 멤버는 공개 API가 되므로, 내부 동작 방식을 API문서에 적어 사용자에게 공개해야할 수도 있다.
  * 따라서 protected 멤버의 수는 적을수록 좋다.
* 상의 클래스의 메서드를 재정의할 때에는 접근 수준을 상위클래스에서보다 좁게 설정할 수 없다.
  * 이 제약은 상위클래스는 하위클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙을 지키기 위해 필요하다. (리스코프 치환 원칙)

### 테스트와 정보 은닉
* 코드를 테스트하려는 목적으로 클래스, 인터페이스, 멤버의 접근 범위를 넓히려 할 때가 있다.
* 적당한 수준까지는 넓혀도 된다.
  * 적당한 수준은 public 클래스의 private 멤버를 default로 풀어주는 것 정도이다.
* 테스트만을 위해 클래스, 인터페이스, 멤버를 공개 API로 만들어서는 안되며 이렇게 할 이유도 없다.
* 테스트 코드를 테스트 대상과 같은 패키지에 두면 default 요소에 접근할 수 있기 때문이다.

### public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다
* 필드가 가변 객체를 참조하거나 final이 아닌 인스턴스 필드를 public으로 선언하면 그 필드에 담을 수 있는 값을 제한할 수 없게 된다.
  * 그 필드와 관련된 모든 것은 불변식을 보장할 수 없게 된다는 의미이다.
* 추가로 필드가 수정될 때 다른 작업을 할 수 없게 되므로 public 가변 필드를 갖는 클래스는 일반적으로 스레드에 안전하지 않다.
* 심지어는 필드가 final이면서 불변 객체를 참조하더라도 문제는 여전히 남아있으며, 내부 구현을 바꾸고 싶어도 그 public 필드를 없애는 방식으로는 리팩토링 할 수 없게 된다.
* 이러한 정적 필드에서도 마찬가지이지만 예외가 있다.
  * 해당 클래스가 표현하는 추상 개념을 완성하는데 꼭 필요한 구성요소로써의 상수라면 public static final 필드로 공개해도 좋다.
  * 하지만 이러한 필드는 반드시 기본 타입 값이나 불변 객체를 참조해야 한다.
  * 가변 객체를 참조하면 final이 아닌 필드에 적용되는 모든 불이익이 그대로 적용된다.

### 모듈에 적용되는 접근 수준
* 모듈에 적용되는 접근 수준은 상당히 주의해서 사용해야 한다.
* JAR 파일을 자신의 모듈 경로가 아닌 애플리케이션의 클래스패스에 두면 그 모듈 안의 모든 패키지는 모듈이 없는 것처럼 행동한다.
* 모듈이 공개했는지 여부와 상관없이 public 클래스가 선언한 모든 public, protected 멤버를 모듈 밖에서도 접근할 수 있게 된다.
* 이 접근 수준을 적극 활용한 예가 JDK 자체이다.
* 자바 라이브러리에서 공개하지 않은 패키지들은 해당 모듈 밖에서는 절대로 접근할 수 없다.

### 정리
* 프로그램 요소의 접근성은 가능한 한 최소한으로 해야 된다.
* 꼭 필요한 것만 골라 최소한의 public API를 설계해야 한다.
* 그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개되는 일이 없도록 해야한다.
* public 클래스는 상수용 public static final 필드 외에는 어떤 public 필드도 가져서는 안된다.
* public static final 필드가 참조하는 객체가 불변인지 확인해야 한다.

## item16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
### public 클래스일 경우
* 인스턴스 필드들을 모아놓는 일 외에는 아무 목적이 없는 클래스를 작성하려 할 때가 있다.

```java
class Point {
    public double x;
    public double y;
}
```
* 위와 같이 필드를 public으로 선언하면 데이터 필드에 직접 접근할 수 있기 때문에 캡슐화의 이점을 제공하지 못한다.
* 객체 지향 프로그래밍에서는 이러한 클래스는 상당히 좋지 못하기 때문에 필드를 모두 private으로 변경하고 public 접근자 getter를 추가한다.
* 패키지 바깥에서 접근할 수 있는 public 클래스라면 접근자를 제공함으로써 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 얻을 수 있다.
  * public 클래스가 필드가 필드를 공개하면 이를 사용하는 클라이언트가 생겨나게 되므로 내부 표현방식을 마음대로 바꿀 수 없다.

### default, private 중첩 클래스일 경우
* default, private 중첩 클래스일 경우 데이터 필드를 노출해도 문제가 없다.
* 그 클래스가 표현하려는 추상 개념만 올바르게 표현해주면 된다.
* 이러한 방식은 클래스 선언 면에서나, 이를 사용하년 클라이언트 코드 면에서나 접근자 방식보다 훨씬 깔끔하다.
* 클라이언트 코드가 이 클래스 내부 표현에 묶이기는 하지만, 클라이언트도 어차피 이 클래스를 포함하는 패키지 않에서만 동작하는 코드일 뿐이다.
  * 즉 패키지 바깥 코드는 전혀 손대지 않고 데이터 표현방식을 바꿀 수 있다.
* private 중첩 클래스의 경우 수정 범위가 더 좁아져 이 클래스를 포함하는 외부 클래스까지로 제한된다.

### 해당 규칙을 어긴 예시들을 따라하지 마라
* 자바 플랫폼 라이브러리에도 public 클래스의 필드를 직접 노출하지 말라는 규칙을 어기는 사례가 종종 있다.
* 이러한 클래스들이 있다고 따라해서는 안되며, 이러한 클래스의 심각한 문제는 오늘날까지도 해결되지 못했다.

### 이러한 문제를 피하기 위해 필드를 불변으로 선언하지 마라
* 이러한 문제를 해결하기 위해 필드를 불변 객체로 만드는 건 직접 노출할 때의 단점이 조금은 줄어들긴 하지만 결코 좋은생각이 아니다.
* API를 변경하지 않고는 표현 방식을 바꿀 수도 없고, 핃르를 읽을 때 부수 작업을 수행할 수 없다는 단점응 ㅕ전하다.
* 그래도 불변식은 보장할 수 있게 된다. 

### 정리
* public 클래스는 절대 가변 필드를 직접 노출해서는 안된다.
* 불변필드라면 노출해도 덜 위험하지만 좋은 선택은 아니다.
* default 클래스나 private 중첩 클래스에서는 종종 필드를 노출하는 편이 나을 수도 있다.

## item.17 변경 가능성을 최소화하라
### 불변 클래스란
* 불변 클래스는 그 인스턴스의 내부 값을 수정할 수 없는 클래스이다.
* 불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않는다.
* 자바 플랫폼 라이브러리에도 다양한 불변 클래스들이 있다.
  * String, 기본타읍의 박싱클래스, BigInteger, BigDecimal 등이 여기 속한다.
* 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며 오류가 생길 여지도 적고 훨씬 안전하다.

### 불변 클래스의 규칙
* 객체의 상태를 변경하는 메서드를 제공하지 않는다.
* 클래스를 확장할 수 없도록 한다.
  * 하위 클래스에서 부주의하거나 나쁜 의도로 객체의 상태를 변하게 만드는 사태를 막아준다.
  * 상속을 막는 대표적인 방법은 클래스를 final로 선언하는 것이지만, 다른 방법도 있다.
* 모든 필드를 final로 선언한다.
  * 시스템이 강제하는 수단을 이용해 설계자의 의도를 명확히 드러내는 방법이다.
  * 새로 생성된 인스턴스를 동기화 없이 다른 스레드로 건네도 문제없이 보장하는 데에도 필요하다.
* 모든 필드를 private으로 선언한다.
  * 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을 막아준다.
  * 기술적으로는 기본 타입 필드나 불변 객체를 참조하는 필드를 public final로만 선언해도 불변 객체가 되지만 이렇게 하면 다음 릴리스에서 내부 표현을 바꾸지는 못한다.
* 자신 외에는 내부 가변 컴포넌트에 접근할 수 없도록 한다.
  * 클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야한다.
  * 이런 필드는 절대 클라이언트가 제공한 객체 참조를 가리키게 해서는 안되며 접근자 메서드가 그 필드를 그대로 반환해서도 안된다.
  * 생성자, 접근자, readObject 메서드 모두에서 방어적 복사를 수행해야 한다.

### 불변 객체의 장점
* 불변 객체는 생성된 시점의 상태를 파괴될 때까지 그대로 간직하기 때문에 단순하다.
* 불변 객체는 근본적으로는 스레드에 안전하기 때문에 따로 동기화할 필요가 없다.
  * 즉 불변 객체에 대해서는 어떤 스레드도 다른 스레드에 영향을 줄 수 없기 때문에 안심하고 공유할 수 있다.
  * 또한 아무리 복사해봐야 원본과 똑같으니 복사 자체가 의미가 없기 때문에, 방어적 복사도 필요 없다는 의미가 된다.
* 불변 객체끼리는 내부 데이터를 공유할 수 있다.
  * 예시로 BinInteger 클래스는 내부에서 값의 부호(sign, int 변수)와 크기(magnitude, int 배열)를 따로 표현한다.
  * 크기가 같고 부호만 반대인 새로운 BigInteger를 생성하는데 배열을 비록 가변이지만 복사하지 않고 원본 인스턴스와 공유해도 된다.
  * 새로 만든 BigInteger 인스턴스도 원본 인스턴스가 가리키는 내부 배열을 그대로 가리킨다.
* 불변 객체는 그 자체로 실패 원자성을 제공한다.
  * 상태가 절대 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없다.


### 불변 객체의 단점
* 불변 클래스는 값이 다르면 반드시 독립된 객체로 만들어야 한다.
* 만약 값의 가짓수가 많다면 이 객체들을 모두 만드는데 큰 비용을 치러야 한다.

### 불변클래스를 만드는 또다른 설계 방법
* 클래스가 불변임을 보장하려면 자신을 상속하지 못하게 해야한다.
* 가장 쉬운 방법은 final 클래스로 선언하는 것 이지만 더 유연한 방법이 있다.
* 모든 생성자를 private 혹은 default로 만들고 public 정적 팩토리를 제공하는 방법이다.

```java
public class Complex {
    private final double re;
    private final double im;
    
    private Complex(double re, double im) {
        this.re = re;
        this.im = im;    
    }
    
    public static Complex valueOf(double re, double im) {
        return new Complex(re, im);    
    }
    ...
}
```

* 패키지 바깥 클라이언트에서 바라본 이 불변 객체는 사실상 final이다.
* public이나 protected 생성자가 없기 때문에 다른 패키지에서는 이 클래스를 확장하는게 불가능하다.
* 또한 다음 릴리스에서 객체 캐싱 기능을 추가해 성능을 끌어올릴 수도 있다.

### 직렬화 시 주의점
* Serializable을 구현하는 불변 클래스의 내부에 가변 객체를 참조하는 필드가 있으면 readObject나 readResolve 메서드를 반드시 제공하거나 ObjectOutputStream.writeUnshared와 OjbectInputStream.readUnshared 메서드를 사용해야 한다.
* 플랫폼이 제공하는 기본 직렬화 방법이면 충분하더라도, 위 내용을 지켜야 한다.
* 그렇지 않으면 공격자가 이 클래스로부터 가변 인스턴스를 만들어낼 수 있다.

### 정리
* getter가 있다고 무조건 setter를 만들지는 않아야 한다.
* 클래스는 꼭 필요한 경우가 아니라면 불변이여야 하며, 불변 클래스는 장점이 많고 단점은 특정 상황에서의 잠재적 성능 저하뿐이다.
  * 성능상 어쩔 수 없다면 불변 클래스와 쌍을 이루는 가변 동반 클래스를 public 클래스로 제공하면 된다.
* 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄여야 한다.
  * 객체가 가질 수 있는 상태의 수를 줄이면 그 객체를 예측하기 쉬워지고 오류가 생길 가능성이 줄어든다.
  * 꼭 변경해야 할 필드를 뺀 나머지는 final로 선언하는게 좋다.
  * 다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.
* 생성자는 불변식 설정이 모두 완료된 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.
  * 확실한 이유가 없다면 생성자와 정적 팩토리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안된다.
  * 객체를 재활용할 목적으로 상태를 다시 초기화하는 메서드도 안되며, 복잡성만 커지고 성능 이점은 거의없다.

## item18. 상속보다는 컴포지션을 사용하라
### 클래스간 상속 시 주의 사항
* 상속은 코드를 재사용하는 강력한 수단이지만 항상 최선은 아니다.
* 잘못 사용하면 오류를 내기 쉬운 소프트웨어를 만들게 된다.
* 상위 클래스와 하위 클래스를 모두 같은 프로그래머가 통제하는 패키지 안에서라면 상속도 안전한 방법이며, 또한 확장할 목적으로 설계되었고 문서화도 잘 된 클래스도 마찬가지로 안전하다.
* 일반적으로 다른 패키지의 구체 클래스를 상속하는 일은 위험하다.

#### 상속의 단점
* 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.
* 상위 클래스는 릴리즈마다 내부 구현이 달라질 수 있으며, 그 여파로 하위 클래스가 오동작 할 수 있다.
* 이러한 이유로 상위 클래스 설계자가 확장을 충분히 고려하고 문서화도 제대로 해두지 않는다면 하위 클래스는 상위 클래스의 변화에 맞춰 수정돼야만 한다.
* 즉, 캡슐화가 깨지게 된다는 의미이다.
* 또한 다음 릴리스에서 상위 클래스에 새로운 메서드를 추가하게 되면, 하위 클래스에서 재정의하지 못한 새 메서드를 사용해 허용되지 않은 원소를 추가할 수 있게 된다.
  * 예시로, Hashtable과 Vector를 컬렉션 프레임워크에 포함시키자 이와 관련한 보안 문제점을 수정해야하는 사태가 벌어졌다.

### 컴포지션과 전달 메서드를 사용하라
* 위 문제들을 모두 피할 수 있는 방법이 있다.
* 기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하면 된다.
  * 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 이러한 설계를 컴포지션이라고 한다.
* 새 클래스의 인스턴스 메서드들은 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환한다.
  * 이 방식을 전달 메서드라 부른다.
* 결과적으로 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나며, 심지어 기존 클래스에 새로운 메서드가 추가되더라도 전혀 영향을 받지 않는다.
* 컴포지션과 전달의 조합은 넓은 의미로 delegation(위임) 이라고 부른다.
* 엄밀히 따지면 래퍼 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우만 위임에 해당한다.
* 래퍼 클래스는 래퍼 클래스가 콜백 프레임워크와는 어울리지 않는다는 점을 제외하곤 단점이 거의 없다. 

### 정리
* 상속은 강력하지만 캡슐화를 해친다는 문제가 있다.
* 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 써야 한다.
* is-a 관계일 때도 안심할 수만은 없는데, 하위클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려해 설계되지 않았다면 여전히 문제가 될 수 있다.
* 상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용해야 한다.
* 특히 래퍼클래스로 구현할 적당한 인터페이스가 있다면 더더욱 그렇고, 래퍼 클래스는 하위 클래스보다 건고하며 강력하다.

## item19. 상속을 고려해 설계하고 문서화하라. 그렇지 않았다면 상속을 금지하라
### 상속을 고려한 설계와 문서화
* 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.
* 클래스의 API로 공개된 메서드에서 클래스 자신의 또 다른 메서드를 호출할 수도 있다.
* 그 호출되는 메서드가 재정의 가능 메서드라면 그 사실을 호출하는 메서드의 API 설명에 적시해야 한다.
* 추가적으로 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 명시해야 한다.
* 즉, 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.

#### Implementation Requirements
* API 문서의 메서드 설명 끝에서 Implementation Requirements로 시작하는 절을 볼 수 있는데, 그 메서드의 내부 동작 방식을 설명하는 곳이다.
* 이 절은 메서드 주석에 @implSpec 태그를 붙어주면 자바독 도구가 생성해준다.
* 여기에는 재정의 했을 때 발생할 수 있는 내용을 담는 경우가 많다.
* 여기서 좋은 API 문서는 어떻게 하는지가 아니라 무엇을 하는지를 적어야 한다.
* 상속이 캡슐화를 해치기 때문에 안전하게 상속할 수 있게 하기 위한 선택이다.

### hook을 만들어라
* 내부 매커니즘을 문서로 남기는 것만이 상속을 위한 설계의 전부는 아니다.
* 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면, 클래스의 내부 동작 과정 중간에 끼어들 수 있는 hook을 잘 선별하여 protected 메서드 형태로 공개할 수도 있다.
* 상속용 클래스를 설계할 때 어떤 메서드를 protected로 노출해야 할지를 결정하는 것은 쉽지 않다.
* 잘 예측해서 만들어 본 다음, 배포전에 반드시 하위클래스를 만들어 테스트를 해봐야 한다.

### 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.
* 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로, 하위 클래스에서 재정의해버린 메서드가 하위 클래스 생성자보다 먼저 호출된다.
* 이 때 하위 클래스 생성자에서 초기화 하는 값에 의존한다면 의도대로 동작하지 않게 된다.
* private, fianl, static 메서드는 재정의가 불가능 하므로 생성자에서 안심하고 호출해도 된다.

#### Cloneable과 Serializable 인터페이스는 상속용 설계를 어렵게 한다.
* 둘 중 하나라도 구현한 클래스를 상속할 수 있게 설계하는 것은 일반적으로는 좋지 않은 생각이다.
* clone과 readObject 메서드도 생성자와 비슷한 효과를 낸다.
* 그렇기 때문에 상속용 클래스에서 Cloneable이나 Serializable을 구현할 지 정해야 한다면 이를 구현할 때 따르는 제약도 생성자와 비슷하다는 점을 주의해야 한다.
  * clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.

### 정리
* 상속용 클래스를 설계하는 것은 결코 만만하지 않다.
* 클래스 내부에서 스스로를 어떻게 사용하는지 모두 문서로 남겨야 하며, 일단 문서화하는 것은 그 클래스가 쓰이는 한 반드시 지켜야 한다.
  * 그렇지 않는다면 그 내부 구현 방식을 믿고 활용하던 하위 클래스를 오동작하게 만들 수 있다.
* 다른 사람이 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있다.
* 이런 생각은 결코 쉽지 않으며, 따라서 클래스를 확장해야 할 명확한 이유가 떠오르지 않는다면 상속을 금지하는 편이 나을 수 있다.
* 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 된다.

## item20. 추상 클래스보다는 인터페이스를 우선하라
### 추상클래스와 인터페이스
* 자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스 두가지 이다.
* 자바 8부터는 인터페이스도 default 메서드를 제공할 수 있게 되어 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있다.

### 인터페이스의 장점
* 인터페이스는 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속했든 같은 타입으로 취급된다.
  * 추상 클래스가 정의한 타입을 구현하는 클래스는 추상 클래스의 하위 클래스가 되어야 한다는 점인데, 자바는 단일 상속만 지원하기 때문에 추상 클래스 방식은 새로운 타입을 정하는 데 커다란 제약은 안게 된다.
* 인터페이스는 기존 클래스에도 쉽게 새로운 인터페이스를 구현해 넣을 수 있다.
  * 인터페이스가 요구하는 메서드를 추가하고, 클래스 선언에 implements 구문만 추가하면 된다.
  * Comparable, Iterable, AutoCloseable 인터페이스가 새로 추가 됐을 때 표준 라이브러리의 많은 기존 클래스가 이 인터페이스들을 구현한 채 릴리스 되었다.
  * 반면 기존 클래스 위에 새로운 추상클래스를 끼워넣기는 어렵다.
* 인터페이스는 mixin 정의에 안성맞춤이다.
  * 믹스인이란 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래의 주된 타입 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다.
  * Comparable은 자신을 구현한 클래스의 인스턴스들끼리는 순서를 정할 수 있다고 선언하는 믹스인 인터페이스이다.
  * 추상 클래스로는 믹스인을 정의할 수 없는데, 기존 클래스에 덧씌울 수 없기 때문이다.
* 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다.
  * 타입을 계층적으로 정의하면 수많은 개념을 구조적으로 잘 표현할 수 있지만, 현실에는 계층을 엄격히 구분하기 어려운 경우도 있다.
  * 만약 클래스로 만들러면 가능한 조합들을 모드 각각의 클래스로 만들어야 하지만, 인터페이스를 사용하면 이러한 상황에 더 잘 어울린다.

### default 메서드
* 인터페이스의 메서드 중 구현 방법이 명백한 것이 있다면, 그 구현을 디폴트 메서드로 제공하면 된다.
* default 메서드를 제공할 때는 상속하려는 사람을 위한 설명을 @implSepc 자바독 태그를 붙여 문서화해야 한다.

#### default 메서드의 한계
* 하지만 default 메서드에도 제약은 있다.
* eqauls와 hashCode같은 Object의 메서드를 정의하고 있지만, 이들은 default 메서드로 제공해서는 안된다.
* 또한 인터페이스는 인스턴스 필드를 가질 수 없고 public이 아닌 정적 멤버도 가질 수 없다.
* 또한 직접 만든 인터페이스가 아니라면 디폴트 메서드를 추가할 수는 없다.

### 추상 골격 구현 클래스
* 인터페이스의 default 메서드의 단점을 극복하기 위해 인터페이스와 추상 골격 클래스를 함께 제공하는 방법이 있다.
* 이러한 방법으로 인터페이스와 추상 클래스의 장점을 모두 취할 수 있다.
* 인터페이스로는 타입을 정의하고, 골격 구현 클래스로 나머지 메서드들을 구현한다.
* 이렇게 하면 골격 구현 클래스를 확장하는 것 만으로 인터페이스를 구현하는 데 필요한 일이 대부분 완료된다.
* 이를 템플릿 메서드 패턴이라고 부른다.
* 관례상 인터페이스 이름이 Interface라면 그 골격 구현 클래스의 이름은 AbstractInterface로 짓는다.
* 구조상 추상 공력 구현 클래스를 활용 못하는 경우에도 인터페이스를 사용하면 그만이므로, 기존 추상클래스가 가지고 있던 제약에서도 벗어난다.

#### 추상 골격 구현 클래스 구현 방법
* 인터페이스를 살펴 다른 메서드들의 구현에 사용되는 기반 메서드를 선정한다.
* 골격 구현에서 기반 메서드가 추상 메서드가 된다.
* 기반 메서드들을 사용해 직접 구현할 수 있는 메서드는 모두 default 메서드로 제공한다.
  * eqauls, hashcode와 같은 Object의 메서드는 default 메서드로 제공하면 안된다.
* 만약 인터페이스의 메서드 모두가 기반 메서드나 default 메서드가 된다면, 굳이 골격 구현 클래스를 만들 필요가 없다.
  * 기반 메서드나 default 메서드로 만들지 못한 메서드가 남아있다면, 이 인터페이스를 구현하는 골격 구현 클래스를 만들어 남은 메서드를 작성해 넣는다.

### 정리
* 일반적으로 다중 구현용 타입으로는 인터페이스가 가장 적합하다.
* 복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함께 제공하는 방법을 고려해봐야 한다.
* 골격 구현은 가능한 한 인터페이스의 default메서드로 제공하여 그 인터페이스를 구현한 모든 곳에서 활용하도록 하는것이 좋다.
  * 가능한 한인 이유는 인터페이스의 걸려있는 구현상의 제약 때문에 골격 구현을 추상클래스로 제공하는 경우가 더 흔하기 때문이다.
* 인터페이스에 정의한 default 메서드던지, 별도의 추상클래스던지 골격 구현은 반드시 그 동작 방식을 잘 정리해 문서로 남겨야 한다.

## item21. 인터페이스는 구현하는 쪽을 생각해 설계하라
### default 메서드 사용 시 주의사항
* default 메서드를 선언하면, 그 인터페이스를 구현한 후 default 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 쓰이게 된다.
* 이처럼 자바에도 기존 인터페이스에 메서드를 추가하는 길이 열렸지만, 모든 기존 구현체들과 매끄럽게 연동된다는 보장은 없다.
* 자바 7까지의 모든 클래스가 인터페이스에 새로운 메서드가 추가될 일은 없을거라 생강하고 작성되었기 때문이다.
* default 메서드는 구현 클래스에 대해 아무것도 모른 채 합의 없이 무작정 삽입될 뿐이다.

### 기존 인터페이스에 모든 상황에서 불변식을 해치지 않는 default 메서드를 작성하긴 어렵다.
* 자바 8에서 핵심 컬렉션 인터페이스들에 다수의 default 메서드가 추가되었다.
  * 주로 람다를 활용하기 위해서이다.
* 자바 라이브러리의 default 메서드는 코드 품질이 높으며 범용적이라 대부분의 상황에서는 잘 작동하지만, 모든 상황에서 잘 동작하는 건 아니다.
* 이러한 문제를 예방하기 위해 일련의 조치를 취했는데, 예를 들면 구현한 인터페이스의 default 메서드를 재정의하고, 다른 메서드에서는 default 메서드를 호출하기 전에 필요한 작업을 수행하도록 했다.
* 즉, 기존 인터페이스에 default 메서드로 새 메서드로 추가하는 일은 생각보다 간단한 일이 아닐 수 있다,
* default 메서드는 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으킬 수 있으며, 기존 인터페이스에 default 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야 한다.
* 물론 default 메서드는 새로운 인터페이스를 만드는 경우라면 표준적인 메서드 구현을 제공하는데 아주 유용한 수단이다.

### 새로운 인터페이스를 만든다면 테스트를 진행해야 한다.
* 새로운 인터페이스라면 릴리스 전에 반드시 테스트를 거쳐야 한다.
* 수 많은 개발자가 그 인터페이스를 나름의 방식으로 구현할 것이며, 각 인터페이스의 인스턴스를 다양한 작업에 활용하는 클라이언트도 여러 개 만들어봐야 한다.
* 이런 작업들을 거치면 인터페이스를 릴리스하기 전에 바로잡을 기회가 남아있을 때 결함을 찾아낼 수 있다.
* 인터페이스를 릴리스한 후라도 결함을 수정하는게 가능한 경우도 있겠지만, 그 가능성에 기대서는 절대 안된다.

## item22. 인터페이스는 타입을 정의하는 용도로만 사용하라
### 인터페이스의 사용 용도
* 인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다.
* 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 잇는지를 클라이언트에 얘기해주는 것이다.
* 인터페이스는 오직 이 용도로만 사용해야 한다.

### 인터페이스를 잘못 사용한 예시인 상수 인터페이스
* 인터페이스를 잘못 사용한 대표적인 예시로, 상수 인터페이스라는 것이 있다.
* 상수 인터페이스란 메서드 없이 상수를 뜻하는 static final 필드로만 가득 찬 인터페이스를 말한다.
* 이 상수들을 사용하려는 클래스에서는 정규화된 이름을 쓰는걸 피하고자 그 인터페이스를 구현하곤 한다.
* 클래스 내부에서 사용하는 상수는 외부 인터페이스가 아니라 내부 구현에 해당한다.
* 따라서 상수 인터페이스를 구현하는 것은 내부 구현을 클래스의 API로 노출하는 행위이다.
* 클래스가 어떤 상수 인터페이스를 상ㅇ하든 사용자에게 아무런 의미가 없다.
  * 오히려 혼란을 주기도 하며, 더 심하게는 클라이언트 코드가 내부 구현에 해당하는 이 상수들에 종속되게 된다.

### 상수인터페이스의 올바른 방향
* 특정 클래스나 인터페이스와 강하게 연관된 상수라면, 그 클래스나 인터페이스 자체에 추가해야 한다.
* 열거 타입으로 나타내기 적합한 상수라면 열거 타입으로 만들어 공개하면 된다.
* 그것도 아니라면 인스턴스화 할 수 없는 유틸리티 클래스에 담아 공개해야 한다.
  * 유틸리티 클래스에 정의된 상수를 클라이언트에서 사용할려면 클래스 이름까지 함께 명시해야 한다.
  * 또한 유틸리티 클래스의 상수를 빈번히 사용해야 한다면 static import를 하여 클래스 이름은 생략할 수 있다.

### 정리
* 인터페이스는 타입을 정의하는 용도로만 사용해야 한다.
* 상수 공개용 수단으로 사용해선 안된다.

## item23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라
### 태그 달린 클래스란
* 두가지 이상의 의미를 표현할 수 있으며, 그 중 현재 표현하는 의미를 태그 값으로 알려주는 클래스가 있다.

```java
Class Figure {
    enum Shape { RECTANGLE, CIRCLE };
    
    final Shape shape;
    
    // 사각형 필드
    double length;
    double width;
    
    // 원 필드
    double radius;
    
    // 원 생성자
    Figure(double radius) {
        shape = Shape.CIRCLE;
        this.radius = radius;    
    }
    
    // 사각형 생성자
    Figure(double length, double width) {
        shape = Shape.RECTANGLE;
        this.length = length;
        this.width = width;    
    }
    
    double area() {
        switch(shape) {
            case RECTANGLE:
                return length * width;
            case CIRCLE:
                return Math.PI * (radius * radius);
            default:
                throw new AssertionError(shape);
        }
    }
} 
```

#### 태그 달린 클래스의 문제점
* 열거 타입 선언, 태그 필드, switch문 등 쓸데없는 코드가 많다.
* 또한 여러 구현이 혼합돼 있어서 가독성도 나쁘다.
* 다른 의미를 위한 코드도 언제나 함께 하니 메모리도 많이 사용한다.
* 필드들을 final로 선언하려면 해당 의미에 쓰이지 않는 필드들까지 생성자에서 초기화해야 한다.
* 생성자가 태그 필드를 설정하고 해당 의미에 쓰이는 데이터 필드들을 초기화하는 데 컴파일러의 도움을 거의 받을 수 없다.
* 또 다른 의미를 추가하려면 코드를 수정해야 한다.
  * 새로운 의미를 추가할 때마다 모든 switch문을 찾아 새 의미를 처리하는 코드를 추가해야 한다.
* 인스턴스의 타입만으로는 현재 나타내는 의미를 알 길이 전혀 없다.

### 태그 달린 클래스 대신 클래스 계층 구조를 사용하라
* 태그 달린 클래스는 클래스 계층 구조를 어설프게 흉내낸 단점만 많은 방법이다. 
* 따라서 태그 달린 클래스 대신 클래스 계층 구조를 사용해야 한다.

```java
abstract class Figure {
    abstract double area();
}

class Circle extends Figure {
    final double radius;
    
    Circle(double radius) { this.radius = radius; }
    
    @Override double area() { return Math.PI * (radius * radius); }
}

class Rectangle extends Figure {
    final double length;
    final double width;
    
    Rectangle(double length, double width) {
        this.length = length;
        this.width = width;    
    }
    
    @Override double area() { return length * width; }
}
```
#### 클래스 계층구조의 장점
* 간결하며 쓸데없는 코드도 사라진다.
* 각 의미를 독립된 클래스에 담아 관련없던 데이터 필드를 모두 제거한다.
* 남은 필드들은 모두 final이며, 각 클래스의 생성자가 모든 필드를 남김없이 초기화하고 추상 메서드를 구현했는지 컴파일러가 확인해준다.
* 루트 클래스의 코드를 건드리지 않고도 독립적으로 계층구조를 확장하고 함께 사용할 수 있다.
* 타입이 의미별로 따로 존재하기 때문에 변수의 의미를 명시하거나 제한할 수 있으며, 또 특정 의미만 매개변수로 받을수도 있다.
* 타입 사이의 계층관계를 반영할 수 있어 컴파일타임 타입 검사 능력이 높아진다.

### 정리
* 태그 달린 클래스를 써야하는 상황은 거의 없고, 새로운 클래스를 작성하는데 태그 필드가 등장한다면 태그를 없애고 계층구조로 작성해야 한다.
* 기존 클래스가 태그 필드를 사용하고 있다면 계층 구조로 리팩토링하는 것을 고민해봐야 한다.

## item24. 멤버 클래스는 되도록 static으로 만들라
### 중첩 클래스란
* 중첩 클래스란 다른 클래스 안에 정의된 클래스를 의미한다.
* 중첩 클래스는 자신을 감싼 바깥 클래스에서만 써여야 하며, 그 외의 쓰임이 있다면 탑레벨 클래스로 만들어야 한다.
* 중첩 클래스에는 정적 멤버 클래스, 비정적 멤버 클래스, 익명 클래스, 지역 클래스 네가지가 있다.
* 정적 멤버 클래스를 제외하고는 내부 클래스에 해당한다.

### 정적 멤버 클래스
* 다른 클래스 안에 선언되고 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하면 일반 클래스와 똑같다.
* 다른 정적 멤버와 똑같은 접근 규칙을 적용받으며, private으로 선언하면 바깥 클래스에서만 접근할 수 있다.
* 정적 멤버 클래스는 흔히는 바깥 클래스와 함께 쓰일 때만 유용한 public 도우미 클래스로 쓰인다.

#### private 정적 멤버 클래스
* private 정적 멤버 클래스는 보통 바깥 클래스가 표현하는 객체의 한 부분을 나타낼 때 사용한다.
* 예시로 Map 구현체는 각각의 키-값 쌍을 표현하는 엔트리 객체들을 가지고 있다.
* 모든 엔트리는 맵과 연관되어 있지만, 엔트리의 메서드들은 맵을 직접 사용하지 않는다.
* 그러므로 엔트리를 비정적 멤버 클래스로 사용하는 것은 낭비이며, private 정적 멤버 클래스가 가장 알맞다.

### 비정적 멤버 클래스
* 비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결된다.
* 비정적 멤버 클래스의 인스턴스 메서드에서 정규화된 this를 사용해, 바깥 인스턴스의 메서드를 호출하거나 바깥 인스턴스의 참조를 가져올 수 있다.
* 중첩 클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있다면 정적 멤버 클래스로 만들어야 한다.
  * 비정적 멤버 클래스는 바깥 인스턴스 없이는 생성할 수 없다.
* 비정적 멤버 클래스는 어떤 클래스의 인스턴스를 감싸 마치 다른 클래스처럼 보이게 하는 뷰로 사용할 때 주로 사용한다.

#### 되도록이면 정적 멤버 클래스를 이용하라
* 멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여 정적 멤버 클래스로 만들어야 한다.
* static을 생략하면 바깥 인스턴스로의 숨은 외부 참조를 갖게 되는데, 이 참조를 저장하려면 시간과 공간이 소비된다.
* 또한 가비지 컬렉션이 바깥 클래스의 인스턴스를 수거하지 못하는 메모리 누수가 생길 수도 있다.

### 익명 클래스
* 익명 클래스는 사용하는데 제약이 많은 편이다.
* 선언한 지점에서만 인스턴스를 만들 수 있으며, instanceof나 클래스 이름이 필요한 작업은 수행할 수 없다.
* 또한 여러 인터페이스를 구현할 수도 없으며, 인터페이스를 구현하는 동시에 다른 클래스를 상속할 수도 없다.
* 익명 클래스는 표현식 중간에 등장하므로 짧지 않으면 가독성도 떨어진다.
* 자바가 람다를 지원하기 전에는 작은 함수 객체나 처리 객체를 만드는데 주로 사용했지만, 이제는 람다를 사용한다.
* 그렇지만 현재도 정적 팩토리 메서드를 구현할 때에는 사용한다.

### 지역 클래스
* 지역 클래스는 지역변수를 선언할 수 있는 곳이면 실직적으로 어디서든 선언할 수 있으며, 유효 범위도 지역변수와 같다.
* 멤버 클래스처럼 이름이 있기 때문에 반복해서 사용할 수 있꼬, 익명 클래스처럼 비정적 문맥에서 사용될 때만 바깥 인스턴스를 참조할 수 있다.
* 정적 멤버는 가질 수 없으며 가독성을 위해 짧게 작성해야 한다.

### 정리
* 중첩 클래스는 네가지가 있으며, 각각의 쓰임이 모두 다르다.
* 메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기엔 너무 길면 멤버 클래스로 만든다.
* 멤버 클래스의 인스턴스 각각이 바깥 인스턴스를 참조한다면 비정적으로, 그렇지 않으면 정적으로 만들어야 한다.
* 중첩 클래스가 한 메서드 안에서만 쓰이면서 그 인스턴스를 생성하는 지점이 단 한곳이며 해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 이미 있으면 익명 클래스로 만들고, 그렇지 않으면 지역 클래스로 만들어야 한다.

## item25. 탑레벨 클래스는 한 파일에 하나만 담으라
### 한 파일에 탑레벨 클래스를 여러개를 담으면 안되는 이유
* 소스 파일 하나에 탑레벨 클래스를 여러 개 선언하더라도 자바 컴파일러는 문제를 발견하지 못한다.
* 하지만 아무런 장점이 없을 뿐만 아니라, 심각한 위험을 감수해야 하는 행위이다.
* 한 클래스를 여러가지로 정의할 수 있으며, 그 중 어느것을 사용할지는 어느 소스파일을 먼저 컴파일하냐에 따라 달라지기 때문이다.

### 간단한 해결책
* 탑레벨 클래스들을 서로 다른 소스 파일로 분리하면 된다.
* 만약 여러 톱레벨 클래스를 한 파일에 담고 싶으면, 정적 멤버 클래스를 사용하는 방법을 고민해볼 수 있다.
* 다른 클래스에 딸린 부가적인 클래스라면 정적 멤버 클래스로 만드는 쪽에 일반적으로는 더 낫다.
* 읽기도 좋으며 private으로 선언하면 접근 범위도 최소로 관리할 수 있다.

### 정리
* 소스파일 하나에는 반드시 탑레벨 클래스를 하나만 담아야 한다.
* 그러면 컴파일러가 한 클래스에 대한 정의를 여러개 만들어낼 일은 없어진다.
* 소스 파일을 어떤 순서로 컴파일하든 바이너리 파일이나 프로그램의 동작이 달라지는 결코 일어나지 않을 것이다.
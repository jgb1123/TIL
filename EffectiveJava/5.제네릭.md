# 제네릭
## item26. 로 타입은 사용하지 말라
### 로타입?
* 로 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다.
  * `List<E>`의 로 타입은 `List`이다.
* 로 타입은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것 처럼 동작한다.
* 제네릭이 생겨나기 전 코드와 호환되도록 하기 위한 방법이었다.

### 로타입을 사용하지 말라
* 로 타입을 쓰면 제네릭이 안겨주는 안정성과 표현력을 모두 잃게 된다.
* 로 타입을 만든 이유는 제네릭이 생겨나기 전 코드와의 호환성을 위해서 만든 것일 뿐이다.
  * 즉 마이그레이션 호환성을 위해 지원한 것이다.
* `List`같은 로 타입은 사용해서는 안되지만 `List<Object>`처럼 임의 객체를 허용하는 매개변수화 타입은 괜찮다.
  * `List`는 제네릭을 완전 배제한 것이고, `List<Object>`는 모든 타입을 허용한다는 의미를 컴파일러에게 명확히 전달한 것이다. 

### 로타입이 필요한 경우라면?
* 제네릭 타입을 쓰고 싶지만, 실제 타입 매개 변수가 무엇인지 신경쓰고 싶지 않다면 와일드 카드 타입인 `?`를 사용하면 된다.
* 예시로, `Set<?>`은 어떠한 타입이라도 담을 수 있는 범용적인 매개변수화 Set타입이 되는 것이다.
* 와일드카드와 로타입을 똑같다고 생각할 수 있지만 명확한 차이가 있다.
* 로타입 컬렉션에는 아무 원소나 넣을 수 있기 때문에, 타입 불변식을 훼손하기 쉽다.
* 반면 `Collection<?>`와 같은 와일드카드의 경우 null외에는 어떤 원소도 넣을 수 없다.
* 다른 원소를 넣으려 하면 컴파일할 때 오류 메시지가 생긴다.

### 정말 로타입을 사용해야 하는 경우
* class 리터럴에는 로타입을 써야한다.
  * 자바 명세에는 class 리터럴에 매개변수화 타입을 사용하지 못하게 했다.
  * `List.class`, `String[].class`, `int.class`는 허용하고 `List<String>.class`와 `List<?>.class`는 허용하지 않는다.
* instanceof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다.
  * 로타입이든 비한정적 와일드카드 타입이든 instanceof는 완전히 똑같이 동작한다.
  * 비한정적 와일드카드의 타입의 괄호와 물음표는 역할없이 코드만 추가되게 되므로 차라리 로타입을 쓰는게 깔끔하다.

### 정리
* 로타입을 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안된다.
* 로타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다.
* 로타입은 안전하지 않기 때문에, 웬만하면 사용하지 않는게 좋다.

## item27. 비검사 경고를 제거하라
### 최대한 비검사 경고를 제거해야 한다.
* 제네릭을 사용하기 시작하면 수많은 컴파일러의 경고를 보게된다.
* 비검사 형변환 경고, 비검사 메서드 호출 경고, 비검사 매개변수화 가변인수 타입 경고, 비검사 변환 경고 등이 있다.
* 제네릭에 익숙해질수록 마주치는 경고 수는 줄어들지만, 한번에 깔끔하게 컴파일되는 것을 기대하지는 않아야 한다.
* 가능한 한 모든 비검사 경고를 제거해야 한다.

### @SuppressWarnings("unchecked")
* 만약 경고를 제거할 수는 없지만 타입이 안전하다고 확신할 수 있다면 `@SuppressWarnings("unchecked")` 애너테이션을 달아 경고를 숨기면 된다.
* 안전하다고 검증된 비검사 경고를 숨기지 않고 그대로 두면 진짜 문제를 알리는 경고가 나와도 눈치채지 못할 수 있다.
* 하지만 타입이 안전하다는 것을 검증하지 않은 채 경고를 숨겨버리면, 경고없이 컴파일 될 순 있겠지만 런타임예외가 발생할 수 있다.
* 해당 애너테이션은 항상 가능한 한 좁은 범위에 적용해야 한다. (변수 선언, 짧은 메서드, 생성자 등)
* 해당 애너테이션을 사용할 때에는 그 경고를 무시해도 안전한 이유를 주석으로 남겨놓는 게 좋다.

### 정리
* 비검사 경고는 중요하니 무시하면 안된다.
* 모든 비검사 경고는 런타임예외를 일으킬 수 있으니, 최대한 제거해야 한다.
* 경고를 없앨 방법을 찾지 못한다면, 그 코드가 안전함을 증명하고 가능한 한 범위를 좁혀 애너테이션으로 경고를 숨기면 된다.
* 그리고 나서 경고를 숨기기로 한 근거를 주석으로 남겨놔야 한다.
# Nested Loops 조인
* NL 조인은 중첩 루프문의 수행 구조를 사용한다.

## 힌트를 이용해 NL 조인을 제어하는 방법
* `ues_nl` 힌트를 사용하여 NL조인을 유도할 수 있다.
  ```oracle
  select /*+ ordered use_nl(B) use_nl(C) use_nl(D) */ *
  from A, B, C, D
  where B.a = A.a
    and C.b = B.b
    and D.c = C.c
  ```
* 아래와 같이 `leading`힌트로 조인 순서를 제어할 수도 있다.
  ```oracle
  select /*+ leading(C, A, D, B) use_nl(A) use_nl(D) use_nl(B) */ *
  from A, B, C, D
  where B.a = A.a
    and C.b = B.b
    and D.c = C.c
  ```
  * 9i까지는 `leading`힌트에 driving table 인자 하나만 입력할 수 있었지만, 10g부터는 여러 테이블을 기술할 수 있도록 개선되었다.
  * 따라서 최근엔 `ordered` 힌트보다 `leading`힌트를 많이 사용한다.
* 아래와 같이 `ordered`나 `leading`힌트를 기술하지 않으면, NL조인을 사용하되 조인 순서는 옵티마이저가 정하게 된다.
  ```oracle
  select /*+ use_nl(A, B, C, D) */ *
  from A, B, C, D
  where B.a = A.a
    and C.b = B.b
    and D.c = C.c
  ```
  
## NL 조인 수행 과정 분석
```oracle
select /*+ ordered use_nl(e) */
       e.empno, e.ename, d.dname, e.job, e.sal
from dept d, emp e
where e.deptno = d.deptno -- 1
  and d.loc = 'SEOUL'     -- 2  
  and d.gb = '2'          -- 3
  and e.sal >= 1500       -- 4
order by sal desc
```

```
pk_dept         : dept.deptno
dept_loc_idx    : dept.loc
pk_emp          : emp.empno
emp_deptno_idx  : emp.deptno
emp_sal_idx     : emp.sal
```  

```
Execution Plan
------------------------------------------------
0     SELECT STATEMENT
1  0    SORT ORDER BY
2  1      NESTED LOOPS
3  2        TABLE ACCESS BY INDEX ROWID DEPT
4  3          INDEX RANGE SCAN DEPT_LOC_IDX
5  2        TABLE ACCESS BY INDEX ROWID EMP
6  5          INDEX RANGE SCAN EMP_DEPTNO_IDX
```
* 위 예시에서 사용되는 인덱스는 `detp_loc_idx`와 `emp_deptno_idx`이며, 조건 비교 순서는 2 -> 3 -> 1 -> 4 순이다.
* 동작 순서는 아래와 같다.
  * `dept_loc_idx` 인덱스로 `dept.loc = 'SEOUL` 조건을 만족하는 레코드를 찾기 위해 범위스캔한다.
  * `dept_loc_idx` 인덱스에서 읽은 rowid를 가지고 `dept` 테이블 액세스 후 `detp.gb = '2'`필터 조건을 만족하는 레코드를 찾는다.
  * `dept` 테이블에서 읽은 `deptno` 값을 가지고 조건을 만족하는 `emp`쪽 레코드를 찾으려고 `emp_deptno_idx` 인덱스를 범위 스캔한다.
  * `dept_loc_idx` 인덱스에서 읽은 rowid를 가지고 `emp`테이블을 액세스해 `sal >= 1500` 필터조건을 만족하는 레코드를 찾는다.
  * `sal` 기준 내림차순 내림차순 정렬 후 결과를 리턴한다.
* 위 예시에서 부하 지점은 아래와 같다.
  * 단일컬럼 인덱스를 `=` 조건으로 스캔했기 때문에, 그만큼 Random 액세스가 발생한다.
    * 만약 많은양의 Random 액세스가 발생하고, `gb = '2'`조건에 의해 필터링되는 비율이 높다면 해당 인덱스에 `gb`컬럼을 추가하는 방안을 고려해야 한다.
  * `emp_deptno_idx` 인덱스 탐색 시, Outer 테이블인 `dept`를 읽고 나서 필터된 결과만큼 조인 액세스가 발생한다.
    * 만약 `emp_deptno_idx`의 높이가 3이면 매 건마다 그만큼의 블록 I/O가 발생(버퍼 Pinning 효과 고려 X)하고 리프블록을 스캔하면서 추가적인 I/O가 발생한다.
  * `emp_deptno_idx` 읽고 `emp` 테이블 액세스 시, Random I/O가 많이 일어난다.
    * `sal >= 1500` 조건에 의해 필터링되는 비율이 높다면, `emp_deptno_idx` 인덱스에 `sal`컬럼을 추가하는 방안을 고려해야 한다.
* OLTP 시스템에서 조인을 튜팅할 때에는, 일반적으로 NL 조인부터 고려해야 한다.
  * 각 단계의 수행 일량을 확인 후, 과도한 Random 액세스가 발생하는 지점을 파악해야 한다.
  * 여러 가지 방안을 검토 후 NL 조인이 효과적이지 못하다면, 해시조인이나 소트머지 조인을 검토해야 한다.

## NL 조인의 특징
* Random 액세스 위주의 조인 방식이기 때문에, 인덱스 구성이 아무리 완벽하더라도 대량의 데이터를 조인할 때에는 매우 비효율적이다.
* 조인을 한 레코드 씩 순차적으로 진행한다.
  * 아무리 대용량 집합이더라도 부분범위 처리가 가능하기 때문에 좋은 응답 속도를 낼 수 있다.
* 다른 조인 방식과 비교했을 때 인덱스 구성 전략이 특히 중요하다.
* 즉, NL 조인은 소량의 데이터를 주로 처리하거나, 부분범위처리가 가능한 온라인 트랜잭션 환경에 적합한 조인 방식이다.

## NL 조인 튜닝 실습
* Outer쪽 인덱스를 수정 해 Random 액세스를 줄이거나, 조인후의 레코드가 적은데 조인 시도 횟수가 많은 경우 조인 순서를 바꾸어 보는 예시이다. 
* p218 ~ p222 참고

## 테이블 Prefetch
* Prefetch는, 디스크 I/O를 수행하려면 비용이 많이 들기 때문에, 한 번 I/O Call이 필요한 시점에 곧이어 읽을 가능성이 큰 블록들을 캐시에 미리 적재해두는 기능이다.
* 오라클 9i 부터는, NL 조인 시 인덱스 rowid에 의한 Inner 테이블 액세스가 Nested Loops 위쪽에 표시되곤 한다.
* 이것은 해당 테이블 액세스 단계에 Prefetch 기능이 적용되었음을 표현하기 위함이다.
```
Execution Plan
------------------------------------------------
0     SELECT STATEMENT Optimizer=ALL_ROWS (Cost=4 Card=14 Bytes=868)
1  0    TABLE ACCESS (BY INDEX ROWID) OF 'EMP' (TABLE) (Cost=1 Card=4 Bytes=128)
2  1      NESTED LOOPS (Cost=4 Card=14 Bytes=868)
3  2        TABLE ACCESS (FULL) OF `DEPT` (TABLE) (Cost=3 Card=4 Bytes=120)
4  2        INDEX (RANGE SCAN) OF 'EMP_DEPTNO_IDX' (INDEX) (Cost=0 Card=5)
```
* `_table_lookup_prefetch_size`파라미터로 테이블Prefetch를 제어할 수 있다.
* Prefetch 기능이 작동할 때, `db file sequential read` 대기 이벤트 대신 `db file parallel reads` 대기 이벤트가 나타난다.
* Prefetch는 Outer쪽 인덱스를 Unique Scan 할 때 작동하지 않으며, 이 경우를 제외하면 새 포맷의 실행계획이 나타날 수 있다.
  * Inner 쪽 Non-Unique 인덱스를 Range Scan할 때는 테이블 실행계획이 항상 나타난다.
  * Inner 쪽 Unique 인덱스를 Non-Unique 조건으로 Range Scan할 때도 테이블 Prefetch 실행계획이 항상 나타난다.
  * Inner 쪽 Unique 인덱스를 Unique 조건으로 액세스할 때도 Prefetch 실행계획이 나타날 수 있다. (p223 ~ p224 참고)
    * 이 때 인덱스는 Range Scan으로 액세스하며, 테이블 Prefetch 실행계획이 안 나타날 때는 Unique Scan으로 액세스한다.

## 배치 I/O
* 배치 I/O는 블록마다 I/O Call을 건건이 발생시키지 않고, 읽을 블록이 일정량 쌓일 때까지 I/O 요청을 모아두었다가 한번에 처리하는 방식이다.
```
Execution Plan
------------------------------------------------
0     SELECT STATEMENT Optimizer=ALL_ROWS (Cost=4 Card=14 Bytes=2K)
1  0    NESTED LOOPS
2  1      NESTED LOOPS (Cost=16 Card=14 Bytes=2K)
3  2        TABLE ACCESS (FULL) OF `DEPT` (TABLE) (Cost=2 Card=14 Bytes=1K)
4  2        INDEX (UNIQUE SCAN) OF 'PK_DEPT' (INDEX (UNIQUE)) (Cost=0 Card=1)
5  1      TABLE ACCESS (BY INDEX ROWID) OF 'DEPT' (TABLE) (Cost=1 Card=1 Bytes=30)
```
* 동작 방식은 아래와 같다.
  * 드라이빙 테이블에서 일정량의 레코드를 읽어 Inner쪽 인덱스와 조인하며 중간 결과 집합을 만든다.
  * 중간 결과집합이 일정량 쌓이면 Inner쪽 테이블 레코드를 액세스한다.
    * 이 때 테이블 블록을 버퍼캐시에서 찾으면 바로 최종 결과집합에 담고, 못 찾으면 중간 집합에 남겨둔다.
  * 위 과정에서 남겨진 중간집합에 대한 Inner쪽 테이블 블록을 디스크로부터 읽는다.
    * 이 때 Multiple Single Block I/O 방식을 사용한다.
  * 버퍼캐시에 올라오면 테이블 레코드를 읽어 최종 결과집합에 담는다.
  * 모든 레코드를 처리하거나 사용자가 Fetch Call을 중단할 때까지 위 과정들을 반복한다.
* `nlj_batching`, `no_nlj_batching` 힌트로 유도하거나 방지할 수 있다.
* 실제 배치 I/O가 작동하면 데이터 정렬순서가 달라질 수 있다.
  * 모두 버퍼 캐시에서 찾을 때는 똑같은 정렬 순서를 유지한다.
  * Prefetch 방식이나 기본적인 NL 조인을 할 때에는 디스크 I/O가 발생해도 데이터 정렬순서가 항상 일정하다.

## 버퍼 Pinning 효과
|버전|내용|상세|
|---|---|---|
| 8i|테이블 블록 피닝 시작| 인덱스를 통해 테이블을 읽을 때, 현재 읽고 있는 테이블 블록 하나를 피닝한다. 클러스터링 팩터가 좋으면 같은 블록을 반복 방문할 때 효과가 크다.|
|9i|Inner 테이블 인덱스 루트|NL 조인 시 Inner 테이블의 인덱스 루트 블록을 피닝하기 시작했다. 조인할 때마다 매번 루트부터 타고 내려오는 비용을 절감했다.|
|10g|테이블 블록 피닝 강화| Outer 레코드를 처리하고 다음 Outer 레코드로 넘어가더라도, Inner 테이블에서 읽었던 테이블 블록의 피닝 상태를 더 적극적으로 유지하려고 시도한다.|
|11g|인덱스 전체 블록 피닝|루트뿐만 아니라 모든 인덱스 블록에 대해 피닝을 적용하여 논리적 I/O를 획기적으로 줄인다.|

# 소트 머지 조인
## 기본 메커니즘
* 소트머지조인은 두 단계로 진행된다.
  * 소트 단계 : 양쪽 집합을 조인 컬럼 기준으로 정렬한다.
  * 머지 단계 : 정렬한 양쪽 집합을 서로 머지한다.
* Sort Area는 PGA영역에 할당되므로, SGA를 경유해 인덱스와 테이블을 액세스할 때보다 훨씬 빠르다.
  * PGA는 프로세스만을 위한 독립적인 메모리 공간이기 때문에, 데이터를 읽을 때 래치 획득 과정이 없다.

```oracle
select /*+ ordered use_merge(e) */ 
       d.deptno, d.dname, e.empno, e.ename
from dept d, emp e
where d.deptno = e.deptno
```
* 위 쿼리는 아래와 같이 동작한다.
  * Outer 테이블인 `dept`를 `deptno`기준으로 정렬한다.
  * Inner 테이블인 `emp`를 `deptno`기준으로 정렬한다.
  * Sort Area에 정렬된 `dept` 테이블을 스캔하면서 정렬된 `emp`테이블과 조인한다.
* `emp` 테이블이 정렬되어 있기 때문에 조인에 실패하는 레코드를 만나는 순간 멈출 수 있다.
* 정렬된 `emp`에서 스캔 시작점을 찾으려고 매번 탐색하지 않아도 된다.
  * Outer 테이블인 `dept`도 같은 순서로 정렬되어 있기 때문에 가능하다.

## 소트 머지 조인 특징
* 소트 머지 조인은 소트 부하만 감수하면 건건이 버퍼 캐시를 거치면서 조인하는 NL 조인보다 유리하다.
* NL 조인은 조인 컬럼에 대한 인덱스 유무에 따라 크게 영향을 받지만, 소트 머지 조인은 영향을 받지 않는다.
* 양쪽 집합을 개별적으로 읽고 나서 조인하기 때문에, 조인 컬럼에 인덱스가 없는 상황에서 조인 대상 집합을 줄일 수 있을 때 유리하다.
* NL조인에 비해 대용량 조인에 유리하지만, 해시조인의 등장으로 아래와같은 상황이 아니면 잘 쓰이지 않는다.
  * Outer 테이블에 소트 연산을 대체할 인덱스가 있을 때
  * 조인할 Outer 집합이 이미 정렬되어 있을 때
  * 조인 조건식이 등치(`=`) 조건이 아닐 때

## Outer 테이블에 소트 연산을 대체할 인덱스가 있을 때
```oracle
select /*+ ordered use_merge(e) */ *
from dept d, emp e
where d.deptno = e.dptno
  and d.loc = 'CHICAGO'
  and e.job = 'SALESMAN'
order by e.deptno
```
```
------------------------------------------------------------------------------------
| Id  | Operation                         | Name      | Rows  | Bytes | Cost (%CPU)|
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                  |           |       |       |            |
|   1 |   MERGE JOIN                      |           |       |       |            |
|   2 |     TABLE ACCESS BY INDEX ROWID   | DEPT      |       |       |            |
|   4 |       INDEX RANGE SCAN            | DEPT_IDX  |       |       |            |
|   5 |     SORT JOIN                     |           |       |       |            |
|   6 |       TABLE ACCESS BY INDEX ROWID | EMP       |       |       |            |
|   7 |         INDEX RANGE SCAN          | EMP_IDX   |       |       |            |
------------------------------------------------------------------------------------
```
* 위 예시와 같이, 인덱스를 이용해 소트 연산을 대체할 수 있는 대상은 Outer쪽 테이블 뿐이다.

### 소트머지조인에서의 부분범위 처리 
* 소트머지조인도 특정 조건에서는 부분범위 처리가 가능한데, 바로 Outer 테이블에 소트 연산을 대체할 인덱스가 있을 경우이다.
* 하지만 이 경우에도 결국 Inner 쪽 집합을 모두 읽어 정렬을 완료 한 경우부터 부분 범위처리가 가능하다. (NL조인만큼 빠르진 않음)

## 조인할 Outer 집합이 이미 정렬되어 있을 때
* 이미 group by, order by, distinct 연산을 수행 하여 Outer 집합이 조인 컬럼 기준으로 정렬되어 있는 경우가 있다.
* 이 때에는 조인을 위해 다시 정렬하지 않아도 되므로 소트 머지 조인이 유리하다.
* 아래 예시는, Outer 테이블을 group by 하고서도 Sort Join 오퍼레이션이 나타나는데, 10gR2에 도입된 hash group by로 처리했기 때문이다.
  ```oracle
  select /*+ ordered use_merge(d) */ d.deptno, d.dname, e.avg_sal
  from (select deptno, avg(sal) avg_sal 
        from emp 
        group by deptno) e
     , dept d
  where e.deptno = d.deptno
  ```
  ```
  -------------------------------------------------------------------------
  | Id  | Operation                   | Name | Rows  | Bytes | Cost (%CPU)|
  -------------------------------------------------------------------------
  |   0 | SELECT STATEMENT            |      |       |       |            |
  |   1 |   MERGE JOIN                |      |       |       |            |
  |   2 |     SORT JOIN               |      |       |       |            |
  |   3 |       VIEW                  |      |       |       |            |
  |   4 |         HASH GROUP BY       |      |       |       |            |
  |   5 |           TABLE ACCESS FULL | EMP  |       |       |            |
  |   6 |     SORT JOIN               |      |       |       |            |
  |   7 |       TABLE ACCESS FULL     | DEPT |       |       |            |
  -------------------------------------------------------------------------
  ```
* 아래와같이 order by 절을 명시해 sort group by로 유도하면 Outer 집합에 대한 Sort Join 오퍼레이션이 사라진다.
  ```oracle
  select /*+ ordered use_merge(d) */ d.deptno, d.dname, e.avg_sal
  from (select deptno, avg(sal) avg_sal 
        from emp 
        group by deptno
        order by deptno) e
     , dept d
  where e.deptno = d.deptno
  ```
  ```
  ---------------------------------------------------------------------------
  | Id  | Operation                     | Name | Rows  | Bytes | Cost (%CPU)|
  ---------------------------------------------------------------------------
  |   0 | SELECT STATEMENT              |      |       |       |            |
  |   1 |   MERGE JOIN                  |      |       |       |            |
  |   2 |     VIEW                      |      |       |       |            |
  |   3 |       SORT GROUP BY           |      |       |       |            |
  |   4 |         TABLE ACCESS FULL     | EMP  |       |       |            |
  |   5 |     SORT JOIN                 |      |       |       |            |
  |   6 |       TABLE ACCESS FULL       | DEPT |       |       |            |
  ---------------------------------------------------------------------------
  ```
* Inner 집합은 group by를 통해 이미 정렬되어 있어도 소트연산을 한번 더 수행한다.

## 조인 조건식이 등치(`=`) 조건이 아닐 때
* 해시 조인은 조언 조건식이 등치(`=`)조건일 때만 사용할 수 있지만, 소트 머지조인은 등치조건이 아닐 때에도 사용될 수 있다.
  ```oracle
  select /*+ ordered use_merge(e) */ d.deptno, d.dname, e.empno, e.ename
  from dept d, emp e
  where d.deptno <= e.deptno
  ```
  ```
  ---------------------------------------------------------------------------
  | Id  | Operation                     | Name | Rows  | Bytes | Cost (%CPU)|
  ---------------------------------------------------------------------------
  |   0 | SELECT STATEMENT              |      |       |       |            |
  |   1 |   MERGE JOIN                  |      |       |       |            |
  |   2 |     SORT JOIN                 |      |       |       |            |
  |   3 |       TABLE ACCESS FULL       | EMP  |       |       |            |
  |   4 |     SORT JOIN                 |      |       |       |            |
  |   5 |       TABLE ACCESS FULL       | DEPT |       |       |            |
  ---------------------------------------------------------------------------
  ```

# 해시 조인
## 기본 메커니즘
* 해시 조인은 두 단계로 진행된다.
  * Build 단계
    * 조건에 해당하는 작은쪽 집합(Build Input)을 읽어 해시 테이블을 생성한다.
    * 조인 키를 해시 함수에 넣어 나온 해시 값을 기준으로, 해시 버킷/해시 체인에 로우를 연결한다.
    * 이 해시 테이블은 PGA의 Hash Area에 저장되고, 크기가 커서 PGA에 담을 수 없다면 Temp 테이블스페이스를 이용한다.
  * Probe 단계
    * 큰 쪽 집합(Probe Input)을 한 로우씩 읽는다.
    * 해당 로우의 조인 키를 같은 해시 함수에 넣어 같은 해시 값을 얻는다.
    * 그 해시 값에 해당하는 해시 체인만 스캔해서 매칭되는 로우를 찾는다. 
* 해시 조인은 NL조인처럼 조인 과정에서 발생하는 Random 액세스 부하가 없고, 소트머지조인처럼 조인 전에 미리 양쪽 집합을 정렬하는 부담도 없다.
* 해시 테이블을 생성하는 비용이 수반되므로, Build Input이 작을 때 효과적이다.

## 힌트를 이용한 조인 순서 및 Build Input 조정
* `use_hash` 힌트로 해시조인을 유도할 수 있다.
* 아래 예시에서는 `use_hash` 힌트만 사용하므로, Build Input을 옵티마이저가 선택한다.
  ```oracle
  select /*+ use_hash(d e) */ d.deptno, d.dname, e.empno, e.ename
  from detp d, emp e
  where d.deptno = e.deptno
  ```
  ```
  ---------------------------------------------------------------------------
  | Id  | Operation                     | Name | Rows  | Bytes | Cost (%CPU)|
  ---------------------------------------------------------------------------
  |   0 | SELECT STATEMENT              |      |       |       |            |
  |   1 |   HASH JOIN                   |      |       |       |            |
  |   2 |     TABLE ACCESS FULL         | DEPT |       |       |            |
  |   3 |     TABLE ACCESS FULL         | EMP  |       |       |            |
  ---------------------------------------------------------------------------
  ```
* Build Input을 직접 선택하고자 하면 `swap_join_inputs` 힌트를 사용하면 된다.
  ```oracle
  select /*+ use_hash(d e) swap_join_inputs(e) */ d.deptno, d.dname, e.empno
  from detp d, emp e
  where d.deptno = e.deptno
  ```
  * 2개 테이블을 조인 시에는 `ordered`, `leading` 힌트를 사용해도 된다.

## 해시조인 알고리즘
### 첫 번째 알고리즘
```oracle
select /*+ leading(r, c, l, d, e) 
           use_hash(c) use_hash(l) use_hash(d) use_hash(e) */
       e.first_name, e.last_name, d.department_name
     , l.street_address, l.city, c.country_name, r.region_name 
from hr.regions r
   , hr.countries c
   , hr.locations l
   , hr.departments d
   , hr.employee e
where d.department_id = e.department_id
  and l.location_id = d.location_id
  and c.country_id = l.country_id
  and r.region_id = c.region_id;
```
```
---------------------------------------------------------------------------------------
| Id  | Operation                      | Name            | Rows  | Bytes | Cost (%CPU)|
---------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |                 |       |       |            |
|   1 |   HASH JOIN                    |                 |       |       |            |
|   2 |     HASH JOIN                  |                 |       |       |            |
|   3 |       HASH JOIN                |                 |       |       |            |
|   4 |         HASH JOIN              |                 |       |       |            |
|   5 |           TABLE ACCESS FULL    | REGIONS         |       |       |            |
|   6 |           INDEX FULL SCAN      | COUNTRY_C_ID_PK |       |       |            |
|   7 |         TABLE ACCESS FULL      | LOCATIONS       |       |       |            |
|   8 |       TABLE ACCESS FULL        | DEPARTMENTS     |       |       |            |
|   9 |     TABLE ACCESS FULL          | EMPLOYEES       |       |       |            |
---------------------------------------------------------------------------------------
```
* 위 예시는, `leading` 힌트를 통해 순서대로 조인하되, 각각 해시 조인으로 처리하라고 되어 있다.
* 따라서 Build Input을 결정하기 위한 것은 아니기 때문에, Build Input은 옵티마이저에 의해 결정되었다.
  1. `regions`
  2. `regions` & `countries`
  3. `regions` & `countries` & `locations`
  4. `regions` & `countries` & `locations` & `departments`

### 두 번째 알고리즘
```oracle
select /*+ leading(r, c, l, d, e) 
           use_hash(c) use_hash(l) use_hash(d) use_hash(e)
           swap_join_inputs(l) 
           swap_join_inputs(d)
           swap_join_inputs(e) */
       e.first_name, e.last_name, d.department_name
     , l.street_address, l.city, c.country_name, r.region_name 
from hr.regions r
   , hr.countries c
   , hr.locations l
   , hr.departments d
   , hr.employee e
where d.department_id = e.department_id
  and l.location_id = d.location_id
  and c.country_id = l.country_id
  and r.region_id = c.region_id;
```
```
-------------------------------------------------------------------------------------
| Id  | Operation                    | Name            | Rows  | Bytes | Cost (%CPU)|
-------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |                 |       |       |            |
|   1 |   HASH JOIN                  |                 |       |       |            |
|   2 |     TABLE ACCESS FULL        | EMPLOYEES       |       |       |            |
|   3 |     HASH JOIN                |                 |       |       |            |
|   4 |       TABLE ACCESS FULL      | DEPARTMENTS     |       |       |            |
|   5 |       HASH JOIN              |                 |       |       |            |
|   6 |         TABLE ACCESS FULL    | LOCATIONS       |       |       |            |
|   7 |         HASH JOIN            |                 |       |       |            |
|   8 |           TABLE ACCESS FULL  | REGIONS         |       |       |            |
|   9 |           INDEX FULL SCAN    | COUNTRY_C_ID_PK |       |       |            |
-------------------------------------------------------------------------------------
```
* 위 예시는 `swap_join_inputs` 힌트를 사용하여 Build Input을 직접 지정한 예시이다.
* NL 조인처럼 순차적으로 조인을 진행한다.
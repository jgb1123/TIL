# Nested Loops 조인
* NL 조인은 중첩 루프문의 수행 구조를 사용한다.

## 힌트를 이용해 NL 조인을 제어하는 방법
* `ues_nl` 힌트를 사용하여 NL조인을 유도할 수 있다.
  ```oracle
  select /*+ ordered use_nl(B) use_nl(C) use_nl(D) */ *
  from A, B, C, D
  where B.a = A.a
    and C.b = B.b
    and D.c = C.c
  ```
* 아래와 같이 `leading`힌트로 조인 순서를 제어할 수도 있다.
  ```oracle
  select /*+ leading(C, A, D, B) use_nl(A) use_nl(D) use_nl(B) */ *
  from A, B, C, D
  where B.a = A.a
    and C.b = B.b
    and D.c = C.c
  ```
  * 9i까지는 `leading`힌트에 driving table 인자 하나만 입력할 수 있었지만, 10g부터는 여러 테이블을 기술할 수 있도록 개선되었다.
  * 따라서 최근엔 `ordered` 힌트보다 `leading`힌트를 많이 사용한다.
* 아래와 같이 `ordered`나 `leading`힌트를 기술하지 않으면, NL조인을 사용하되 조인 순서는 옵티마이저가 정하게 된다.
  ```oracle
  select /*+ use_nl(A, B, C, D) */ *
  from A, B, C, D
  where B.a = A.a
    and C.b = B.b
    and D.c = C.c
  ```
  
## NL 조인 수행 과정 분석
```oracle
select /*+ ordered use_nl(e) */
       e.empno, e.ename, d.dname, e.job, e.sal
from dept d, emp e
where e.deptno = d.deptno -- 1
  and d.loc = 'SEOUL'     -- 2  
  and d.gb = '2'          -- 3
  and e.sal >= 1500       -- 4
order by sal desc
```

```
pk_dept         : dept.deptno
dept_loc_idx    : dept.loc
pk_emp          : emp.empno
emp_deptno_idx  : emp.deptno
emp_sal_idx     : emp.sal
```  

```
Execution Plan
------------------------------------------------
0     SELECT STATEMENT
1  0    SORT ORDER BY
2  1      NESTED LOOPS
3  2        TABLE ACCESS BY INDEX ROWID DEPT
4  3          INDEX RANGE SCAN DEPT_LOC_IDX
5  2        TABLE ACCESS BY INDEX ROWID EMP
6  5          INDEX RANGE SCAN EMP_DEPTNO_IDX
```
* 위 예시에서 사용되는 인덱스는 `detp_loc_idx`와 `emp_deptno_idx`이며, 조건 비교 순서는 2 -> 3 -> 1 -> 4 순이다.
* 동작 순서는 아래와 같다.
  * `dept_loc_idx` 인덱스로 `dept.loc = 'SEOUL` 조건을 만족하는 레코드를 찾기 위해 범위스캔한다.
  * `dept_loc_idx` 인덱스에서 읽은 rowid를 가지고 `dept` 테이블 액세스 후 `detp.gb = '2'`필터 조건을 만족하는 레코드를 찾는다.
  * `dept` 테이블에서 읽은 `deptno` 값을 가지고 조건을 만족하는 `emp`쪽 레코드를 찾으려고 `emp_deptno_idx` 인덱스를 범위 스캔한다.
  * `dept_loc_idx` 인덱스에서 읽은 rowid를 가지고 `emp`테이블을 액세스해 `sal >= 1500` 필터조건을 만족하는 레코드를 찾는다.
  * `sal` 기준 내림차순 내림차순 정렬 후 결과를 리턴한다.
* 위 예시에서 부하 지점은 아래와 같다.
  * 단일컬럼 인덱스를 `=` 조건으로 스캔했기 때문에, 그만큼 Random 액세스가 발생한다.
    * 만약 많은양의 Random 액세스가 발생하고, `gb = '2'`조건에 의해 필터링되는 비율이 높다면 해당 인덱스에 `gb`컬럼을 추가하는 방안을 고려해야 한다.
  * `emp_deptno_idx` 인덱스 탐색 시, Outer 테이블인 `dept`를 읽고 나서 필터된 결과만큼 조인 액세스가 발생한다.
    * 만약 `emp_deptno_idx`의 높이가 3이면 매 건마다 그만큼의 블록 I/O가 발생(버퍼 Pinning 효과 고려 X)하고 리프블록을 스캔하면서 추가적인 I/O가 발생한다.
  * `emp_deptno_idx` 읽고 `emp` 테이블 액세스 시, Random I/O가 많이 일어난다.
    * `sal >= 1500` 조건에 의해 필터링되는 비율이 높다면, `emp_deptno_idx` 인덱스에 `sal`컬럼을 추가하는 방안을 고려해야 한다.
* OLTP 시스템에서 조인을 튜팅할 때에는, 일반적으로 NL 조인부터 고려해야 한다.
  * 각 단계의 수행 일량을 확인 후, 과도한 Random 액세스가 발생하는 지점을 파악해야 한다.
  * 여러 가지 방안을 검토 후 NL 조인이 효과적이지 못하다면, 해시조인이나 소트머지 조인을 검토해야 한다.

## NL 조인의 특징
* Random 액세스 위주의 조인 방식이기 때문에, 인덱스 구성이 아무리 완벽하더라도 대량의 데이터를 조인할 때에는 매우 비효율적이다.
* 조인을 한 레코드 씩 순차적으로 진행한다.
  * 아무리 대용량 집합이더라도 부분범위 처리가 가능하기 때문에 좋은 응답 속도를 낼 수 있다.
* 다른 조인 방식과 비교했을 때 인덱스 구성 전략이 특히 중요하다.
* 즉, NL 조인은 소량의 데이터를 주로 처리하거나, 부분범위처리가 가능한 온라인 트랜잭션 환경에 적합한 조인 방식이다.

## NL 조인 튜닝 실습
* Outer쪽 인덱스를 수정 해 Random 액세스를 줄이거나, 조인후의 레코드가 적은데 조인 시도 횟수가 많은 경우 조인 순서를 바꾸어 보는 예시이다. 
* p218 ~ p222 참고

## 테이블 Prefetch
* Prefetch는, 디스크 I/O를 수행하려면 비용이 많이 들기 때문에, 한 번 I/O Call이 필요한 시점에 곧이어 읽을 가능성이 큰 블록들을 캐시에 미리 적재해두는 기능이다.
* 오라클 9i 부터는, NL 조인 시 인덱스 rowid에 의한 Inner 테이블 액세스가 Nested Loops 위쪽에 표시되곤 한다.
* 이것은 해당 테이블 액세스 단계에 Prefetch 기능이 적용되었음을 표현하기 위함이다.
```
Execution Plan
------------------------------------------------
0     SELECT STATEMENT Optimizer=ALL_ROWS (Cost=4 Card=14 Bytes=868)
1  0    TABLE ACCESS (BY INDEX ROWID) OF 'EMP' (TABLE) (Cost=1 Card=4 Bytes=128)
2  1      NESTED LOOPS (Cost=4 Card=14 Bytes=868)
3  2        TABLE ACCESS (FULL) OF `DEPT` (TABLE) (Cost=3 Card=4 Bytes=120)
4  2        INDEX (RANGE SCAN) OF 'EMP_DEPTNO_IDX' (INDEX) (Cost=0 Card=5)
```
* `_table_lookup_prefetch_size`파라미터로 테이블Prefetch를 제어할 수 있다.
* Prefetch 기능이 작동할 때, `db file sequential read` 대기 이벤트 대신 `db file parallel reads` 대기 이벤트가 나타난다.
* Prefetch는 Outer쪽 인덱스를 Unique Scan 할 때 작동하지 않으며, 이 경우를 제외하면 새 포맷의 실행계획이 나타날 수 있다.
  * Inner 쪽 Non-Unique 인덱스를 Range Scan할 때는 테이블 실행계획이 항상 나타난다.
  * Inner 쪽 Unique 인덱스를 Non-Unique 조건으로 Range Scan할 때도 테이블 Prefetch 실행계획이 항상 나타난다.
  * Inner 쪽 Unique 인덱스를 Unique 조건으로 액세스할 때도 Prefetch 실행계획이 나타날 수 있다. (p223 ~ p224 참고)
    * 이 때 인덱스는 Range Scan으로 액세스하며, 테이블 Prefetch 실행계획이 안 나타날 때는 Unique Scan으로 액세스한다.

## 배치 I/O
* 배치 I/O는 블록마다 I/O Call을 건건이 발생시키지 않고, 읽을 블록이 일정량 쌓일 때까지 I/O 요청을 모아두었다가 한번에 처리하는 방식이다.
```
Execution Plan
------------------------------------------------
0     SELECT STATEMENT Optimizer=ALL_ROWS (Cost=4 Card=14 Bytes=2K)
1  0    NESTED LOOPS
2  1      NESTED LOOPS (Cost=16 Card=14 Bytes=2K)
3  2        TABLE ACCESS (FULL) OF `DEPT` (TABLE) (Cost=2 Card=14 Bytes=1K)
4  2        INDEX (UNIQUE SCAN) OF 'PK_DEPT' (INDEX (UNIQUE)) (Cost=0 Card=1)
5  1      TABLE ACCESS (BY INDEX ROWID) OF 'DEPT' (TABLE) (Cost=1 Card=1 Bytes=30)
```
* 동작 방식은 아래와 같다.
  * 드라이빙 테이블에서 일정량의 레코드를 읽어 Inner쪽 인덱스와 조인하며 중간 결과 집합을 만든다.
  * 중간 결과집합이 일정량 쌓이면 Inner쪽 테이블 레코드를 액세스한다.
    * 이 때 테이블 블록을 버퍼캐시에서 찾으면 바로 최종 결과집합에 담고, 못 찾으면 중간 집합에 남겨둔다.
  * 위 과정에서 남겨진 중간집합에 대한 Inner쪽 테이블 블록을 디스크로부터 읽는다.
    * 이 때 Multiple Single Block I/O 방식을 사용한다.
  * 버퍼캐시에 올라오면 테이블 레코드를 읽어 최종 결과집합에 담는다.
  * 모든 레코드를 처리하거나 사용자가 Fetch Call을 중단할 때까지 위 과정들을 반복한다.
* `nlj_batching`, `no_nlj_batching` 힌트로 유도하거나 방지할 수 있다.
* 실제 배치 I/O가 작동하면 데이터 정렬순서가 달라질 수 있다.
  * 모두 버퍼 캐시에서 찾을 때는 똑같은 정렬 순서를 유지한다.
  * Prefetch 방식이나 기본적인 NL 조인을 할 때에는 디스크 I/O가 발생해도 데이터 정렬순서가 항상 일정하다.

## 버퍼 Pinning 효과
|버전|내용|상세|
|---|---|---|
| 8i|테이블 블록 피닝 시작| 인덱스를 통해 테이블을 읽을 때, 현재 읽고 있는 테이블 블록 하나를 피닝한다. 클러스터링 팩터가 좋으면 같은 블록을 반복 방문할 때 효과가 크다.|
|9i|Inner 테이블 인덱스 루트|NL 조인 시 Inner 테이블의 인덱스 루트 블록을 피닝하기 시작했다. 조인할 때마다 매번 루트부터 타고 내려오는 비용을 절감했다.|
|10g|테이블 블록 피닝 강화| Outer 레코드를 처리하고 다음 Outer 레코드로 넘어가더라도, Inner 테이블에서 읽었던 테이블 블록의 피닝 상태를 더 적극적으로 유지하려고 시도한다.|
|11g|인덱스 전체 블록 피닝|루트뿐만 아니라 모든 인덱스 블록에 대해 피닝을 적용하여 논리적 I/O를 획기적으로 줄인다.|

# 소트 머지 조인
## 기본 메커니즘
* 소트머지조인은 두 단계로 진행된다.
  * 소트 단계 : 양쪽 집합을 조인 컬럼 기준으로 정렬한다.
  * 머지 단계 : 정렬한 양쪽 집합을 서로 머지한다.
* Sort Area는 PGA영역에 할당되므로, SGA를 경유해 인덱스와 테이블을 액세스할 때보다 훨씬 빠르다.
  * PGA는 프로세스만을 위한 독립적인 메모리 공간이기 때문에, 데이터를 읽을 때 래치 획득 과정이 없다.

```oracle
select /*+ ordered use_merge(e) */ 
       d.deptno, d.dname, e.empno, e.ename
from dept d, emp e
where d.deptno = e.deptno
```
* 위 쿼리는 아래와 같이 동작한다.
  * Outer 테이블인 `dept`를 `deptno`기준으로 정렬한다.
  * Inner 테이블인 `emp`를 `deptno`기준으로 정렬한다.
  * Sort Area에 정렬된 `dept` 테이블을 스캔하면서 정렬된 `emp`테이블과 조인한다.
* `emp` 테이블이 정렬되어 있기 때문에 조인에 실패하는 레코드를 만나는 순간 멈출 수 있다.
* 정렬된 `emp`에서 스캔 시작점을 찾으려고 매번 탐색하지 않아도 된다.
  * Outer 테이블인 `dept`도 같은 순서로 정렬되어 있기 때문에 가능하다.

## 소트 머지 조인 특징
* 소트 머지 조인은 소트 부하만 감수하면 건건이 버퍼 캐시를 거치면서 조인하는 NL 조인보다 유리하다.
* NL 조인은 조인 컬럼에 대한 인덱스 유무에 따라 크게 영향을 받지만, 소트 머지 조인은 영향을 받지 않는다.
* 양쪽 집합을 개별적으로 읽고 나서 조인하기 때문에, 조인 컬럼에 인덱스가 없는 상황에서 조인 대상 집합을 줄일 수 있을 때 유리하다.
* NL조인에 비해 대용량 조인에 유리하지만, 해시조인의 등장으로 아래와같은 상황이 아니면 잘 쓰이지 않는다.
  * Outer 테이블에 소트 연산을 대체할 인덱스가 있을 때
  * 조인할 Outer 집합이 이미 정렬되어 있을 때
  * 조인 조건식이 등치(`=`) 조건이 아닐 때

## Outer 테이블에 소트 연산을 대체할 인덱스가 있을 때
```oracle
select /*+ ordered use_merge(e) */ *
from dept d, emp e
where d.deptno = e.dptno
  and d.loc = 'CHICAGO'
  and e.job = 'SALESMAN'
order by e.deptno
```
```
------------------------------------------------------------------------------------
| Id  | Operation                         | Name      | Rows  | Bytes | Cost (%CPU)|
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                  |           |       |       |            |
|   1 |   MERGE JOIN                      |           |       |       |            |
|   2 |     TABLE ACCESS BY INDEX ROWID   | DEPT      |       |       |            |
|   4 |       INDEX RANGE SCAN            | DEPT_IDX  |       |       |            |
|   5 |     SORT JOIN                     |           |       |       |            |
|   6 |       TABLE ACCESS BY INDEX ROWID | EMP       |       |       |            |
|   7 |         INDEX RANGE SCAN          | EMP_IDX   |       |       |            |
------------------------------------------------------------------------------------
```
* 위 예시와 같이, 인덱스를 이용해 소트 연산을 대체할 수 있는 대상은 Outer쪽 테이블 뿐이다.

### 소트머지조인에서의 부분범위 처리 
* 소트머지조인도 특정 조건에서는 부분범위 처리가 가능한데, 바로 Outer 테이블에 소트 연산을 대체할 인덱스가 있을 경우이다.
* 하지만 이 경우에도 결국 Inner 쪽 집합을 모두 읽어 정렬을 완료 한 경우부터 부분 범위처리가 가능하다. (NL조인만큼 빠르진 않음)

## 조인할 Outer 집합이 이미 정렬되어 있을 때
* 이미 group by, order by, distinct 연산을 수행 하여 Outer 집합이 조인 컬럼 기준으로 정렬되어 있는 경우가 있다.
* 이 때에는 조인을 위해 다시 정렬하지 않아도 되므로 소트 머지 조인이 유리하다.
* 아래 예시는, Outer 테이블을 group by 하고서도 Sort Join 오퍼레이션이 나타나는데, 10gR2에 도입된 hash group by로 처리했기 때문이다.
  ```oracle
  select /*+ ordered use_merge(d) */ d.deptno, d.dname, e.avg_sal
  from (select deptno, avg(sal) avg_sal 
        from emp 
        group by deptno) e
     , dept d
  where e.deptno = d.deptno
  ```
  ```
  -------------------------------------------------------------------------
  | Id  | Operation                   | Name | Rows  | Bytes | Cost (%CPU)|
  -------------------------------------------------------------------------
  |   0 | SELECT STATEMENT            |      |       |       |            |
  |   1 |   MERGE JOIN                |      |       |       |            |
  |   2 |     SORT JOIN               |      |       |       |            |
  |   3 |       VIEW                  |      |       |       |            |
  |   4 |         HASH GROUP BY       |      |       |       |            |
  |   5 |           TABLE ACCESS FULL | EMP  |       |       |            |
  |   6 |     SORT JOIN               |      |       |       |            |
  |   7 |       TABLE ACCESS FULL     | DEPT |       |       |            |
  -------------------------------------------------------------------------
  ```
* 아래와같이 order by 절을 명시해 sort group by로 유도하면 Outer 집합에 대한 Sort Join 오퍼레이션이 사라진다.
  ```oracle
  select /*+ ordered use_merge(d) */ d.deptno, d.dname, e.avg_sal
  from (select deptno, avg(sal) avg_sal 
        from emp 
        group by deptno
        order by deptno) e
     , dept d
  where e.deptno = d.deptno
  ```
  ```
  ---------------------------------------------------------------------------
  | Id  | Operation                     | Name | Rows  | Bytes | Cost (%CPU)|
  ---------------------------------------------------------------------------
  |   0 | SELECT STATEMENT              |      |       |       |            |
  |   1 |   MERGE JOIN                  |      |       |       |            |
  |   2 |     VIEW                      |      |       |       |            |
  |   3 |       SORT GROUP BY           |      |       |       |            |
  |   4 |         TABLE ACCESS FULL     | EMP  |       |       |            |
  |   5 |     SORT JOIN                 |      |       |       |            |
  |   6 |       TABLE ACCESS FULL       | DEPT |       |       |            |
  ---------------------------------------------------------------------------
  ```
* Inner 집합은 group by를 통해 이미 정렬되어 있어도 소트연산을 한번 더 수행한다.

## 조인 조건식이 등치(`=`) 조건이 아닐 때
* 해시 조인은 조언 조건식이 등치(`=`)조건일 때만 사용할 수 있지만, 소트 머지조인은 등치조건이 아닐 때에도 사용될 수 있다.
  ```oracle
  select /*+ ordered use_merge(e) */ d.deptno, d.dname, e.empno, e.ename
  from dept d, emp e
  where d.deptno <= e.deptno
  ```
  ```
  ---------------------------------------------------------------------------
  | Id  | Operation                     | Name | Rows  | Bytes | Cost (%CPU)|
  ---------------------------------------------------------------------------
  |   0 | SELECT STATEMENT              |      |       |       |            |
  |   1 |   MERGE JOIN                  |      |       |       |            |
  |   2 |     SORT JOIN                 |      |       |       |            |
  |   3 |       TABLE ACCESS FULL       | EMP  |       |       |            |
  |   4 |     SORT JOIN                 |      |       |       |            |
  |   5 |       TABLE ACCESS FULL       | DEPT |       |       |            |
  ---------------------------------------------------------------------------
  ```

# 해시 조인
## 기본 메커니즘
* 해시 조인은 두 단계로 진행된다.
  * Build 단계
    * 조건에 해당하는 작은쪽 집합(Build Input)을 읽어 해시 테이블을 생성한다.
    * 조인 키를 해시 함수에 넣어 나온 해시 값을 기준으로, 해시 버킷/해시 체인에 로우를 연결한다.
    * 이 해시 테이블은 PGA의 Hash Area에 저장되고, 크기가 커서 PGA에 담을 수 없다면 Temp 테이블스페이스를 이용한다.
  * Probe 단계
    * 큰 쪽 집합(Probe Input)을 한 로우씩 읽는다.
    * 해당 로우의 조인 키를 같은 해시 함수에 넣어 같은 해시 값을 얻는다.
    * 그 해시 값에 해당하는 해시 체인만 스캔해서 매칭되는 로우를 찾는다. 
* 해시 조인은 NL조인처럼 조인 과정에서 발생하는 Random 액세스 부하가 없고, 소트머지조인처럼 조인 전에 미리 양쪽 집합을 정렬하는 부담도 없다.
* 해시 테이블을 생성하는 비용이 수반되므로, Build Input이 작을 때 효과적이다.

## 힌트를 이용한 조인 순서 및 Build Input 조정
* `use_hash` 힌트로 해시조인을 유도할 수 있다.
* 아래 예시에서는 `use_hash` 힌트만 사용하므로, Build Input을 옵티마이저가 선택한다.
  ```oracle
  select /*+ use_hash(d e) */ d.deptno, d.dname, e.empno, e.ename
  from detp d, emp e
  where d.deptno = e.deptno
  ```
  ```
  ---------------------------------------------------------------------------
  | Id  | Operation                     | Name | Rows  | Bytes | Cost (%CPU)|
  ---------------------------------------------------------------------------
  |   0 | SELECT STATEMENT              |      |       |       |            |
  |   1 |   HASH JOIN                   |      |       |       |            |
  |   2 |     TABLE ACCESS FULL         | DEPT |       |       |            |
  |   3 |     TABLE ACCESS FULL         | EMP  |       |       |            |
  ---------------------------------------------------------------------------
  ```
* Build Input을 직접 선택하고자 하면 `swap_join_inputs` 힌트를 사용하면 된다.
  ```oracle
  select /*+ use_hash(d e) swap_join_inputs(e) */ d.deptno, d.dname, e.empno
  from detp d, emp e
  where d.deptno = e.deptno
  ```
  * 2개 테이블을 조인 시에는 `ordered`, `leading` 힌트를 사용해도 된다.

## 해시조인 알고리즘
### 첫 번째 알고리즘
```oracle
select /*+ leading(r, c, l, d, e) 
           use_hash(c) use_hash(l) use_hash(d) use_hash(e) */
       e.first_name, e.last_name, d.department_name
     , l.street_address, l.city, c.country_name, r.region_name 
from hr.regions r
   , hr.countries c
   , hr.locations l
   , hr.departments d
   , hr.employee e
where d.department_id = e.department_id
  and l.location_id = d.location_id
  and c.country_id = l.country_id
  and r.region_id = c.region_id;
```
```
---------------------------------------------------------------------------------------
| Id  | Operation                      | Name            | Rows  | Bytes | Cost (%CPU)|
---------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |                 |       |       |            |
|   1 |   HASH JOIN                    |                 |       |       |            |
|   2 |     HASH JOIN                  |                 |       |       |            |
|   3 |       HASH JOIN                |                 |       |       |            |
|   4 |         HASH JOIN              |                 |       |       |            |
|   5 |           TABLE ACCESS FULL    | REGIONS         |       |       |            |
|   6 |           INDEX FULL SCAN      | COUNTRY_C_ID_PK |       |       |            |
|   7 |         TABLE ACCESS FULL      | LOCATIONS       |       |       |            |
|   8 |       TABLE ACCESS FULL        | DEPARTMENTS     |       |       |            |
|   9 |     TABLE ACCESS FULL          | EMPLOYEES       |       |       |            |
---------------------------------------------------------------------------------------
```
* 위 예시는, `leading` 힌트를 통해 순서대로 조인하되, 각각 해시 조인으로 처리하라고 되어 있다.
* 따라서 Build Input을 결정하기 위한 것은 아니기 때문에, Build Input은 옵티마이저에 의해 결정되었다.
  1. `regions`
  2. `regions` & `countries`
  3. `regions` & `countries` & `locations`
  4. `regions` & `countries` & `locations` & `departments`

### 두 번째 알고리즘
```oracle
select /*+ leading(r, c, l, d, e) 
           use_hash(c) use_hash(l) use_hash(d) use_hash(e)
           swap_join_inputs(l) 
           swap_join_inputs(d)
           swap_join_inputs(e) */
       e.first_name, e.last_name, d.department_name
     , l.street_address, l.city, c.country_name, r.region_name 
from hr.regions r
   , hr.countries c
   , hr.locations l
   , hr.departments d
   , hr.employee e
where d.department_id = e.department_id
  and l.location_id = d.location_id
  and c.country_id = l.country_id
  and r.region_id = c.region_id;
```
```
-------------------------------------------------------------------------------------
| Id  | Operation                    | Name            | Rows  | Bytes | Cost (%CPU)|
-------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |                 |       |       |            |
|   1 |   HASH JOIN                  |                 |       |       |            |
|   2 |     TABLE ACCESS FULL        | EMPLOYEES       |       |       |            |
|   3 |     HASH JOIN                |                 |       |       |            |
|   4 |       TABLE ACCESS FULL      | DEPARTMENTS     |       |       |            |
|   5 |       HASH JOIN              |                 |       |       |            |
|   6 |         TABLE ACCESS FULL    | LOCATIONS       |       |       |            |
|   7 |         HASH JOIN            |                 |       |       |            |
|   8 |           TABLE ACCESS FULL  | REGIONS         |       |       |            |
|   9 |           INDEX FULL SCAN    | COUNTRY_C_ID_PK |       |       |            |
-------------------------------------------------------------------------------------
```
* 위 예시는 `swap_join_inputs` 힌트를 사용하여 Build Input을 직접 지정한 예시이다.
* NL 조인처럼 순차적으로 조인을 진행한다.

## Build Input이 Hash Area를 초과할 때 처리 방식

### Grace 해시 조인
* In-Memory 해시 조인이 불가능할 때 Grace 해시 조인 알고리즘을 사용한다.
1) 파티션 단계
  * 조인되는 양쪽 집합 모두 조인 컬럼에 해시 함수를 적용하고, 반환된 해시 값에 따라 동적으로 파티셔닝을 실시한다.
  * 독립적으로 처리할 수 있는 여러 개의 작은 서브 집합으로 분할하여 파티션 짝을 생성하는 단계이다.
  * 파티션 단계에서 양쪽 집합을 모두 읽어 디스크상의 Temp 공간에 일단 저장해야 하므로, Im-Memory 해시 조인보다 성능이 크게 떨어진다.
2) 조인 단계
  * 각 파티션 짝에 대해 하나씩 조인을 수행한다.
  * 각 파티션 짝이 작은 쪽을 파티션 Build Input으로 선택해 해시 테이블을 생성한다.
  * 해시 테이블 생성 후, 반대 쪽 파티션 로우를 하나씩 읽으며 해시 테이블을 탐색하며, 모든 파티션 짝에 대한 처리를 진행한다.

### Hybrid 해시 조인
* Grace 해시 조인의 디스크 I/O 부하 문제를 보완하기 위한 알고리즘이 사용된다.
1) 두 테이블 중 작은쪽을 Build Input으로 선택하고, 두 개의 해시 함수를 사용하며 Hash Area에 해시 테이블을 생성한다.
   * 첫 번째 해시 값 : 레코드를 저장할 파티션을 결정한다.
   * 두 번째 해시 값 : 실제 조인할 때를 위해 레코드와 함께 저장한다. 
2) 해시 테이블 생성 중 Hash Area가 꽉 차면 그 중 가장 큰 파티션을 디스크에 기록한다.
3) 해시 테이블을 완성하기 위해 Build Input을 계속 읽는 동안 이미 디스크에 기록된 파티션에 해당되는 레코드는 디스크 파티션에 기록한다.
4) Hash Area가 다 차면 가장 큰 파티션을 디스크에 기록한다.
5) 첫 테이블에 대한 파티셔닝 단계가 끝나면 파티션 크기가 작은 순으로 메모리를 채운다.
6) 2개의 해시 함수를 사용하여 두 번째 테이블을 읽기 시작한다.
   * 첫 번째 해시 값에 해당하는 파티션이 현재 메모리에 있다면 그 파티션을 스캔하고, 여기서 조인 레코드를 찾으면 바로 결과 집합에 포함시킨다.
   * 이때, 비트-벡터 필터링을 거쳐 선택된 레코드만 파티션을 스캔하며, 선택되지 않은 레코드는 버린다.
7) 비트-벡터 필터링을 통과했지만 메모리에서 매칭되는 파티션을 찾지 못하면 Build Input을 파티셔닝할 때와 같은 방식으로 해시 파티셔닝 한다.
   * 첫 번째 해시 값으로 레코드가 저장될 파티션을 결정하고, 두 번째 해시 값과 함께 디스크로 저장된다.
   * 윗 단계에서 비트-벡터 필터링을 거친 레코드만 디스크에 기록하게 된다.
8) 이제 양쪽 테이블 모두 해시 함수로 파티셔닝 했기 때문에 같은 해시 값을 갖는 레코드끼리는 같은 파티션 짝에 놓이게 된다.
9) 각 파티션 짝에 대해 하나씩 조인을 하는데, 파티션 짝 별로 작은 쪽 파티션을 Build Input으로 선택해 해시 테이블을 생성하는데, 모든 파티션에 대해 반복한다.
   * 위에서 저장해둔 해시값들이 이용된다.

### Recursive 해시 조인(Nested-loops 해시 조인)
* 디스크에 기록된 파티션 짝끼리 조인을 수행하려고 할 때, 작은 파티션을 메모리에 로드하는 과정에서 또다시 Hash Area를 초과하는 경우가 발생할 수 있다.
* 이럴 땐 추가적인 파티셔닝을 거치게 되는데, 이것을 Recursive 해시 조인이라고 한다.
  * Recursive 해시 조인은 Multipass 해시 조인이라고도 한다.
  * 디스크 쓰기가 발생했지만, Multipass 오퍼레이션을 거치지 않은 경우엔 Onepass 해시 조인이라고 한다.
  * 디스크를 전혀 사용하지 않은 In-Memory 해시 조인은 Optimal 해시조인이라고 한다.

### 비트-벡터 필터링
* Hybrid 조인에서, 두 번째 테이블을 읽는 과정 중 메모리 상에서 조인을 완료하기 때문에, 두 번째 테이블이 디스크에 기록되는 양을 상당히 줄일 수 있다.
* 여기에는 비트-벡터 필터링 기법이 사용되는데, 조인 성공 가능성이 없는 파티션 레코드는 아예 디스크에 기록되지 않게 하기 위함이다.
* 다른 조인 키 값에 대한 해시 값이 우연히 같을수는 있기 때문에, 비트-벡터가 1로 설정되어있다고 해도 파티션에 실제로 조인되는 레코드가 존재한다는것을 보장하진 않는다.
* 하지만 비트-벡터가 0인 경우엔 파티션에 조인되는 레코드가 없다는 것은 확신할 수 있다.
* 즉, 비트-벡터 필터링을 통해 조인 단계에서 실패할 수밖에 없는 레코드들을 디스크에 기록하지 않고 버릴 수 있다. 

## Build Input 해시 키 값에 중복이 많을 때 발생하는 비효율
* 해시 알고리즘은, 해시 충돌을 얼마나 최소화할 수 있냐에 따라 성능이 좌우된다.
* 따라서 Build Input 해시 키 값에 중복이 많을 것 같은 상황이 어떠한 상황인지 파악하고 개선할 수 있어야 한다.
* 아래 예시에서는 해시 키 중복이 많이 발생한다.
  ```oracle
  select /*+ use_hash(t o) index(t) inde(0) */
         o.상품번호, o.주문번호, o.회원번호
       , o.매도매수구분, o.주문유형코드
       , o.주문수량, o.주문가격
       , t.체결가격, t.체결수량, (t.체결가격 * t.체결수량) 체결금액
  from 주문체결 t, 주문 o
  where t.상품번호 = :상품번호
    and t.체결일자 = :체결일자
    and o.상품번호 = t.상품번호 -- 해시 키
    and o.주문일자 = t.체결일자 -- 해시 키
    and o.주문접수번호 in (t.매도주문접수번호, t.매수주문접수번호) -- 등치조건만 해시 키에 포함되기 때문에, 해시 키에 포함 안됨  
  ```
* 아래와 같이 `주문접수번호`를 해시 키 값으로 사용되게 변경할 수 있다.  
  ```oracle
  select /*+ use_hash(t o) index(t) inde(0) */
         o.상품번호, o.주문번호, o.회원번호
       , o.매도매수구분, o.주문유형코드
       , o.주문수량, o.주문가격
       , t.체결가격, t.체결수량, (t.체결가격 * t.체결수량) 체결금액
  from (select /*+ index(t) */
               상품번호, 체결일자, 체결가격, 체결수량, 매도주문접수번호 주문접수번호
        from 주문체결 t
        union all
        select /*+ index(t) */
               상품번호, 체결일자, 체결가격, 체결수량, 매수주문접수번호 주문접수번호
        from 주문체결 t) t, 주문 o
  where t.상품번호 = :상품번호
    and t.체결일자 = :체결일자
    and o.상품번호 = t.상품번호
    and o.주문일자 = t.체결일자
    and o.주문접수번호 = t.주문접수번호 -- 해시 키 값으로 사용 가능 
  ```

## 해시 조인 사용 기준
* 해시 조인의 성능을 좌우하는 두 가지 중요한 부분이 있다.
  * 한 쪽 테이블이 Hash Area에 담길 정도로 충분히 작아야 한다.
  * Build Input 해시 키 컬럼에 중복 값이 거의 없어야 한다.
* 따라서 해시 조인은 아래와 같은 상황에서 효과적이다.
  * 조인 컬럼에 적당한 인덱스가 없어 NL 조인이 비효율적일 때
  * 조인 컬럼에 인덱스가 있더라도, NL 조인 드라이빙 집합에서 Inner 쪽 집합으로의 조인 액세스량이 많아 Random 액세스 부하가 심할 때
  * 소트 머지 조인하기에는 두 테이블이 너무 커서 소트 부하가 심할 때
  * 수행빈도가 낮고 쿼리 수행 시간이 오래 걸리는 대용량 테이블을 조인할 때
* NL 조인을 무작적 해시조인으로 사용하려고 하면 안된다.
  * NL 조인에 사용되는 인덱스는 영구적으로 유지되며 여러 쿼리에서 공유 및 재사용된다.
  * 하지만 해시 테이블은 단 하나의 쿼리를 위해 생성하며, 조인이 끝나면 소멸하는 구조이다.
  * 따라서 수행빈도가 높은 쿼리에 해시 조인을 사용하면, CPU와 메모리 사용률을 크게 증가시키며 여러 래치 경합이 발생해 시스템 동시성을 떨어뜨린다.
  * 그러므로, OLTP 환경에서 충분히 빠른 쿼리를 더 단축시키려는 목적으로 해시 조인을 쓰는것은 좋지 않다. 

# 조인 순서의 중요성
```oracle
select /*+ use_nl(a b) */ a.납입방법명, b.*
from 납입방법 a, 고객 b
where b.납입방법코드 = a.납입방법코드
```
* 위 예시에서, 이 10만명의 고객을 관리하는 `고객` 테이블과, 3종류의 납입방법을 관리하는 `납입방법` 테이블이 있는 경우의 예시이다.

## 필터 조건이 없을 때
* 두 테이블 모두 `납입방법코드` 단일 인덱스가 있는 경우이다.
* 아래 예시는 `고객` 테이블이 드라이빙하는 경우이다.
  ```oracle
  select /*+ leading(b) use_nl(a) */ a.납입방법명, b.*
  from 납입방법 a, 고객 b
  where b.납입방법코드 = a.납입방법코드
  ```
  * 조인 액세스 시 10만번의 Random 액세스가 발생
  * `납입방법` 테이블로 액세스 할 때 10만번의 Random 액세스가 발생
  
* 아래 예시는 `납입방법` 테이블이 드라이빙하는 경우이다. 
  ```oracle
  select /*+ leading(a) use_nl(b) */ a.납입방법명, b.*
  from 납입방법 a, 고객 b
  where b.납입방법코드 = a.납입방법코드
  ```
  * 조인 액세스 시 3번의 Random 액세스가 발생
  * `고객` 테이블을 액세스할 때 10만번의 Random 액세스가 발생

* 즉, 다른 필터조건이 없는 상황은 작은쪽 집합이 드라이빙하는 것이 유리하다.

## 필터 조건이 있을 때
* 특정 거주 지역엔 전체 중 10%만 해당하며, `고객` 테이블에 `[거주지역]` 인덱스가 있는 경우이다.
* 아래 예시는 `고객` 테이블이 드라이빙하는 경우이다.
  ```oracle
  select /*+ leading(b) use_nl(a) */ a.납입방법명, b.*
  from 납입방법 a, 고객 b
  where b.납입방법코드 = a.납입방법코드
    and b.거주지역 = '부산'
  ```
  * `[거주지역]` 인덱스를 통해 `고객` 테이블을 액세스 시 1만번의 Random 액세스가 발생
  * 조인 액세스 시 1만번의 Random 액세스가 발생
  * `납입방법` 테이블로 액세스 할 때 1만번의 Random 액세스가 발생
* 아래 예시는 `납입방법` 테이블이 드라이빙하는 경우이다.
  ```oracle
  select /*+ leading(a) use_nl(b) */ a.납입방법명, b.*
  from 납입방법 a, 고객 b
  where b.납입방법코드 = a.납입방법코드
    and b.거주지역 = '부산'
  ```
  * 조인 액세스 시 3번의 Random 액세스가 발생
  * `고객` 테이블을 액세스할 때 10만번의 Random 액세스가 발생
  * 그 후, 조건에 의해 90% 가량이 버려지므로 비효율 발생  
* 아래 예시는 `납입방법` 테이블이 드라이빙하는 경우인데, `고객` 테이블에 `[납입방법코드 + 거주지역]` 인덱스가 있는 경우이다.
  ```oracle
  select /*+ leading(a) use_nl(b) */ a.납입방법명, b.*
  from 납입방법 a, 고객 b
  where b.납입방법코드 = a.납입방법코드
    and b.거주지역 = '부산'
  ```
  * `[납입방법코드 + 거주지역]` 인덱스로 인해 10003번의 Random 액세스가 발생

## 소트 머지 조인과 해시 조인의 조인 순서
* 소트 머지 조인은 PGA상에 정렬된 집합을 통해 조인 액세스가 일어나기 때문에, Random 액세스 발생량 보다는 소트 부하에 의해 성능이 결정된다.
  * 디스크 소트가 발생할 정도의 큰 테이블일 경우 큰 테이블을 드라이빙하는 것이 더 빠르다.
  * 메모리 소트 방식으로 조인할 때에는 작은 쪽 테이블을 드라이빙하는 것이 조금 더 빠르다.
* 해시 조인은 Hash Area에 Build Input을 모두 채울 수 있느냐가 관건이기 때문에, 작은 쪽 테이블을 드라이빙 하는것이 유리하다.

# Outer 조인
## Outer NL 조인
* NL 조인은 특성상 Outer 조인할 때 방향이 한 쪽으로 고정된다.
* Outer 기호 `(+)`가 붙지 않은 테이블이 항상 드라이빙 테이블로 선택된다.
  * leading 힌트를 이용해 순서를 바꾸려 해도 안된다.
* 불필요한 Outer 조인이 발생하지 않도록 주의해야 한다.

### ERD 표기를 따르는 SQL 개발의 중요성
* SQL을 작성할 때, 각 송성의 Null 값 허용 여부를 반드시 확인해야 하고, 엔티티 간 관계를 해석할 때도 카디널리티만 보지 말고 Optionality를 반드시 따져봐야 한다.
* 즉 Outer 조인이 필요하지 않은 상황에서 굳이 Outer 조인을 할 필요는 없으며, 괜히 성능만 안좋아질 수 있다.

## Outer 소트 머지 조인
* Outer 소트 머지 조인도 처리방향은 한쪽으로 곶어되며, Outer 기호 `(+)`가 붙지 않은 테이블이 항상 드라이빙 테이블로 선택된다.
  * leading 힌트를 이용해 순서를 바꾸려 해도 안된다.

## Outer 해시 조인
* Outer 해시 조인도 9i까지는 방향이 고정되었고, Outer 기호 `(+)`가 붙지 않은 테이블이 항상 Build Input으로 선택된다.
* Outer 해시 조인은 순서가 고정되다 보니, 대용량 테이블을 해시 테이블로 빌드해야 하는 상황이 생기기도 했다.
* 이러한 문제를 해결하기 위해 10g에서 Right Outer 해시 조인을 도입했다.

## Full Outer 조인
* 아래는 고객별 입금액과 출금액을 같이 집계하는 예시이다.
  ```oracle
  select a.고객ID, a.입금액, b.출금액
  from (select 고객ID, sum(입금액) 입금액 from 입금 group by 고객ID) a
     , (select 고객ID, sum(출금액) 출금액 from 출금 group by 고객ID) b
  where b.고객ID(+) = a.고객ID
  union all
  select 고객ID, null, 출금액
  from (select 고객ID, sum(출금액) 출금액 from 출금 group by 고객ID) a
  where not exists (select 'x' from 입금 where 고객ID = a.고객ID);
  ```
  ```
  ---------------------------------------
  | Id  | Operation              | Name |
  ---------------------------------------
  |   0 | SELECT STATEMENT       |      |
  |   1 |  UNION-ALL             |      |
  |   2 |   HASH JOIN OUTER      |      |
  |   3 |    VIEW                |      |
  |   4 |     HASH GROUP BY      |      |
  |   5 |      TABLE ACCESS FULL | 입금  |
  |   6 |    VIEW                |      |
  |   7 |     HASH GROUP BY      |      |
  |   8 |      TABLE ACCESS FULL | 출금  |
  |   9 |   HASH GROUP BY        |      |
  |  10 |    HASH JOIN ANTI      |      |
  |  11 |     TABLE ACCESS FULL  | 출금  |
  |  12 |     TABLE ACCESS FULL  | 입금  |
  ---------------------------------------
  ```
  * 위의 예시는 내부적으로 Left Outer 조인 + Union All + Anti 조인방식을 사용한다.
* 9i부터는 아래와 같이 Full Outer 조인할 수 있도록 ANSI 구문을 지원하기 시작했다.
  ```oracle
  select nvl(a.고객ID, b.고객ID) 고객ID, a.입금액, b.출금액
  from (select 고객ID, sum(입금액) 입금액 from 입금 group by 고객ID) a
        full outer join
       (select 고객ID, sum(출금액) 출금액 from 출금 group by 고객ID) b
     on a.고객ID = b.고객ID; 
  ```
  ```
  -------------------------------------------
  | Id  | Operation                  | Name |
  -------------------------------------------
  |   0 | SELECT STATEMENT           |      |
  |   1 |  VIEW                      |      |
  |   2 |   UNION-ALL                |      |
  |   3 |    HASH JOIN OUTER         |      |
  |   4 |     VIEW                   |      |
  |   5 |      HASH GROUP BY         |      |
  |   6 |       TABLE ACCESS FULLL   | 입금  |
  |   7 |     VIEW                   |      |
  |   8 |      HASH GROUP BY         |      |
  |   9 |       TABLE ACCESS FULL    | 출금  |
  |  10 |    HASH GROUP BY           | 입금  |
  |  11 |     FILTER                 | 입금  |
  |  12 |      TABLE ACCESS FULL     | 출금  |
  |  13 |      SORT GROUP BY NOSORT  |      |
  |  14 |        TABLE ACCESS FULL   | 입금  |
  -------------------------------------------
  ```
  * 위 예시 또한 내부적으로 Left Outer 조인 + Union All + Anti 조인방식을 사용한다.
  * 쿼리만 간단해졌고, `입금`과 `출금` 테이블을 각각 두번씩 액세스하는 비효율이 있다.
* 11g에서 Native Hash Full Outer 조인이 생겨났고, 필요 시 10.2.0.4 버전에서도 특정 파라미터를 조정해 해당 기능을 사용할 수 있다.
  ```oracle
  select nvl(a.고객ID, b.고객ID) 고객ID, a.입금액, b.출금액
  from (select 고객ID, sum(입금액) 입금액 from 입금 group by 고객ID) a
        full outer join
       (select 고객ID, sum(출금액) 출금액 from 출금 group by 고객ID) b
     on a.고객ID = b.고객ID;
  ```
  ```
  -----------------------------------------------
  | Id  | Operation                  | Name     |
  -----------------------------------------------
  |   0 | SELECT STATEMENT           |          |
  |   1 |  VIEW                      | VW_FOJ_0 |
  |   2 |   HASH JOIN FULL OUTER     |          |
  |   4 |    VIEW                    |          |
  |   5 |     HASH GROUP BY          |          |
  |   6 |      TABLE ACCESS FULLL    | 입금      |
  |   7 |    VIEW                    |          |
  |   8 |     HASH GROUP BY          |          |
  |   9 |      TABLE ACCESS FULL     | 출금      |
  -----------------------------------------------
  ```
  * 각 테이블을 한번만 액세스하며, `입금액`이 null인 레코드가 마지막에 출력된다.

* 아래와 같이 Union All 을 이용해 Full Outer 조인을 할 수 있다.
  ```oracle
  select 고객ID, sum(입금액) 입금액, sum(출금액) 출금액
  from (
    select 고객ID, 입금액, to_number(null) 출금액
    from 입금
    union all
    select 고객ID, to_number(null 입금액, 출금액)
    from 출금
  )
  group by 고객ID;
  ```
  ```
  -------------------------------------------
  | Id  | Operation                  | Name |
  -------------------------------------------
  |   0 | SELECT STATEMENT           |      |
  |   1 |  HASH GROUP BY             |      |
  |   2 |   VIEW                     |      |
  |   4 |    UNION-ALL               |      |
  |   5 |     TABLE ACCESS FULLL     | 입금  |
  |   6 |     TABLE ACCESS FULL      | 출금  |
  -----------------------------------------------
  ```
  
# 스칼라 서브쿼리를 이용한 조인
## 스칼라 서브쿼리
* 쿼리에 내장된 또다른 쿼리 블록을 서브쿼리라고 하는데, 함수처럼 한 레코드당 정확히 하나의 값만 리턴하는 서브쿼리를 스칼라 서브쿼리라고 한다.
* 주로 select-list에서 사용되지만, 몇 가지 예외사항만 빼면 컬럼이 올 수 있는 대부분 위치에서 사용 가능하다.

## 스칼라 서브쿼리의 캐싱 효과
* 오라클에서는, 스칼라 서브쿼리 수행횟수를 최소화하려고 그 입력 값과 출력 값을 내부 캐시에 저장해둔다. (Query Execution Cache)
* 이로 인해, 반복 수행되는 함수 때문에 쿼리 성능이 크게 저하될 때에는 스칼라 서브쿼리를 덧씌워 호출 횟수를 줄일 수 있다.
* 스칼라 서브쿼리의 캐싱 효과는, 입력 값의 종류가 소수여서 해시 충돌 가능성이 적은 상황에서만 효과가 있다.
  * 반대의 경우엔 캐시를 확인하는 비용 때문에 성능은 저하되고 CPU 사용률이 높아진다.
    * 입력 값과 출력 값을 빠르게 저장하고 찾기 위해 해싱 알고리즘을 사용한다.
  * 또한 스칼라 서브쿼리를 사용하면 NL 조인 시 Inner 쪽 인덱스와 테이블에서 나타나는 버퍼 Pinning 효과가 사라진다.

## 두 개 이상의 값을 리턴하고 싶을 때
* 스칼라 서브쿼리에서의 큰 제약은 두 개 이상의 값을 반환할 수 없다는 제약이다.
* 이로 인해 아래와같은 방식들을 사용할 수 있다.
  1. 여러 문자열로 합쳐 한번에 가져오고 바깥에서 분리하는 방식
  2. 오브젝트 TYPE을 사용하는 방식
     * TYPE을 미리 선언해두어야 하는 불편함이 있다.
  3. 인라인 뷰를 사용하는 방식
     * 뷰가 머징되지 않았을 때 비효율이나, 뷰가 머징될 때 상황에 따라 부분범위처리가 안되는 케이스가 있다.
     * 하지만 11g이후에선 조인 조건 Pushdown 기능이 잘 작동하기 때문에 마음편히 사용할 수 있다.

# 조인을 내포한 DML 튜닝
## 수정가능 조인 뷰 활용
### 전통적인 방식의 UPDATE
* 아래는 update문 예시이다.
    ```oracle
  update 고객 c
  set (최종거래일시, 최근거래횟수, 최근거래금액) = 
      (select max(거래일시), count(*), sum(거래금액)
       from 거래
       where 고객번호 = c.고객번호
         and 거래일시 >= trunc(add_months(sysdate, -1)))
  where exists (select 'x' from 거래
                where 고객번호 = c.고객번호
                  and 거래일시 >= trunc(add_months(sysdate, -1)))
  ```
* 총 `고객` 수가 아주 많다면 Exists 서브쿼리를 해시 세미조인으로 유도하는 것을 고려할 수 있다.
  ```oracle
  update 고객 c
  set (최종거래일시, 최근거래횟수, 최근거래금액) = 
      (select max(거래일시), count(*), sum(거래금액)
       from 거래
       where 고객번호 = c.고객번호
         and 거래일시 >= trunc(add_months(sysdate, -1)))
  where exists (select /*+ unnest hash_sj */ 'x' from 거래
                where 고객번호 = c.고객번호
                  and 거래일시 >= trunc(add_months(sysdate, -1)))
  ```
* 한달 이내 `거래`를 발생시킨 `고객`이 많아 UPDATE 발생량이 많다면 아래와 같이 변경하는 것을 고려할 수 있다.
  ```oracle
  update 고객 c
  set (최종거래일시, 최근거래횟수, 최근거래금액) = 
      (select nvl(max(거래일시), c.최종거래일시)
            , decode(count(*), 0, c.최근거래횟수, count(*))
            , nvl(sum(거래금액), c.최근거래금액)
       from 거래
       where 고객번호 = c.고객번호
         and 거래일시 >= trunc(add_months(sysdate, -1)))
  ```
  * 하지만 모든 레코드에 LOCK이 걸리는 것은 물론, 이전과 같은 값으로 갱신되는 비중이 높을수록 Redo 로그 발생량이 증가해 오히려 비효율적일 수 있다.
* 즉, 다른 테이블과 조인이 필요한 경우 전통적인 UPDATE문을 사용하면 비효율을 완전히 없앨 순 없다.

### 수정가능 조인뷰 활용
* 아래와 같이 수정가능 조인 뷰를 활용하면 참조 테이블과 두 번 조인하는 비효율을 없앨 수 있다.
  ```oracle
  update
  (select /*+ ordered use_hash no_merge(t) */
          c.최종거래일시, c.최근거래횟수, c.최근거래금액
        , t.거래일시, t.거래횟수, t.거래금액
   from (select 고객번호
              , max(거래일시) 거래일시, count(*) 거래횟수, sum(거래금액) 거래금액
         from 거래
         where 거래일시 >= trunc(add_months(sysdate, -1))
         group by 고객번호) t
       , 고객 c
   where c.고객번호 = t.고객번호
  )
  set 최종거래일시 = 거래일시
    , 최근거래횟수 = 거래횟수
    , 최근거래금액 = 거래금액
  ```

* 조인 뷰는 FROM 절에 두 개 이상 테이블을 가진 뷰를 의미하며, 수정가능 조인뷰는 말 그대로 입력, 수정, 삭제가 허용되는 조인뷰를 의미한다.
* 조인뷰에서 DML이 허용되려면, 그 테이블이 키 보존 테이블 이어야 한다.

### 키 보존 테이블?
* 키 보존 테이블이란 조인된 결과집합을 통해서도 중복값 없이 Unique하게 식별이 가능한 테이블을 말한다.
* 즉, 뷰에 rowid를 제공하는 테이블을 의미하며, 보통 1쪽(Unique/PK 보장)집합이 키 보존 테이블이 된다.

### 수정가능 조인 뷰 제약 회피
```oracle
update
(select d.deptno
      , d.avg_sal as d_avg_sal
      , e.avg_sal as e_avg_sal
 from (select deptno, round(avg(sal), 2) avg_sal 
       from emp 
       group by deptno) e
    , dept d
 where d.deptno = e.deptno)
set d_avg_sal = e.avg_sal
```
* 위 예시는 11g이하 버전에서 ORA-01779 에러가 발생한다.
* 이럴 경우엔 10g에선 `bypass_ujvc` 힌트를 이용해 제약을 회피할 수 있다.
  * `bypass_ujvc`는 Updatable Join View Check를 생략하라고 옵티마이저에 지시하는 힌트이다.
* 11g부터는 이 힌트를 사용할 수 없기 때문에 위 예시는 MERGE문으로 변경해줘야 한다.
  * `bypass_ujvc` 힌트 사용만 중단되었고, 11g 이후에서도 수정가능 조인 뷰는 사용할 수 있다.
  * 12c부터는 수정가능 조인 뷰가 개선되었고 위 예시는 힌트없어도 잘 동작한다.

## Merge문 활용
* DW에서 가장 흔히 발생하는 오퍼레이션은, 기간계 시스템에서 가져온 신규 트랜잭션 데이터를 반영하여 두 시스템 간 데이터를 동기화시키는 작업이다.
1) 전일 발생한 변경데이터를 기간계 시스템으로부터 추출(Extraction)
```oracle
create table customer_delta
as
select * from customer
where mod_dt >= trunc(sysdate) - 1
  and mod_dt < trunc(sysdate)
```
2) CUSTOMER_DELTA 테이블을 DW 시스템으로 전송(Transportation)
3) DW 시스템으로 적재(Loading)
```oracle
merge into customer t 
using customer_delta s 
  on (t.cust_id = s.cust_id)
when matched then 
  update set t.cust_nm = s.cust_nm, t.email = s.email, t.tel_no = s.tel_no, t.addr = s.addr, t.reg_dt = s.reg_dt
when not matched then 
  insert (cust_id, cust_nm, email, tel_no, region, addr, reg_dt) 
  values (s.cust_id, s.cust_nm, s.email, s.tel_no, s.region, s.addr, s.reg_dt);
```
* 여기서 3번 데이터 적재 작업을 효과적으로 처리하기 위해 오라클 9i부터 merge into문을 지원하기 시작했다.

### Optional Clauses
* 10g부터는 update와 insert를 선택적으로 처리할 수 있다.
* 이 기능을 통해, 아래와 같이 수정가능 조인 뷰 기능을 대체할 수 있게 되었다.
  ```oracle
  merge into dept d
  using (select deptno, rount(avb(sal), 2) avg_sal from emp group by deptno) e
  on (d.deptno = e.deptno)
  when matched then
    update set d.avg_sal = e.avg_sal; 
  ```

### Conditional Operations
* 10g부터는 on절에 기술한 조인문 외에 아래와 같이 추가로 조건절을 기술할 수 있다.
  ```oracle
  merge into customer t using customer_delta s on (t.cust_id = s.cust_id)
  when matched then 
    update set t.cust_nm = s.cust_nm, t.email = s.email, t.tel_no = s.tel_no, t.addr = s.addr, t.reg_dt = s.reg_dt
    where reg_dt >= to_date('20000101', 'yyyymmdd') -- 추가 조건
  when not matched then 
    insert (cust_id, cust_nm, email, tel_no, region, addr, reg_dt) 
    values (s.cust_id, s.cust_nm, s.email, s.tel_no, s.region, s.addr, s.reg_dt)
    where reg_dt < trunc(sysdate); -- 추가 조건
  ```

### DELETE Clause
* 10g부터는 이미 저장된 데이터를 조건에 따라 지울 수 있다.
```oracle
merge into customer t using customer_delta s on (t.cust_id = s.cust_id)
when matched then
  update set t.cust_nm = s.cust_nm, t.email = s.email, t.tel_no = s.tel_no, t.addr = s.addr, t.reg_dt = s.reg_dt
  delete where t.withdraw_dt is not null -- 탈퇴일시가 null이 아닌 레코드 삭제
when not matched then 
  insert (cust_id, cust_nm, email, tel_no, region, addr, reg_dt) 
  values (s.cust_id, s.cust_nm, s.email, s.tel_no, s.region, s.addr, s.reg_dt);
```
* 주의해야 할 점은, update가 이루어진 결과 이후 delete문이 동작한다.

## 다중 테이블 Insert 활용
* 오라클 9i 부터는 조건에 따라 여러 테이블에 insert하는 다중 테이블 insert문을 제공한다.
```oracle
insert first
when 구분 = 'A' then
  into 청구보험당사자(당사자id, 접수일자, 접수순번, 담보구분, 청구순번)
  values (당사자id, 접수일자, 접수순번, 담보구분, 청구순번)
when 구분 = 'B' then
  into 자동차사고접수당사자(당사자id, 접수일자, 접수순번, 담보구분, 청구순번)
  values (당사자id, 접수일자, 접수순번, 담보구분, 청구순번)
select a.구분, a.당사자id, a.접수순번, a.담보구분, a.청구순번
from (
    select 'A' 구분, 당사자id, 접수일자, 접수순번, 담보구분, 청구순번
    from 청구보험당사자_임시
    union all
    select 'B' 구분, 당사자id, 접수일자, 접수순번, 담보구분, 청구순번
    from 가사고접수당사자_임시
    where 당사자구분 not in ('4' , '5', '6')
    ) a, 거래당사자 b
where a.당사자id = b.당사자id;
```

# 고급 조인 테크닉
## 누적 매출 구하기
```oracle
create table 월별지점매출
as
select deptno 지점
     , row_number() over (partition by deptno order by empno) 판매월
     , round(dbms_random.value(500, 1000)) 매출
from emp
order by deptno;
```
* 아래는 오라클의 분석함수를 이용하여 지점별 누적매출을 구하는 쿼리이다.
  ```oracle
  select 지점, 판매월, 매출
       , sum(매출) over (partition by 지점 order by 판매월
              range between unbounded preceding and current row) 누적매출
  from 월별지점매출
  ```
* 아래는 부등호 조인을 통해 지점별 누적매출을 구하는 쿼리이다.
  ```oracle
  select t1.지점, t1.판매월, min(t1.매출) 매출, sum(t2.매출) 누적매출
  from 월별지점매출 t1, 월별지점매출 t2
  where t2.지점 = t1.지점
    and t2.판매월 <= t1.판매월
  group by t1.지점, t1.판매월
  order by t1.지점, t1.판매월
  ```

## 선분이력 끊기
```oracle
create table 월도 (기준월, 시작일자, 종료일자)
as
select '2009/06', '2009/06/01', '2009/06/30' from dual union all
select '2009/07', '2009/07/01', '2009/07/31' from dual union all
select '2009/08', '2009/08/01', '2009/08/31' from dual union all
select '2009/09', '2009/09/01', '2009/09/30' from dual union all
select '2009/10', '2009/10/01', '2009/10/31' from dual;

create table 선분이력 (상품번호, 시작일자, 종료일자, 데이터)
as
select 'A', '2009/07/13', '2009/08/08', 'A1' from dual union all
select 'A', '2009/08/09', '2009/08/20', 'A2' from dual union all
select 'A', '2009/08/21', '2009/10/07', 'A3' from dual;
```

* 아래와 같은 쿼리로 조회하면, 월도에 판매중이던 상품들을 조회할 수 있다.
  ```oracle
  select a.기준월, b.시작일자, b.종료일자, b.상품번호, b.데이터
  from 월도 a, 선분이력 b
  where b.시작일자 <= a.종료일자
    and b.종료일자 >= a.시작일자
  order by a.기준월, b.시작일자;
  ```

* 최종적으로 아래와 같은 쿼리로 월도 기준으로 선분이력을 끊을 수 있다.
  ```oracle
  select b.상품번호
       , greatest(a.시작일자, b.시작일자) 시작일자
       , least(a.종료일자, b.종료일자) 종료일자
       , b.데이터
  from 월도 a, 선분이력 b
  where b.시작일자 <= a.종료일자
    and b.종료일자 >= a.시작일자;
  ```

## 데이터 복제를 통한 소계 구하기
* 부등호 조인을 이용한 데이터 복제 외에, 카티션 곱을 발생시켜 복제하는 방법이 있다.
```oracle
select deptno 부서번호
     , decode(no, 1, to_char(empno), 2, '부서계') 사원번호
     , sum(sal) 급여합, round(avg(sal)) 급여평균
from emp a, (select rownum no from dual connect by level <= 2)
group by deptno, no, decode(no, 1, to_char(empno), 2, '부서계')
order by 1, 2
```
* p307 ~ p310 참고

## 상호배타적 관계의 조인
* 자식 엔티티가 두 개 이상인 부모 엔티티중, 하나와만 관계를 맺는 경우를 상호배타적 관계라고 한다.

1. 부모에서 두 자식 컬럼을 따로 두고, 레코드별로 둘 중 하나의 컬럼에만 값을 입력하는 경우
   * 아래와 같이 Outer 조인으로 간단하게 조회 가능하다.
     ```oracle
     select /*+ ordered use_nl(b) use_nl(c) use_nl(d) */
            a.주문번호, a.결제일자, a.결제금액
          , nvl(b.온라인권번호, c.실권번호) 상품권번호
          , nvl(b.발행일시, c.발행일시) 발행일시   
     from 상품권결제 a, 온라인권 b, 실권 c, 실권발행 d
     where a.결제일자 between :dt1 and :dt2
       and b.온라인권번호(+) = a.온라인권번호
       and c.실권번호(+) = a.실권번호
       and d.발행번호(+) = c.발행번호;
     ```
2. 부모에서 구분 컬럼을 두고 사용하는 경우
   * union all 을 사용하여 조회 가능하다.
     ```oracle
     select *
     from 상품권결제 x, 온라인권 y
     where x.상품권구분 = '1'
       and x.결제일자 between :dt1 and :dt2
       and y.온라인권번호 = x.상품권번호
     union all
     select *
     from 상품권결제 x, 실권 y, 실권발행 z
     where x.상품권구분 = '2'
       and x.결제일자 between :dt1 and :dt2
       and y.실권번호 = x.상품권번호
       and z.발행번호 = y.발행번호
     ```
   * 아래는 `결제일자`만으로 구성된 인덱스를 이용할 경우에서의 비효율을 제거한 쿼리이다.
     ```oracle
     select /*+ ordered use_nl(b) use_nl(c) use_nl(d) */
            a.주문번호, a.결제일자, a.결제금액
          , nvl(b.온라인번호, c.실권번호) 상품권번호
          , nvl(b.발행일시, d.발행일시) 발행일시
     from 상품권결제 a, 온라인권 b, 실권 c, 실권발행 d
     where a.결제일자 between :dt1 and :dt2
       and b.온라인권번호(+) = decode(a.상품권구분, '1', a.상품권번호)
       and c.실권번호(+) = decode(a.상품권구분, '2', a.상품권번호)
       and c.발행번호(+) = c.발행번호
     ```
     
## 최종 출력 건에 대해서만 조인하기
* 흔히 보이는 페이징 쿼리에서, 가능하다면 페이징이 완료된 후 조인하는 방식의 예시이다.
* 페이징 쿼리에서 count쿼리가 부담이되어 반정규화를 했다면, 페이징 완료 후 count하는 쿼리로 변경해보고 그래도 성능이 안나오면 반정규화를 해야 한다.
* p312 ~ p318 참고

## 징검다리 테이블 조인을 이용한 튜닝
* 조인부하로 인해 문제가 생기는 예시가 있는데, 이럴 때 징검다리 테이블을 조인하여 조인부하를 획기적으로 줄일 수 있다.
* 아래와 같이 징검다리 테이블을 한번 더 조인하도록 만들어 조인성능을 올릴 수 있다.
  ```oracle
  select /*+ ordered use_hash(r_brdg) rowid(s) rowid(r) */
         c.고객번호, s.서비스번호, s.서비스구분코드, s.서비스상태코드
       , s.서비스상태변경코드, r.할인시작일자, r.할인종료일자
  from 고객 c
     , 서비스 s_brdg, 서비스요금할인 r_brdg
     , 서비스 s, 서비스요금할인 r
  where c.주민법인등록번호 = :ctz_biz_num
    and s_brdg.명의고객번호 = c.고객번호
    and r_brdg.서비스번호 = s_brdg.서비스번호
    and r_brdg.서비스상품그룹 = '3001'
    and r_brdg.할인기간코드 = '15'
    and s.rowid = s_brdg.rowid
    and r.rowid = r_brdg.rowid
  order by r.할인종료일자 desc, s.서비스번호
  ```
  * 실행계획 상에서, 테이블 액세스 시 `Table Aceess By User Rowid`가 보인다.
    * 즉, 테이블을 두 번씩 액세스하도록 쿼리를 작성했지만 실제 처리 일량은 한 번만 액세스한 것과 같다.
* p319 ~ p323 참고

### 인조식별자의 장단점
1) 장점
   * 제약조건을 위해 사용되는 인덱스 저장공간이 최소화된다.
   * 조인연산을 위한 CPU 사용량이 조금 줄 수 있다.
2) 단점
   * 조인 연산횟수와 블록I/O가 증가해 리소스가 낭비될 수 있다.
   * 데이터 모델을 이해하기 어려워진다. (실질 식별자를 찾기 어려워짐)

## 점이력 조회
* 점이력은 데이터 변경이 발생할 때마다 변경일자와 함께 새로운 이력 레코드를 쌓는 방식이다.
* 가장 간단하게는 아래와 같이 조회 가능하다.
  ```oracle
  select a.고객명, a.거주지역, a.주소, a.연락처, b.연체금액
  from 고객 a, 고객별연체이력 b
  where a.가입회사 = 'C70'
    and b.고객번호 = a.고객번호
    and b.변경일자 = (select max(변경일자)
                    from 고객별연체이력
                    where 고객번호 = a.고객번호
                      and 변경일자 <= a.서비스만료일)
  ```
* 아래와 같이 스칼라 서브쿼리로 변환하면 인덱스를 두 번 액세스하지 않아도 되기 때문에 I/O를 그만큼 줄 수 있다.
  ```oracle
  select a.고객명, a.거주지역, a.주소, a.연락처
       , (select /*+ index_desc(b 고객별연체이력_idx01 */ 연체금액
          from 고객별연체이력 b
          where b.고객번호 = a.고객번호
            and b.변경일자 <= a.서비스만료일
            and rownum <= 1) 연체금액
  from 고객 a
  where 가입회사 = 'C70'
  ```
  * 만약 2개 이상의 컬럼을 읽어야 하는 경우엔 서브쿼리에서 컬럼 문자열을 연결하고 메인쿼리에서 잘라쓰는 방법을 사용해야 한다.
  * 아니면 아래와 같이 스칼라 서브쿼리에서 rowid값만 가져오고 한 번 더 조인하는 방법이 있다.
    ```oracle
    select /*+ ordered use_nl(b) rowid(b) */ a.*, b.연체금액, b.연체개월수
    from (select a.고객명, a.거주지역, a.주소, a.연락처
               , (select /*+ index_desc(b 고객별연체이력_idx01) */ rowid
                  from 고객별연체이력 b
                  where b.고객번호 = a.고객번호
                    and b.변경일자 <= a.서비스만료일
                    and rownum <= 1) rid
          from 고객 a
          where 가입회사 = 'C70') a, 고객별연체이력 b
    where b.rowid = a.rid
    ```
* 아니면 아래와 같이 스칼라 서브쿼리 없이 작성해도 된다.
  ```oracle
  select /*+ ordered use_nl(b) rowid(b) */
         a.고객명, a.거주지역, a.주소, a.연락처, b.연체금액, b.연체개월수
  from 고객 a, 고객별연체이력 b
  where a.가입회사 = 'C70'
    and b.rowid = (select /*+ index(c 고객별연체이력_idx01) */ rowid
                   from 고객별연체이력 c
                   where c.고객번호 = a.고객번호
                     and c.변경일자 <= a.서비스만료일
                     and rownum <= 1)
  ```

### 정해진 시점 기준으로 조회
```oracle
select a.고객명, a.거주지역, a.주소, a.연락처, b.연체금액, b.연체개월수
from 고객 a
   , (select 고객번호, 연체금액, 연체개월수, 변경일자
           , row_number() over (partition by 고객번호 order by 변경일자 desc) no
      from 고객별연체이력
      where 변경일자 <= to_char(sysdate, 'yyyymmdd')) b
where b.고객번호 = a.고객번호
  and b.no = 1
```

## 선분이력 조인
### 과거/현재/미래의 임의 시점 조회
```oracle
select *
from 고객 c, 고객등급변경이력 c1, 전화번호변경이력 c2
where c.고객번호 = 123
  and c1.고객번호 = c.고객번호
  and c2.고객번호 = c.고객번호
  and :dt between c1.시작일자 and c1.종료일자
  and :dt between c2.시작일자 and c2.종료일자
```

### 현재 시점 조회
1. 미래시점 데이터를 미리 입력하지 않는 경우
   ```oracle
   select *
   from 고객 c, 고객등급변경이력 c1, 전화번호변경이력 c2
   where c.고객번호 = 123
     and c1.고객번호 = c.고객번호
     and c2.고객번호 = c.고객번호
     and c1.종료일자 = '99991231'
     and c2.종료일자 = '99991231'
   ```

2. 미래시점 데이터를 미리 입력하는 경우
   ```oracle
   select *
   from 고객 c, 고객등급변경이력 c1, 전화번호변경이력 c2
   where c.고객번호 = 123
     and c1.고객번호 = c.고객번호
     and c2.고객번호 = c.고객번호
     and to_char(sysdate, 'yyyymmdd') between c1.시작일자 and c1.종료일자
     and to_char(sysdate, 'yyyymmdd') between c2.시작일자 and c2.종료일자
   ```
   
## 선분이력 조인 튜닝
|조인 유형 | 데이터상황                        | 튜닝방안                                                                                      
|---|------------------------------|-------------------------------------------------------------------------------------------|
|정해진 시점으로 선분이력과 단순 조인| 조회대상이 많지 않을 때                | 인덱스 순서 조정                                                                                 
| | 조회대상이 많을 때                   | 해시조인 (대상별 이력 레코드가 많아도, Full Scan 비용만 커지며 조인과정에서의 비효율은 없음)                                 |
|Between 조인 | 조회 대상이 많지 않을 때               | 스칼라 서브쿼리 등에 Stopkey 조건을 사용해 인덱스 한 건만 스캔하도록 구현                                             |
| | 조회대상이 많지만 대상 이력 레코드가 많지 않을 때 | 해시 조인 (해시 테이블 탐색 비용이 크지 않음)                                                               |
| | 대상별 이력 레코드가 많을 때             | 월말 시점마다 선분을 끊어주거나, 마스터 데이터 건수가 적으면서 변경이 잦은 경우라면 매일 전체 대상 집합을 새로 저장하는 이력 관리 방식을 고려해볼 수 있다. |

* p337 ~ p354 참고


## 조인에 실패한 레코드 읽기
* 아래 예시는, 케이스에 따라 `지역` 이 공백(`' '`)으로 들어가 있는 상황에서의 예시다. 
  ```oracle
  select /*+ ordered use_nl(r) */
         c.통화시간, c.국가코드, c.지역, r.요금
  from cdr c, cdr_rating r
  where c.통화시간 like '20250315%'
    and (r.국가코드, r.지역) = (select c.국가코드, max(지역)
                              from cdr_rating
                              where 국가코드 = c.국가코드
                                and 지역 in(' ', c.지역));
  ```
  * 여기서 인덱스를 두 번 액세스하지 않고 서브쿼리에서 얻은 rowid로 테이블을 직접 액세스하도록 튜닝할 수 있다.
    ```oracle
    select /*+ ordered use_nl(r) rowid(r) */
           c.통화시간, c.국가코드, c.지역, r.요금
    from cdr c, cdr_rating r
    where c.통화시간 like '20250315%'
      and r.rowid = (select /*+ use_concat(@subq 1) qb_name(subq) ordered_predicates */ rowid
                     from cdr_rating
                     where 국가코드 = c.국가코드
                       and 지역 in(' ', c.지역)
                       and rownum <= 1);
    ```

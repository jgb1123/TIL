# Nested Loops 조인
* NL 조인은 중첩 루프문의 수행 구조를 사용한다.

## 힌트를 이용해 NL 조인을 제어하는 방법
* `ues_nl` 힌트를 사용하여 NL조인을 유도할 수 있다.
  ```oracle
  select /*+ ordered use_nl(B) use_nl(C) use_nl(D) */ *
  from A, B, C, D
  where B.a = A.a
    and C.b = B.b
    and D.c = C.c
  ```
* 아래와 같이 `leading`힌트로 조인 순서를 제어할 수도 있다.
  ```oracle
  select /*+ leading(C, A, D, B) use_nl(A) use_nl(D) use_nl(B) */ *
  from A, B, C, D
  where B.a = A.a
    and C.b = B.b
    and D.c = C.c
  ```
  * 9i까지는 `leading`힌트에 driving table 인자 하나만 입력할 수 있었지만, 10g부터는 여러 테이블을 기술할 수 있도록 개선되었다.
  * 따라서 최근엔 `ordered` 힌트보다 `leading`힌트를 많이 사용한다.
* 아래와 같이 `ordered`나 `leading`힌트를 기술하지 않으면, NL조인을 사용하되 조인 순서는 옵티마이저가 정하게 된다.
  ```oracle
  select /*+ use_nl(A, B, C, D) */ *
  from A, B, C, D
  where B.a = A.a
    and C.b = B.b
    and D.c = C.c
  ```
  
## NL 조인 수행 과정 분석
```oracle
select /*+ ordered use_nl(e) */
       e.empno, e.ename, d.dname, e.job, e.sal
from dept d, emp e
where e.deptno = d.deptno -- 1
  and d.loc = 'SEOUL'     -- 2  
  and d.gb = '2'          -- 3
  and e.sal >= 1500       -- 4
order by sal desc
```

```
pk_dept         : dept.deptno
dept_loc_idx    : dept.loc
pk_emp          : emp.empno
emp_deptno_idx  : emp.deptno
emp_sal_idx     : emp.sal
```  

```
Execution Plan
------------------------------------------------
0     SELECT STATEMENT
1  0    SORT ORDER BY
2  1      NESTED LOOPS
3  2        TABLE ACCESS BY INDEX ROWID DEPT
4  3          INDEX RANGE SCAN DEPT_LOC_IDX
5  2        TABLE ACCESS BY INDEX ROWID EMP
6  5          INDEX RANGE SCAN EMP_DEPTNO_IDX
```
* 위 예시에서 사용되는 인덱스는 `detp_loc_idx`와 `emp_deptno_idx`이며, 조건 비교 순서는 2 -> 3 -> 1 -> 4 순이다.
* 동작 순서는 아래와 같다.
  * `dept_loc_idx` 인덱스로 `dept.loc = 'SEOUL` 조건을 만족하는 레코드를 찾기 위해 범위스캔한다.
  * `dept_loc_idx` 인덱스에서 읽은 rowid를 가지고 `dept` 테이블 액세스 후 `detp.gb = '2'`필터 조건을 만족하는 레코드를 찾는다.
  * `dept` 테이블에서 읽은 `deptno` 값을 가지고 조건을 만족하는 `emp`쪽 레코드를 찾으려고 `emp_deptno_idx` 인덱스를 범위 스캔한다.
  * `dept_loc_idx` 인덱스에서 읽은 rowid를 가지고 `emp`테이블을 액세스해 `sal >= 1500` 필터조건을 만족하는 레코드를 찾는다.
  * `sal` 기준 내림차순 내림차순 정렬 후 결과를 리턴한다.
* 위 예시에서 부하 지점은 아래와 같다.
  * 단일컬럼 인덱스를 `=` 조건으로 스캔했기 때문에, 그만큼 Random 액세스가 발생한다.
    * 만약 많은양의 Random 액세스가 발생하고, `gb = '2'`조건에 의해 필터링되는 비율이 높다면 해당 인덱스에 `gb`컬럼을 추가하는 방안을 고려해야 한다.
  * `emp_deptno_idx` 인덱스 탐색 시, Outer 테이블인 `dept`를 읽고 나서 필터된 결과만큼 조인 액세스가 발생한다.
    * 만약 `emp_deptno_idx`의 높이가 3이면 매 건마다 그만큼의 블록 I/O가 발생(버퍼 Pinning 효과 고려 X)하고 리프블록을 스캔하면서 추가적인 I/O가 발생한다.
  * `emp_deptno_idx` 읽고 `emp` 테이블 액세스 시, Random I/O가 많이 일어난다.
    * `sal >= 1500` 조건에 의해 필터링되는 비율이 높다면, `emp_deptno_idx` 인덱스에 `sal`컬럼을 추가하는 방안을 고려해야 한다.
* OLTP 시스템에서 조인을 튜팅할 때에는, 일반적으로 NL 조인부터 고려해야 한다.
  * 각 단계의 수행 일량을 확인 후, 과도한 Random 액세스가 발생하는 지점을 파악해야 한다.
  * 여러 가지 방안을 검토 후 NL 조인이 효과적이지 못하다면, 해시조인이나 소트머지 조인을 검토해야 한다.

## NL 조인의 특징
* Random 액세스 위주의 조인 방식이기 때문에, 인덱스 구성이 아무리 완벽하더라도 대량의 데이터를 조인할 때에는 매우 비효율적이다.
* 조인을 한 레코드 씩 순차적으로 진행한다.
  * 아무리 대용량 집합이더라도 부분범위 처리가 가능하기 때문에 좋은 응답 속도를 낼 수 있다.
* 다른 조인 방식과 비교했을 때 인덱스 구성 전략이 특히 중요하다.
* 즉, NL 조인은 소량의 데이터를 주로 처리하거나, 부분범위처리가 가능한 온라인 트랜잭션 환경에 적합한 조인 방식이다.

## NL 조인 튜닝 실습
* Outer쪽 인덱스를 수정 해 Random 액세스를 줄이거나, 조인후의 레코드가 적은데 조인 시도 횟수가 많은 경우 조인 순서를 바꾸어 보는 예시이다. 
* p218 ~ p222 참고

## 테이블 Prefetch
* Prefetch는, 디스크 I/O를 수행하려면 비용이 많이 들기 때문에, 한 번 I/O Call이 필요한 시점에 곧이어 읽을 가능성이 큰 블록들을 캐시에 미리 적재해두는 기능이다.
* 오라클 9i 부터는, NL 조인 시 인덱스 rowid에 의한 Inner 테이블 액세스가 Nested Loops 위쪽에 표시되곤 한다.
* 이것은 해당 테이블 액세스 단계에 Prefetch 기능이 적용되었음을 표현하기 위함이다.
```
Execution Plan
------------------------------------------------
0     SELECT STATEMENT Optimizer=ALL_ROWS (Cost=4 Card=14 Bytes=868)
1  0    TABLE ACCESS (BY INDEX ROWID) OF 'EMP' (TABLE) (Cost=1 Card=4 Bytes=128)
2  1      NESTED LOOPS (Cost=4 Card=14 Bytes=868)
3  2        TABLE ACCESS (FULL) OF `DEPT` (TABLE) (Cost=3 Card=4 Bytes=120)
6  5        INDEX (RANGE SCAN) OF 'EMP_DEPTNO_IDX' (INDEX) (Cost=0 Card=5)
```
* `_table_lookup_prefetch_size`파라미터로 테이블Prefetch를 제어할 수 있다.
* Prefetch 기능이 작동할 때, `db file sequential read` 대기 이벤트 대신 `db file parallel reads` 대기 이벤트가 나타난다.
* Prefetch는 Outer쪽 인덱스를 Unique Scan 할 때 작동하지 않으며, 이 경우를 제외하면 새 포맷의 실행계획이 나타날 수 있다.
  * Inner 쪽 Non-Unique 인덱스를 Range Scan할 때는 테이블 실행계획이 항상 나타난다.
  * Inner 쪽 Unique 인덱스를 Non-Unique 조건으로 Range Scan할 때도 테이블 Prefetch 실행계획이 항상 나타난다.
  * Inner 쪽 Unique 인덱스를 Unique 조건으로 액세스할 때도 Prefetch 실행계획이 나타날 수 있다. (p223 ~ p224 참고)
    * 이 때 인덱스는 Range Scan으로 액세스하며, 테이블 Prefetch 실행계획이 안 나타날 때는 Unique Scan으로 액세스한다.

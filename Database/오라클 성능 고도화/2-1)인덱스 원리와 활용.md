# 인덱스 구조
## 범위 스캔
* 인덱스는 키 컬럼 순으로 정렬되어 있기 때문에, 특정 위치에서 스캔을 시작해 검색조건에 일치하지 않는 값을 만나는 순간 멈출 수 있다.
  * 즉, 인덱스는 범위 스캔이 가능하다.
* 테이블의 경우 IOT는 특정 컬럼 순으로 정렬상태를 유지하기 때문에 범위스캔이 가능하지만, IOT를 제외하면 범위스캔은 불가능하다.
  * 일반적인 힙 구조 테이블에서 범위스캔은 불가능하다.

## 인덱스 기본 구조
* 여러 종류의 인덱스 중 가장 일반적으로 사용되는 구조는 B-Tree 구조이다.
  * 루트를 포함한 브랜치 블록에 저장된 엔트리에는, 하위 노드 블록을 찾아가기 위한 DBA(Data Block Address) 정보를 갖고 있다.
  * 리프 블록에는 인덱스 키 컬럼과 함께 해당 테이블 레코드를 찾아가기 위한 주소정보 ROWID를 갖는다.

> LMC(Left Most Child)
> * 브랜치 노드의 각 엔트리는 키 값과 하위 노드를 가리키는 블록 주소를 갖는다.
> * 각 브랜치 노드의 첫 번 째 엔트리는 키 값을 갖지 않는데, 이를 LMC라고 한다.
> * LMC는 명시적인 키 값을 갖지 않더라도, 키 값을 가진 첫 번째 엔트리보다 작은 값의 의미를 갖는다.
> * 즉, 그 브랜치 블록의 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다.

* 리프 노드상의 인덱스 레코드와, 테이블 레코드 간에는 1:1 관계이다. (인덱스의 구성 컬럼이 모두 null인경우는 제외, 클러스터 인덱스인 경우는 1:M)
  * 오라클은 인덱스 구성 컬럼이 모두 null인 레코드는 저장하지 않는다. 
* 리프 노드상의 키 값과 테이블 레코드 키 값은 서로 일치한다.
* 브랜치 노드상의 레코드 개수는 하위 레벨 블록 개수와 일치한다.
* 브랜치 노드상의 키 값은 하위 노드가 갖는 값의 범위를 의미한다.

## 인덱스 탐색
* 인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 구분해 설명할 수 있다.
  * 수평적 탐색 : 범위 스캔
  * 수직적 탐색 : 수평적 탐색을 위한 시작 지점을 찾는 과정
* 특정 조건으로 검색 시 탐색이 어떤식으로 이루어지는지 알아야 한다.


## ROWID 포맷
* rowid에는 데이터파일, 번호, 로우번호 같은 테이블 레코드의 물리적 위치 정보를 포함한다.
* 오라클 7버전 까지
  * 데이터 파일 번호(4자리)
    * 데이터베이스 내에서 유일한 값
  * 블록 번호(8자리)
    * 해당 로우가 저장된 데이트 블록 번호로, 데이터파일 내에서의 상대적 번호
  * 로우 번호(4자리)
    * 블록 내에서 각 로우에 붙여진 일련번호로, 0부터 시작
  * `(블록).(로우).(데이터파일)`의 형태
* 오라클 8버전 이후
  * 데이터 오브젝트 번호(6자리)
    * 데이터베이스 세그먼트를 식별하기 위해 사용되는 데이터 오브젝트 번호
  * 데이터파일 번호(3자리)
    * 로우가 속한 데이터파일 번호로, 테이블스페이스 내에서의 상대적인 파일 번호
  * 블록번호(6자리)
    * 해당 로우가 저장된 데이터 블록 번호로, 데이터파일 내에서의 상대적 번호
  * 로우번호(3자리)
    * 블록 내에서 각 로우에 붙여진 일련번호로, 0부터 시작
  * `(데이터 오브젝트)(데이터파일)(블록)(로우)`의 형태

# 인덱스 기본 원리
## 인덱스 사용이 불가능하거나, 범위 스캔이 불가능한 경우
* 인덱스를 정상적으로 사용할 수 없는 예시
  * 인덱스 컬럼을 조건절에서 가공
    ```oracle
    select * from 업체 where substr(업체명, 1, 2) = '대한';
    ```
  * 부정형 비교를 사용
    ```oracle
    select * from 고객 where 직업 <> '학생';
    select * from 사원 where 부서코드 is not null;
    ```
  * 단일컬럼 인덱스인 경우 `is null` 조건 사용 (결합 인덱스일 때에는 구성컬럼이 모두 `null` 조건)
    ```oracle
    select * from emp where empno is null;
    ```
    * 위 예시에서도 옵티마이저가 인덱스를 사용하는 경우가 있긴 하다.
    * `empno`컬럼에 `not null` 제약이 있다면, 어차피 테이블을 스캔해도 해당 조건을 만족하는 레코드가 없음을 알기 때문에 인덱스 스캔을 통해 공집합을 리턴하기 때문이다.
    * 하지만 애초에 `not null` 컬럼을 `is null` 조건으로 검색하는 것 자체가 모순이다.

## 인덱스 컬럼의 가공
* 인덱스 컬럼을 가공하면 정상적인 `Index Range Scan`이 불가능하다.
* 특정 상황에서는 함수기반 인덱스(FBI) 생성을 고려해볼 수도 있다.

## 묵시적 형변환
* 묵시적 형변환으로, 인덱스 컬럼이 가공되어 인덱스를 사용하지 못하는 상황이 발생할 수 있다.
  * 이를 확인하고 파악하려면, 옵티마이저에 의해 일어나는 내부적인 형변환 원리를 이해하고 있어야 하고, 조인 컬럼의 데이터타입을 일일이 따져봐야 한다.
* 또한 묵시적 형변환으로, 아예 쿼리 수행 도중 에러가 발생하거나 잘못된 결과가 나오는 상황도 생긴다.
  ```oracle
  select round(avg(sal)) avg_sal
       , max(sal) max_sal 
       , max(decode(job, 'PRESIDENT', NULL, sal)) max_sal2  -- 4번째 인자 sal을 문자열로 변환했을 때 가장 큰 값을 출력하게 됨
                                                             
  from scott.emp
  ```
  * `decode`로 4번째 인자를 출력될 때, 데이터 타입은 3번째 인자의 타입으로 결정되며, `decode`는 3번째 인자가 `null`이면 `varchar2`로 취급한다.
  * 즉, 묵시적 형변환으로 인한 오류가 발생하는 예시이다.
* 묵시적 형변환 기능에 절대 의존해선 안된다.
  * 필요하다면 항상 명시적으로 변환 함수를 사용해야 한다.

# 다양한 인덱스 스캔 방식
## Index Range Scan
* 인덱스 루트 블록에서 리프 블록까지 수직적 탐색 후, 리프블록을 필요한 범위만 스캔하는 방식이다.
* B-Tree 인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식이다.
* `Index Range Scan`이 가능하게 하려면 인덱스를 구성하는 선두 컬럼이 조건절에 사용되어야 한다.
  * 그렇지 못한 상황에서 인덱스를 사용하도록 힌트로 강제한다면, `Index Full Scan` 방식으로 처리된다.
* `Index Range Scan` 과정을 거쳐 생성된 결과 집합은 인덱스 컬럼 순으로 정렬된 상태가 되기 때문에 `sort order by` 연산을 생략하거나 `min/max` 값을 빠르게 추출해낼 수 있다.
* 실행계획 상에서 `Index Range Scan`이 나타난다고해서 항상 빠른 속도를 보장하는 것은 아니며, 인덱스를 스캔하는 범위를 줄이고 테이블로 액세스하는 횟수를 줄이는게 중요하다.

## Index Full Scan
* 수직적 탐색 없이(최초 1번은 일어남), 인덱스 리프블록을 처음부터 끝까지 수평적으로 탐색하는 방식이다.
* 보통은 데이터 검색을 위한 최적의 인덱스가 없을 때 차선으로 선택된다.
* 상황에 따라, `Index Full Scan`이 전체적인 I/O면에서 유리할 수도 있다. 
  * 인덱스 선두 컬럼이 조건절에 없으면, 옵티마이저는 우선적으로 `Table Full Scan`을 고려한다.
  * 하지만 대용량 테이블이어서 `Table Full Scan`의 부담이 크다면 상황에 따라 옵티마이저는 인덱스를 활용하는 방법을 생각해볼 수 있는데, 데이터 저장 공간은, 보통 인덱스가 차지하는 면적이 테이블보다 훨씬 적기 때문이다.
  * 따라서 **인덱스 스캔 단계에서 대부분의 레코드를 필터링할 수 있고, 일부에 대해서만 테이블 액세스가 발생할 수 있다면** 전체적인 I/O에서 더 유리해진다.
* `Index Full Scan`은 `Index Range Scan`과 마찬가지로, 결과 집합이 인덱스 컬럼 순으로 정렬되므로 `Sort Order By` 연산을 생략할 목적으로 사용될 수 있다.

## Index Unique Scan
* 수직적 탐색만으로 데이터를 찾는 스캔 방식이다.
* Unique 인덱스를 통해 `=`조건으로 탐색하는 경우에 작동한다.
  * 이 경우엔 데이터 한 건을 찾는 순간 더 이상 탐색할 필요가 없기 때문이다.

## Index Skip Scan
* 루트 또는 브랜치 블록에서 읽은 컬럼 값 정보를 이용해 조건에 부합하는 레코드를 포함할 가능성이 있는 리프 블록만 골라서 액세스 하는 방식이다.
* **조건절에 빠진 선두 컬럼의 Distinct Value 개수가 적고, 후행 컬럼의 Distinct Value 개수가 많을 때 유용**하다.
* Skip에는 버퍼 `Pinning`이 활용된다.
  * 브랜치 블록 버퍼를 `Pinning` 한 채로 리프 블록을 방문했다가 다시 브랜치 블록으로 돌아와 다음 방문할 리프 블록을 찾는 과정을 반복한다.
  * 브랜치 블록 간에는 서로 연결할 수 있는 주소 정보가 없기 때문에 하나의 브랜치 블록을 모두 처리하면 그 상위 노드를 재방문한다.
  * 루트 또는 브랜치 블록을 재방문하더라도, `Pinning` 한 상태이기 때문에 추가적인 블록 I/O는 발생하지 않는다.
* `index_ss`, `no_index_ss`힌트를 사용해 유도하거나 방지할 수 있다.

### Index Skip Scan이 동작하기 위한 조건
* 인덱스 중간 컬럼에 대한 조건절이 누락된 경우에 사용될 수 있다.
  ```oracle
  -- 일별업종별거래_PK : 업종유형코드 + 업종코드 + 기준일자
  SELECT /*+ INDEX_SS(A 일별업종거래_PK) */
         기준일자, 업종코드, 체결건수, 체결수량, 거래대금
  FROM 일별업종거래 A
  WHERE 업종유형코드 = '01'
    AND 기준일자 BETWEEN '20080501' AND '20080531'
  ```
* Distinct Value가 적은 선두컬럼들이 모두 누락된 경우에도 유용하게 사용될 수 있다.
  ```oracle
  -- 일별업종별거래_PK : 업종유형코드 + 업종코드 + 기준일자
  SELECT /*+ INDEX_SS(A 일별업종거래_PK) */
         기준일자, 업종코드, 체결건수, 체결수량, 거래대금
  FROM 일별업종거래 A
  WHERE 기준일자 BETWEEN '20080501' AND '20080531'
  ```
* 선두컬럼이 부등호, between, like 같은 범위검색 조건일 경우에도 사용될 수 있다.
  ```oracle
  -- 일별업종별거래_PK : 기준일자 + 업종유형코드
  SELECT /*+ INDEX_SS(A 일별업종거래_PK) */
         기준일자, 업종코드, 체결건수, 체결수량, 거래대금
  FROM 일별업종거래 A
  WHERE 기준일자 BETWEEN '20080501' AND '20080531'
    AND 업종유형코드 = '01'
  ```

## Index Fast Full Scan
* 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock Read 방식으로 스캔하는 방식이다.
  * `Index Full Scan` 방식은 Single Block I/O 이기 때문에, 대기 이벤트가 주로 `db file squential read`로 찍힌다. 
  * `Index Fast Full Scan` 방식은 Multiblock I/O이기 때문에, 대기 이벤트가 주로 `db file scattered read`로 찍힌다.
* `Index Fast Full Scan` 방식은 인덱스 리프 노드가 갖는 연결 리스트 구조를 이용하지 않기 때문에 결과집합이 인덱스 키 순서대로 정렬되지 않는다.
* 인덱스가 파티션되어있지 않더라도 병렬 쿼리가 가능하다.
  * `Index Full Scan`의 경우 병럴스캔이 불가능하다. 
  * 병렬쿼리시 Direct Path Read 방식을 사용하기 때문에 I/O 속도가 더 빨라진다.
* `index_ffs`, `no_index_ffs` 힌트로 유도하거나 방지할 수 있다.

### Index Fast Full Scan를 고려해보면 좋을 상황
* 인덱스의 정렬이 필요 없고, `Stopkey(Top-N)`로 일찍 멈출 이점이 없는 경우
* 대량 스캔이 필요한데, 인덱스를 멀티블록으로 빠르게 읽는 게 유리한 경우
* 인덱스만으로 거의 처리 가능해서 테이블 액세스가 적거나 없는 경우 (인덱스 크게 훑고 끝)

## Index Range Scan Descending
* Index Range Scan과 기본적으로 동일한 스캔 방식으로, 인덱스를 뒤에서 앞쪽으로 스캔한다.

## And-Equal, Index Combine, Index Join
* 인덱스가 아무리 많아도 테이블당 하나만 사용하는게 일반적이지만, 오라클은 두 개 이상 인덱스를 함께 사용하는 방법도 제공한다.

### And-Equal
* 8i에서 `Index Combine` 방식 도입 후 사용할 일은 없고, 10g부터는 폐기되었다.
* 단일 컬럼의 Non-Unique 인덱스여야 함과 동시에 인덱스 컬럼이 대한 조건절이 `=`여야 동작한다.
* 인덱스 필터링을 거친 양쪽 집합은 rowid순으로 정렬되며, 양쪽을 번갈아 스캔하면서 rowid가 같은 레코드를 찾아 테이블을 액세스하는 방식이다.
* 데이터 분포도가 좋지 않아 단독으로 테이블 Random 액세스를 많이 발생시키는 단일 컬럼 인덱스를 두 개 이상(최대 5개) 결합해 테이블 액세스를 줄이려는 목적이 있다.
  * 인덱스 스캔량이 아무리 많더라도 두 인덱스를 결합하고 나서의 테이블 액세스량이 소량일때 효과가 있다.

### Index Combine
* Index Combine의 과정은 아래와 같다.
  1. 일반 B-Tree 인덱스를 스캔하면서 각 조건을 만족하는 레코드의 rowid 목록을 얻는다.
  2. 위에서 얻은 rowid 목록을 가지고 비트맵 인덱스 구조를 하나씩 만든다.
      * 이미 비트맵인덱스가 있는 테이블은 위 1~2과정을 생략한다.
  3. 비트맵 인덱스에 대한 Bit-Wise 오퍼레이션을 수행한다.
  4. Bit-Wise 오퍼레이션을 수행한 결과가 true인 비트 값들을 rowid값으로 환산해 최종적으로 방문할 테이블 rowid 목록을 얻는다.
  5. rowid를 이용해 테이블을 액세스한다.
* Index Combine은 And-Equal과 마찬가지로, 데이터 분포도가 좋지 않은 두 개 이상의 인덱스를 결합해 Random 액세스량을 줄이려는 목적이 있다.
  * 하지만 조건절이 `=`이어야 할 필요도 없고, Non-Unique 인덱스일 필요도 없다.
  * 또한 비트맵 인덱스를 이용하므로, 조건절이 OR로 결합된 경우에도 유용하다.
* `_b_tree_bitmap_plans` 파라미터가 true일때에만 동작하며, 9i부터는 기본적으로 true로 설정되어있다.

```oracle
select /*+ index_combine(e emp_deptno_idx emp_job_idx */ *
from emp e
where deptno = 30
  and job = 'SALESMAN'
```
```
-----------------------------------------------------------------------------
| Id  | Operation                          | Name            | Rows  | Cost |
-----------------------------------------------------------------------------
|  0  | SELECT STATEMENT                   |                 |       |      |
|  1  |  TABLE ACCESS BY INDEX ROWID       | EMP             |       |      |
|  2  |   BITMAP CONVERSION TO ROWIDS      |                 |       |      |
|  3  |    BITMAP AND                      |                 |       |      |
|  4  |     BITMAP CONVERSION FROM ROWIDS  |                 |       |      |
|  5  |      INDEX RANGE SCAN              | EMP_JOB_IDX     |       |      |
|  6  |     BITMAP CONVERSION FROM ROWIDS  |                 |       |      |
|  7  |      INDEX RANGE SCAN              | EMP_DEPTNO_IDX  |       |      |
-----------------------------------------------------------------------------
```

### Index Join
* `Index Join`은 한 테이블에 속한 여러 인덱스를 이용해 테이블 액세스 없이 결과집합을 만들 때 사용하는 인덱스 스캔 방식이다.
* `Index Join`의 과정은 아래와 같다.
  1. 크기가 비교적 작은 쪽 인덱스에서, 키 값과 rowid를 읽어 PGA 메모리에 해시 맵을 생성한다. (해시 키로 rowid 사용)
  2. 다른쪽 인덱스를 스캔하면서 위에서 생성한 해시맵에 같은 rowid값을 갖는 레코드가 있는지 탐색한다.
  3. rowid끼리 조인에 성공한 레코드만 결과집합에 포함시킨다. (각 인덱스 컬럼에 대한 조건을 모두 만족한다는 의미)
* `Index Join`은 쿼리에 사용된 컬럼들이 인덱스에 모두 포함될 때에만 작동한다.
  * 둘 중 어느 한쪽에 포함되기만 하면 된다.
```oracle
select /*+ index_join(e emp_deptno_idx emp_job_idx) */ deptno, job
from emp e
where deptno = 30
  and joib = 'SALESMAN';
```
```
------------------------------------------------------------------------
| Id  | Operation                      | Name            | Rows | Cost |
------------------------------------------------------------------------
|  0  | SELECT STATEMENT               |                 |    1 |    3 |
|  1  |  VIEW                          | index$_join$_001|    1 |    3 |
|  2  |   HASH JOIN                    |                 |      |      |
|  3  |    INDEX RANGE SCAN            | EMP_JOB_IDX     |    1 |    1 |
|  4  |    INDEX RANGE SCAN            | EMP_DEPTNO_IDX  |    1 |    1 |
------------------------------------------------------------------------
```

# 테이블 Random 액세스 부하
## 인덱스 ROWID에 의한 테이블 액세스
* rowid는 물리적 주소정보라고 말하는 사람도 많지만, 논리적 주소정보라고 표현하기도 한다.
  * rowid가 물리적 위치 정보로 구성되어있긴 하지만, 테이블 레코드로 직접 연결된 구조는 아니기 때문이다.
* 오라클은 테이블 블록이 수시로 버퍼 캐시에서 밀려났다가 다시 캐싱되며, 그때마다 다른 공간에 캐싱되기 때문에 인덱스에서 직접 포인터로 연결할 수 없는 구조이다.
* 인덱스 rowid는 테이블 레코드와 물리적으로 연결되어있지 않기 때문에 인덱스를 통한 테이블 액세스는 생각보다 고비용 구조이다.
  * 모든 데이터가 메모리에 캐싱되어 있더라도 테이블 레코드를 찾기 위해 매번 DBA를 해싱하고 래치획득 과정을 반복해야 한다.
  * 동시 액세스가 심할 때에는 래치와 버퍼 Lock에 대한 경합까지 발생하게 된다.

## 인덱스 클러스터링 팩터
* 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다.
* CF가 좋은 컬럼에 생성한 인덱스는 검색효율이 매우 좋다.
* 데이터가 물리적으로 근접해 있다면 흩어져 있을 때보다 데이터를 찾는 속도가 빨라진다.

### 클러스터링 팩터 조회
* 오라클은 아래와 같이 CF를 계산한다.
  * counter 변수를 하나 선언한다.
  * 인덱스 리프 블록을 처음부터 끝까지 스캔하며 인덱스 rowid로부터 블록 번호를 취한다.
  * 현재 읽고 있는 인덱스 레코드의 블록 번호가 바로 직전에 읽은 레코드의 블록 번호와 다를때마다 counter 변수 값을 1씩 증가시킨다.
  * 스캔 완료 후 최종 counter 변수 값을 `clustering_factor`로 인덱스 통계에 저장한다.
* 이런식으로 측정된 CF는 옵티마이저가 `Index Range Scan`을 통한 테이블 액세스 비용을 평가하는데 사용된다.
  ```
  비용 = blevel +                           -- 인덱스 수직적 탐색 비용
        (리프 블록 수 * 유효 인덱스 선택도) +   -- 인덱스 수평적 탐색 비용
        (클러스터링 팩터 * 유효 테이블 선택도)   -- 테이블 Random 액세스 비용
  ```

### 클러스터링 팩터와 I/O
#### 물리적 I/O
* 오라클에서 I/O는 블록 단위로 이루어지기 때문에, 인덱스를 통해 하나의 레코드를 읽으면 같은 블록에 속한 다른 레코드들도 함께 캐싱되는 결과를 가져온다.
* 따라서 CF가 좋은 인덱스였다면 그 레코드들도 가까운 시점에 읽힐 가능성이 높기 때문에, 인덱스를 스캔하면서 읽는 테이블 블록들의 캐시 히트율이 높아져 물리적인 디스크 I/O 횟수가 감소한다.

#### 논리적 I/O
* 인덱스 CF는, 인덱스를 경유해 테이블 전체 로우를 액세스할 때 읽을 것으로 예상되는 논리적인 블록 개수를 의미한다.
* CF가 가장 좋을 때는 통계에 나타나는 `clustering_factor`가 전체 테이블 블록 개수와 일치하며, 가장 안좋을 때는 총 레코드 개수와 일치한다.
  * 만약 모든 블록에 레코드가 하나씩만 저장되어 있다면 `clustering_factor`는 총 레코드 개수와 일치할 것이다.
* 똑같은 개수의 레코드를 읽어도 인덱스 CF에 따라 논리적인 블록 I/O가 차이나는 이유는 버퍼 Pinning 때문이다.
  * 연속된 인덱스 레코드가 같은 블록을 가리키면, 래치 획득 과정을 생략하고 버퍼를 Pin한 상태에서 읽기 때문에 논리적인 블록 읽기 횟수가 증가하지 않는다.

## 인덱스 손익분기점
* 인덱스 rowid에 의한 테이블 액세스는 생각보다 고비용구조이기 때문에, 일정량을 넘는 순간 `Full Table Scan`보다 느려질 수 있다.
  * 인덱스 rowid에 의한 테이블 액세스는 Random 액세스이지만, `Full Table Scan`은 Sequential 액세스 방식으로 이루어진다.
  * 디스크 I/O 시, 인덱스 rowid에 의한 테이블 액세스는 `Single Block Read` 방식을 사용하지만, `Full Table Scan`은 `Multiblock Read` 방식을 사용한다. 
* 인덱스 손익분기점은 CF에 따라 크게 달라진다.
  * 인덱스 손익분기점은 일반적으로 5~20%의 낮은 수준에서 결정되지만, CF가 나쁘면 5%미만에서 결정되며, CF가 좋을 경우엔 90%까지 올라가기도 한다.

### 손익분기점을 극복하기 위한 기능
#### IOT
* IOT는 테이블을 인덱스 구조로 생성하는 것이다.
* 테이블 자체가 인덱스 구조이므로 항상 정렬된 상태를 유지한다.
* 인덱스 리프 블록이 곧 데이터 블록이기 때문에, 인덱스를 수직 탐색한 다음에 테이블 레코드를 읽기 위한 Random 액세스가 불필요하다.

#### 클러스터 테이블
* 키 값이 같은 레코드는 같은 블록에 모이도록 저장한다.
* 클러스터 인덱스를 이용할 때는 테이블 Random 액세스가 키 값별로 한 번씩만 발생한다.
* 클러스터에 도달해서는 Sequential 방식으로 스캔하기 때문에 넓은 범위를 읽더라도 비효율은 없다.

#### 파티셔닝
* 읽고자 하는 데이터가 많을 때는 인덱스를 이용하지 않는것이 좋지만, 초대용량 테이블은 Full Scan하기 쉽지 않다.
* 대량 범위 조건으로 자주 사용되는 컬럼을 기준으로 테이블을 파티셔닝 한다면 Full Table Scan 하더라도 일부 파티션만 읽고 멈추도록 할 수 있다.
* 클러스터 테이블은 기준 키 값이 같은 레코드를 블록 단위로 모아놓지만, 파티셔닝은 세그먼트 단위로 모아놓는다는 것이다.

# 테이블 Random 액세스 최소화 튜닝
* 인덱스 컬럼 추가 예시 (p79 ~ p82)
  * 기존 사용하던 인덱스가 있었고, 인덱스를 새로만들기에는 부담이 되는 상황에서 기존 인덱스에 컬럼을 하나 추가하는 예시
* PK 인덱스에 컬럼 추가 예시 (p82 ~ p84)
  * 조인 시 효율을 위해 `[PK 컬럼 + 필터조건 컬럼]` 구조의 새로운 인덱스를 추가해야 하는 상황에서, PK 제약을 drop 후 `[PK 컬럼 + 필터조건 컬럼]`의 인덱스로 새로운 PK제약을 만드는 예시
* 컬럼 추가에 따른 클러스터링 팩터 변화 예시 (p84 ~ p86)
  * 인덱스 추가 후 CF 변화가 생기는 예시 
  * 인덱스에 컬럼을 추가함으로써 Random 액세스 부하를 줄이는 효과는 있지만, 인덱스 클러스터링 팩터가 나빠질 수 있다.
  * 인덱스에 변별력이 좋지 않은 컬럼 뒤에 변별력이 좋은 다른 컬럼을 추가할 때 CF 변화의 주의를 해야 한다.  
* 인덱스만 읽고 처리하는 예시 (p86 ~ p92)
  * 실행계획 상에서, 많은 Random 액세스를 발생시키는 부분을 Covered 인덱스를 사용해 Random 액세스를 줄이는 예시
* 버퍼 Pinning 효과 활용 예시 (p92 ~ p94)
  * 인라인 뷰에서 읽은 rowid 값을 이용해 테이블을 액세스하는 예시
  * 오라클의 경우 한번 입력된 테이블 레코드는 rowid가 절대 바뀌지 않는다.
  * 따라서 미리 알고 있던 테이블 rowid값을 이용해 레코드를 조회하는 것이 가능하다.
* 수동으로 클러스터링 팩터를 높이는 예시 (p94 ~ p97)
  * CF가 나쁜 인덱스를 기준으로 테이블을 재생성하여 CF를 인위적으로 좋게 만드는 예시
  * 인위적으로 CF를 높일 목적으로 테이블을 Reorg할 때에는 가장 자주 사용되는 인덱스를 기준으로 삼아야 한다.
  * 인덱스들 컬럼 간 상관관계가 높지 않다면 CF가 좋은 인덱스는 테이블당 하나이다.


# 인덱스 구조
## 범위 스캔
* 인덱스는 키 컬럼 순으로 정렬되어 있기 때문에, 특정 위치에서 스캔을 시작해 검색조건에 일치하지 않는 값을 만나는 순간 멈출 수 있다.
  * 즉, 인덱스는 범위 스캔이 가능하다.
* 테이블의 경우 IOT는 특정 컬럼 순으로 정렬상태를 유지하기 때문에 범위스캔이 가능하지만, IOT를 제외하면 범위스캔은 불가능하다.
  * 일반적인 힙 구조 테이블에서 범위스캔은 불가능하다.

## 인덱스 기본 구조
* 여러 종류의 인덱스 중 가장 일반적으로 사용되는 구조는 B-Tree 구조이다.
  * 루트를 포함한 브랜치 블록에 저장된 엔트리에는, 하위 노드 블록을 찾아가기 위한 DBA(Data Block Address) 정보를 갖고 있다.
  * 리프 블록에는 인덱스 키 컬럼과 함께 해당 테이블 레코드를 찾아가기 위한 주소정보 ROWID를 갖는다.

> LMC(Left Most Child)
> * 브랜치 노드의 각 엔트리는 키 값과 하위 노드를 가리키는 블록 주소를 갖는다.
> * 각 브랜치 노드의 첫 번 째 엔트리는 키 값을 갖지 않는데, 이를 LMC라고 한다.
> * LMC는 명시적인 키 값을 갖지 않더라도, 키 값을 가진 첫 번째 엔트리보다 작은 값의 의미를 갖는다.
> * 즉, 그 브랜치 블록의 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다.

* 리프 노드상의 인덱스 레코드와, 테이블 레코드 간에는 1:1 관계이다. (인덱스의 구성 컬럼이 모두 null인경우는 제외, 클러스터 인덱스인 경우는 1:M)
  * 오라클은 인덱스 구성 컬럼이 모두 null인 레코드는 저장하지 않는다. 
* 리프 노드상의 키 값과 테이블 레코드 키 값은 서로 일치한다.
* 브랜치 노드상의 레코드 개수는 하위 레벨 블록 개수와 일치한다.
* 브랜치 노드상의 키 값은 하위 노드가 갖는 값의 범위를 의미한다.

## 인덱스 탐색
* 인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 구분해 설명할 수 있다.
  * 수평적 탐색 : 범위 스캔
  * 수직적 탐색 : 수평적 탐색을 위한 시작 지점을 찾는 과정
* 특정 조건으로 검색 시 탐색이 어떤식으로 이루어지는지 알아야 한다.


## ROWID 포맷
* rowid에는 데이터파일, 번호, 로우번호 같은 테이블 레코드의 물리적 위치 정보를 포함한다.
* 오라클 7버전 까지
  * 데이터 파일 번호(4자리)
    * 데이터베이스 내에서 유일한 값
  * 블록 번호(8자리)
    * 해당 로우가 저장된 데이트 블록 번호로, 데이터파일 내에서의 상대적 번호
  * 로우 번호(4자리)
    * 블록 내에서 각 로우에 붙여진 일련번호로, 0부터 시작
  * `(블록).(로우).(데이터파일)`의 형태
* 오라클 8버전 이후
  * 데이터 오브젝트 번호(6자리)
    * 데이터베이스 세그먼트를 식별하기 위해 사용되는 데이터 오브젝트 번호
  * 데이터파일 번호(3자리)
    * 로우가 속한 데이터파일 번호로, 테이블스페이스 내에서의 상대적인 파일 번호
  * 블록번호(6자리)
    * 해당 로우가 저장된 데이터 블록 번호로, 데이터파일 내에서의 상대적 번호
  * 로우번호(3자리)
    * 블록 내에서 각 로우에 붙여진 일련번호로, 0부터 시작
  * `(데이터 오브젝트)(데이터파일)(블록)(로우)`의 형태

# 인덱스 기본 원리
## 인덱스 사용이 불가능하거나, 범위 스캔이 불가능한 경우
* 인덱스를 정상적으로 사용할 수 없는 예시
  * 인덱스 컬럼을 조건절에서 가공
    ```oracle
    select * from 업체 where substr(업체명, 1, 2) = '대한';
    ```
  * 부정형 비교를 사용
    ```oracle
    select * from 고객 where 직업 <> '학생';
    select * from 사원 where 부서코드 is not null;
    ```
  * 단일컬럼 인덱스인 경우 `is null` 조건 사용 (결합 인덱스일 때에는 구성컬럼이 모두 `null` 조건)
    ```oracle
    select * from emp where empno is null;
    ```
    * 위 예시에서도 옵티마이저가 인덱스를 사용하는 경우가 있긴 하다.
    * `empno`컬럼에 `not null` 제약이 있다면, 어차피 테이블을 스캔해도 해당 조건을 만족하는 레코드가 없음을 알기 때문에 인덱스 스캔을 통해 공집합을 리턴하기 때문이다.
    * 하지만 애초에 `not null` 컬럼을 `is null` 조건으로 검색하는 것 자체가 모순이다.

## 인덱스 컬럼의 가공
* 인덱스 컬럼을 가공하면 정상적인 `Index Range Scan`이 불가능하다.
* 특정 상황에서는 함수기반 인덱스(FBI) 생성을 고려해볼 수도 있다.

## 묵시적 형변환
* 묵시적 형변환으로, 인덱스 컬럼이 가공되어 인덱스를 사용하지 못하는 상황이 발생할 수 있다.
  * 이를 확인하고 파악하려면, 옵티마이저에 의해 일어나는 내부적인 형변환 원리를 이해하고 있어야 하고, 조인 컬럼의 데이터타입을 일일이 따져봐야 한다.
* 또한 묵시적 형변환으로, 아예 쿼리 수행 도중 에러가 발생하거나 잘못된 결과가 나오는 상황도 생긴다.
  ```oracle
  select round(avg(sal)) avg_sal
       , max(sal) max_sal 
       , max(decode(job, 'PRESIDENT', NULL, sal)) max_sal2  -- 4번째 인자 sal을 문자열로 변환했을 때 가장 큰 값을 출력하게 됨
                                                             
  from scott.emp
  ```
  * `decode`로 4번째 인자를 출력될 때, 데이터 타입은 3번째 인자의 타입으로 결정되며, `decode`는 3번째 인자가 `null`이면 `varchar2`로 취급한다.
  * 즉, 묵시적 형변환으로 인한 오류가 발생하는 예시이다.
* 묵시적 형변환 기능에 절대 의존해선 안된다.
  * 필요하다면 항상 명시적으로 변환 함수를 사용해야 한다.

# 다양한 인덱스 스캔 방식
## Index Range Scan
* 인덱스 루트 블록에서 리프 블록까지 수직적 탐색 후, 리프블록을 필요한 범위만 스캔하는 방식이다.
* B-Tree 인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식이다.
* `Index Range Scan`이 가능하게 하려면 인덱스를 구성하는 선두 컬럼이 조건절에 사용되어야 한다.
  * 그렇지 못한 상황에서 인덱스를 사용하도록 힌트로 강제한다면, `Index Full Scan` 방식으로 처리된다.
* `Index Range Scan` 과정을 거쳐 생성된 결과 집합은 인덱스 컬럼 순으로 정렬된 상태가 되기 때문에 `sort order by` 연산을 생략하거나 `min/max` 값을 빠르게 추출해낼 수 있다.
* 실행계획 상에서 `Index Range Scan`이 나타난다고해서 항상 빠른 속도를 보장하는 것은 아니며, 인덱스를 스캔하는 범위를 줄이고 테이블로 액세스하는 횟수를 줄이는게 중요하다.

## Index Full Scan
* 수직적 탐색 없이(최초 1번은 일어남), 인덱스 리프블록을 처음부터 끝까지 수평적으로 탐색하는 방식이다.
* 보통은 데이터 검색을 위한 최적의 인덱스가 없을 때 차선으로 선택된다.
* 상황에 따라, `Index Full Scan`이 전체적인 I/O면에서 유리할 수도 있다. 
  * 인덱스 선두 컬럼이 조건절에 없으면, 옵티마이저는 우선적으로 `Table Full Scan`을 고려한다.
  * 하지만 대용량 테이블이어서 `Table Full Scan`의 부담이 크다면 상황에 따라 옵티마이저는 인덱스를 활용하는 방법을 생각해볼 수 있는데, 데이터 저장 공간은, 보통 인덱스가 차지하는 면적이 테이블보다 훨씬 적기 때문이다.
  * 따라서 **인덱스 스캔 단계에서 대부분의 레코드를 필터링할 수 있고, 일부에 대해서만 테이블 액세스가 발생할 수 있다면** 전체적인 I/O에서 더 유리해진다.
* `Index Full Scan`은 `Index Range Scan`과 마찬가지로, 결과 집합이 인덱스 컬럼 순으로 정렬되므로 `Sort Order By` 연산을 생략할 목적으로 사용될 수 있다.

## Index Unique Scan
* 수직적 탐색만으로 데이터를 찾는 스캔 방식이다.
* Unique 인덱스를 통해 `=`조건으로 탐색하는 경우에 작동한다.
  * 이 경우엔 데이터 한 건을 찾는 순간 더 이상 탐색할 필요가 없기 때문이다.

## Index Skip Scan
* 루트 또는 브랜치 블록에서 읽은 컬럼 값 정보를 이용해 조건에 부합하는 레코드를 포함할 가능성이 있는 리프 블록만 골라서 액세스 하는 방식이다.
* **조건절에 빠진 선두 컬럼의 Distinct Value 개수가 적고, 후행 컬럼의 Distinct Value 개수가 많을 때 유용**하다.
* Skip에는 버퍼 `Pinning`이 활용된다.
  * 브랜치 블록 버퍼를 `Pinning` 한 채로 리프 블록을 방문했다가 다시 브랜치 블록으로 돌아와 다음 방문할 리프 블록을 찾는 과정을 반복한다.
  * 브랜치 블록 간에는 서로 연결할 수 있는 주소 정보가 없기 때문에 하나의 브랜치 블록을 모두 처리하면 그 상위 노드를 재방문한다.
  * 루트 또는 브랜치 블록을 재방문하더라도, `Pinning` 한 상태이기 때문에 추가적인 블록 I/O는 발생하지 않는다.
* `index_ss`, `no_index_ss`힌트를 사용해 유도하거나 방지할 수 있다.

### Index Skip Scan이 동작하기 위한 조건
* 인덱스 중간 컬럼에 대한 조건절이 누락된 경우에 사용될 수 있다.
  ```oracle
  -- 일별업종별거래_PK : 업종유형코드 + 업종코드 + 기준일자
  SELECT /*+ INDEX_SS(A 일별업종거래_PK) */
         기준일자, 업종코드, 체결건수, 체결수량, 거래대금
  FROM 일별업종거래 A
  WHERE 업종유형코드 = '01'
    AND 기준일자 BETWEEN '20080501' AND '20080531'
  ```
* Distinct Value가 적은 선두컬럼들이 모두 누락된 경우에도 유용하게 사용될 수 있다.
  ```oracle
  -- 일별업종별거래_PK : 업종유형코드 + 업종코드 + 기준일자
  SELECT /*+ INDEX_SS(A 일별업종거래_PK) */
         기준일자, 업종코드, 체결건수, 체결수량, 거래대금
  FROM 일별업종거래 A
  WHERE 기준일자 BETWEEN '20080501' AND '20080531'
  ```
* 선두컬럼이 부등호, between, like 같은 범위검색 조건일 경우에도 사용될 수 있다.
  ```oracle
  -- 일별업종별거래_PK : 기준일자 + 업종유형코드
  SELECT /*+ INDEX_SS(A 일별업종거래_PK) */
         기준일자, 업종코드, 체결건수, 체결수량, 거래대금
  FROM 일별업종거래 A
  WHERE 기준일자 BETWEEN '20080501' AND '20080531'
    AND 업종유형코드 = '01'
  ```

## Index Fast Full Scan
* 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock Read 방식으로 스캔하는 방식이다.
  * `Index Full Scan` 방식은 Single Block I/O 이기 때문에, 대기 이벤트가 주로 `db file squential read`로 찍힌다. 
  * `Index Fast Full Scan` 방식은 Multiblock I/O이기 때문에, 대기 이벤트가 주로 `db file scattered read`로 찍힌다.
* `Index Fast Full Scan` 방식은 인덱스 리프 노드가 갖는 연결 리스트 구조를 이용하지 않기 때문에 결과집합이 인덱스 키 순서대로 정렬되지 않는다.
* 인덱스가 파티션되어있지 않더라도 병렬 쿼리가 가능하다.
  * `Index Full Scan`의 경우 병럴스캔이 불가능하다. 
  * 병렬쿼리시 Direct Path Read 방식을 사용하기 때문에 I/O 속도가 더 빨라진다.
* `index_ffs`, `no_index_ffs` 힌트로 유도하거나 방지할 수 있다.

### Index Fast Full Scan를 고려해보면 좋을 상황
* 인덱스의 정렬이 필요 없고, `Stopkey(Top-N)`로 일찍 멈출 이점이 없는 경우
* 대량 스캔이 필요한데, 인덱스를 멀티블록으로 빠르게 읽는 게 유리한 경우
* 인덱스만으로 거의 처리 가능해서 테이블 액세스가 적거나 없는 경우 (인덱스 크게 훑고 끝)

## Index Range Scan Descending
* Index Range Scan과 기본적으로 동일한 스캔 방식으로, 인덱스를 뒤에서 앞쪽으로 스캔한다.

## And-Equal, Index Combine, Index Join
* 인덱스가 아무리 많아도 테이블당 하나만 사용하는게 일반적이지만, 오라클은 두 개 이상 인덱스를 함께 사용하는 방법도 제공한다.

### And-Equal
* 8i에서 `Index Combine` 방식 도입 후 사용할 일은 없고, 10g부터는 폐기되었다.
* 단일 컬럼의 Non-Unique 인덱스여야 함과 동시에 인덱스 컬럼이 대한 조건절이 `=`여야 동작한다.
* 인덱스 필터링을 거친 양쪽 집합은 rowid순으로 정렬되며, 양쪽을 번갈아 스캔하면서 rowid가 같은 레코드를 찾아 테이블을 액세스하는 방식이다.
* 데이터 분포도가 좋지 않아 단독으로 테이블 Random 액세스를 많이 발생시키는 단일 컬럼 인덱스를 두 개 이상(최대 5개) 결합해 테이블 액세스를 줄이려는 목적이 있다.
  * 인덱스 스캔량이 아무리 많더라도 두 인덱스를 결합하고 나서의 테이블 액세스량이 소량일때 효과가 있다.

### Index Combine
* Index Combine의 과정은 아래와 같다.
  1. 일반 B-Tree 인덱스를 스캔하면서 각 조건을 만족하는 레코드의 rowid 목록을 얻는다.
  2. 위에서 얻은 rowid 목록을 가지고 비트맵 인덱스 구조를 하나씩 만든다.
      * 이미 비트맵인덱스가 있는 테이블은 위 1~2과정을 생략한다.
  3. 비트맵 인덱스에 대한 Bit-Wise 오퍼레이션을 수행한다.
  4. Bit-Wise 오퍼레이션을 수행한 결과가 true인 비트 값들을 rowid값으로 환산해 최종적으로 방문할 테이블 rowid 목록을 얻는다.
  5. rowid를 이용해 테이블을 액세스한다.
* Index Combine은 And-Equal과 마찬가지로, 데이터 분포도가 좋지 않은 두 개 이상의 인덱스를 결합해 Random 액세스량을 줄이려는 목적이 있다.
  * 하지만 조건절이 `=`이어야 할 필요도 없고, Non-Unique 인덱스일 필요도 없다.
  * 또한 비트맵 인덱스를 이용하므로, 조건절이 OR로 결합된 경우에도 유용하다.
* `_b_tree_bitmap_plans` 파라미터가 true일때에만 동작하며, 9i부터는 기본적으로 true로 설정되어있다.

```oracle
select /*+ index_combine(e emp_deptno_idx emp_job_idx */ *
from emp e
where deptno = 30
  and job = 'SALESMAN'
```
```
-----------------------------------------------------------------------------
| Id  | Operation                          | Name            | Rows  | Cost |
-----------------------------------------------------------------------------
|  0  | SELECT STATEMENT                   |                 |       |      |
|  1  |  TABLE ACCESS BY INDEX ROWID       | EMP             |       |      |
|  2  |   BITMAP CONVERSION TO ROWIDS      |                 |       |      |
|  3  |    BITMAP AND                      |                 |       |      |
|  4  |     BITMAP CONVERSION FROM ROWIDS  |                 |       |      |
|  5  |      INDEX RANGE SCAN              | EMP_JOB_IDX     |       |      |
|  6  |     BITMAP CONVERSION FROM ROWIDS  |                 |       |      |
|  7  |      INDEX RANGE SCAN              | EMP_DEPTNO_IDX  |       |      |
-----------------------------------------------------------------------------
```

### Index Join
* `Index Join`은 한 테이블에 속한 여러 인덱스를 이용해 테이블 액세스 없이 결과집합을 만들 때 사용하는 인덱스 스캔 방식이다.
* `Index Join`의 과정은 아래와 같다.
  1. 크기가 비교적 작은 쪽 인덱스에서, 키 값과 rowid를 읽어 PGA 메모리에 해시 맵을 생성한다. (해시 키로 rowid 사용)
  2. 다른쪽 인덱스를 스캔하면서 위에서 생성한 해시맵에 같은 rowid값을 갖는 레코드가 있는지 탐색한다.
  3. rowid끼리 조인에 성공한 레코드만 결과집합에 포함시킨다. (각 인덱스 컬럼에 대한 조건을 모두 만족한다는 의미)
* `Index Join`은 쿼리에 사용된 컬럼들이 인덱스에 모두 포함될 때에만 작동한다.
  * 둘 중 어느 한쪽에 포함되기만 하면 된다.
```oracle
select /*+ index_join(e emp_deptno_idx emp_job_idx) */ deptno, job
from emp e
where deptno = 30
  and joib = 'SALESMAN';
```
```
------------------------------------------------------------------------
| Id  | Operation                      | Name            | Rows | Cost |
------------------------------------------------------------------------
|  0  | SELECT STATEMENT               |                 |    1 |    3 |
|  1  |  VIEW                          | index$_join$_001|    1 |    3 |
|  2  |   HASH JOIN                    |                 |      |      |
|  3  |    INDEX RANGE SCAN            | EMP_JOB_IDX     |    1 |    1 |
|  4  |    INDEX RANGE SCAN            | EMP_DEPTNO_IDX  |    1 |    1 |
------------------------------------------------------------------------
```

# 테이블 Random 액세스 부하
## 인덱스 ROWID에 의한 테이블 액세스
* rowid는 물리적 주소정보라고 말하는 사람도 많지만, 논리적 주소정보라고 표현하기도 한다.
  * rowid가 물리적 위치 정보로 구성되어있긴 하지만, 테이블 레코드로 직접 연결된 구조는 아니기 때문이다.
* 오라클은 테이블 블록이 수시로 버퍼 캐시에서 밀려났다가 다시 캐싱되며, 그때마다 다른 공간에 캐싱되기 때문에 인덱스에서 직접 포인터로 연결할 수 없는 구조이다.
* 인덱스 rowid는 테이블 레코드와 물리적으로 연결되어있지 않기 때문에 인덱스를 통한 테이블 액세스는 생각보다 고비용 구조이다.
  * 모든 데이터가 메모리에 캐싱되어 있더라도 테이블 레코드를 찾기 위해 매번 DBA를 해싱하고 래치획득 과정을 반복해야 한다.
  * 동시 액세스가 심할 때에는 래치와 버퍼 Lock에 대한 경합까지 발생하게 된다.

## 인덱스 클러스터링 팩터
* 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다.
* CF가 좋은 컬럼에 생성한 인덱스는 검색효율이 매우 좋다.
* 데이터가 물리적으로 근접해 있다면 흩어져 있을 때보다 데이터를 찾는 속도가 빨라진다.

### 클러스터링 팩터 조회
* 오라클은 아래와 같이 CF를 계산한다.
  * counter 변수를 하나 선언한다.
  * 인덱스 리프 블록을 처음부터 끝까지 스캔하며 인덱스 rowid로부터 블록 번호를 취한다.
  * 현재 읽고 있는 인덱스 레코드의 블록 번호가 바로 직전에 읽은 레코드의 블록 번호와 다를때마다 counter 변수 값을 1씩 증가시킨다.
  * 스캔 완료 후 최종 counter 변수 값을 `clustering_factor`로 인덱스 통계에 저장한다.
* 이런식으로 측정된 CF는 옵티마이저가 `Index Range Scan`을 통한 테이블 액세스 비용을 평가하는데 사용된다.
  ```
  비용 = blevel +                           -- 인덱스 수직적 탐색 비용
        (리프 블록 수 * 유효 인덱스 선택도) +   -- 인덱스 수평적 탐색 비용
        (클러스터링 팩터 * 유효 테이블 선택도)   -- 테이블 Random 액세스 비용
  ```

### 클러스터링 팩터와 I/O
#### 물리적 I/O
* 오라클에서 I/O는 블록 단위로 이루어지기 때문에, 인덱스를 통해 하나의 레코드를 읽으면 같은 블록에 속한 다른 레코드들도 함께 캐싱되는 결과를 가져온다.
* 따라서 CF가 좋은 인덱스였다면 그 레코드들도 가까운 시점에 읽힐 가능성이 높기 때문에, 인덱스를 스캔하면서 읽는 테이블 블록들의 캐시 히트율이 높아져 물리적인 디스크 I/O 횟수가 감소한다.

#### 논리적 I/O
* 인덱스 CF는, 인덱스를 경유해 테이블 전체 로우를 액세스할 때 읽을 것으로 예상되는 논리적인 블록 개수를 의미한다.
* CF가 가장 좋을 때는 통계에 나타나는 `clustering_factor`가 전체 테이블 블록 개수와 일치하며, 가장 안좋을 때는 총 레코드 개수와 일치한다.
  * 만약 모든 블록에 레코드가 하나씩만 저장되어 있다면 `clustering_factor`는 총 레코드 개수와 일치할 것이다.
* 똑같은 개수의 레코드를 읽어도 인덱스 CF에 따라 논리적인 블록 I/O가 차이나는 이유는 버퍼 Pinning 때문이다.
  * 연속된 인덱스 레코드가 같은 블록을 가리키면, 래치 획득 과정을 생략하고 버퍼를 Pin한 상태에서 읽기 때문에 논리적인 블록 읽기 횟수가 증가하지 않는다.

## 인덱스 손익분기점
* 인덱스 rowid에 의한 테이블 액세스는 생각보다 고비용구조이기 때문에, 일정량을 넘는 순간 `Full Table Scan`보다 느려질 수 있다.
  * 인덱스 rowid에 의한 테이블 액세스는 Random 액세스이지만, `Full Table Scan`은 Sequential 액세스 방식으로 이루어진다.
  * 디스크 I/O 시, 인덱스 rowid에 의한 테이블 액세스는 `Single Block Read` 방식을 사용하지만, `Full Table Scan`은 `Multiblock Read` 방식을 사용한다. 
* 인덱스 손익분기점은 CF에 따라 크게 달라진다.
  * 인덱스 손익분기점은 일반적으로 5~20%의 낮은 수준에서 결정되지만, CF가 나쁘면 5%미만에서 결정되며, CF가 좋을 경우엔 90%까지 올라가기도 한다.

### 손익분기점을 극복하기 위한 기능
#### IOT
* IOT는 테이블을 인덱스 구조로 생성하는 것이다.
* 테이블 자체가 인덱스 구조이므로 항상 정렬된 상태를 유지한다.
* 인덱스 리프 블록이 곧 데이터 블록이기 때문에, 인덱스를 수직 탐색한 다음에 테이블 레코드를 읽기 위한 Random 액세스가 불필요하다.

#### 클러스터 테이블
* 키 값이 같은 레코드는 같은 블록에 모이도록 저장한다.
* 클러스터 인덱스를 이용할 때는 테이블 Random 액세스가 키 값별로 한 번씩만 발생한다.
* 클러스터에 도달해서는 Sequential 방식으로 스캔하기 때문에 넓은 범위를 읽더라도 비효율은 없다.

#### 파티셔닝
* 읽고자 하는 데이터가 많을 때는 인덱스를 이용하지 않는것이 좋지만, 초대용량 테이블은 Full Scan하기 쉽지 않다.
* 대량 범위 조건으로 자주 사용되는 컬럼을 기준으로 테이블을 파티셔닝 한다면 Full Table Scan 하더라도 일부 파티션만 읽고 멈추도록 할 수 있다.
* 클러스터 테이블은 기준 키 값이 같은 레코드를 블록 단위로 모아놓지만, 파티셔닝은 세그먼트 단위로 모아놓는다는 것이다.

# 테이블 Random 액세스 최소화 튜닝
* 인덱스 컬럼 추가 예시 (p79 ~ p82)
  * 기존 사용하던 인덱스가 있었고, 인덱스를 새로만들기에는 부담이 되는 상황에서 기존 인덱스에 컬럼을 하나 추가하는 예시
* PK 인덱스에 컬럼 추가 예시 (p82 ~ p84)
  * 조인 시 효율을 위해 `[PK 컬럼 + 필터조건 컬럼]` 구조의 새로운 인덱스를 추가해야 하는 상황에서, PK 제약을 drop 후 `[PK 컬럼 + 필터조건 컬럼]`의 인덱스로 새로운 PK제약을 만드는 예시
* 컬럼 추가에 따른 클러스터링 팩터 변화 예시 (p84 ~ p86)
  * 인덱스 추가 후 CF 변화가 생기는 예시 
  * 인덱스에 컬럼을 추가함으로써 Random 액세스 부하를 줄이는 효과는 있지만, 인덱스 클러스터링 팩터가 나빠질 수 있다.
  * 인덱스에 변별력이 좋지 않은 컬럼 뒤에 변별력이 좋은 다른 컬럼을 추가할 때 CF 변화의 주의를 해야 한다.  
* 인덱스만 읽고 처리하는 예시 (p86 ~ p92)
  * 실행계획 상에서, 많은 Random 액세스를 발생시키는 부분을 Covered 인덱스를 사용해 Random 액세스를 줄이는 예시
* 버퍼 Pinning 효과 활용 예시 (p92 ~ p94)
  * 인라인 뷰에서 읽은 rowid 값을 이용해 테이블을 액세스하는 예시
  * 오라클의 경우 한번 입력된 테이블 레코드는 rowid가 절대 바뀌지 않는다.
  * 따라서 미리 알고 있던 테이블 rowid값을 이용해 레코드를 조회하는 것이 가능하다.
* 수동으로 클러스터링 팩터를 높이는 예시 (p94 ~ p97)
  * CF가 나쁜 인덱스를 기준으로 테이블을 재생성하여 CF를 인위적으로 좋게 만드는 예시
  * 인위적으로 CF를 높일 목적으로 테이블을 Reorg할 때에는 가장 자주 사용되는 인덱스를 기준으로 삼아야 한다.
  * 인덱스들 컬럼 간 상관관계가 높지 않다면 CF가 좋은 인덱스는 테이블당 하나이다.

# IOT, 클러스터 테이블 활용
* 오라클에선 테이블을 아예 인덱스 구조로 생성할 수 있도록 기능을 제공하는데, 이것을 IOT(Index-Organized Table)라고 한다.
* IOT에서는 인덱스 리프 블록이 곧 데이터 블록이다.

## IOT의 장단점
1) 장점
   * 같은 값을 가진 레코드들이 정렬된 상태로 모여있기 때문에, Random 액세스가 아닌 Sequential 방식으로 데이터를 액세스할 수 있어 넓은 범위를 액세스할 때 유리하다.
   * PK 인덱스를 위한 별도의 세그먼트를 생성하지 않아도 되기 때문에 저장공간이 절약된다.
2) 단점
   * 데이터 입력 시 성능이 느리다.
   * 인덱스 분할(Split) 발생량으로 인한 성능 차이가 크며, 컬럼수가 많을수록 인덱스 분할 발생 빈도도 높아진다.
   * Direct Path Insert가 작동하지 않는다.

## IOT가 유용한 상황
### 크기가 작고 NL 조인으로 반복 룩업하는 테이블
* 코드성 테이블이 주로 여기에 속한다. 
  * NL 조인에서 Inner 쪽 룩업 테이블로서 액세스 되는 동안 건건이 인덱스와 테이블 블록을 다 읽으면 비효율적이다.
* 하지만 IOT 구성 시 PK 이외의 속성이 커 인덱스 높이가 증가한다면 역효과가 날 수 있다.

### 폭이 좁고 긴(로우수가 많은) 테이블 
* N:M 관계를 해소하기 위한 Association 테이블이 주로 여기에 속한다.
  * PK 컬럼 이외의 컬럼이 전혀 없거나 있더라도 아주 소수에 불과하기 때문이다.

### 넓은 범위를 주로 검색하는 테이블
* Between, Like 같은 조건으로 넓은 범위를 검색하는 테이블이라면 IOT를 고려해볼만하다.
* PK 이외의 컬럼이 별로 없는 통계성 테이블에 최적이다. 
  * 이런 통계성 테이블은 PK 컬럼은 많고 일반 속성은 적은 상황이 많다.
 
### 데이터 입력과 조회 패턴이 서로 다른 테이블
* 조회패턴에 맞게 IOT를 구성해 주면 작은 블록만 읽고 처리할 수 있다.

## Partitioned IOT
```oracle
select 거래일자, 지점번호, 계좌번호, sum(거래량), sum(거래금액)
from 일별상품별계좌별거래
where 상품번호 = 'P7001234123'
and 거래일자 between '20250101' and '20250630'
group by 거래일자, 지점번호, 계좌번호
```
* 위 예시와 같이 대용량의 테이블에서 기간검색이 필요한 경우, 아래와같은 문제들이 발생할 수 있다.
  * 인덱스를 사용하면 Random 액세스 부하가 심하게 발생한다.
  * Range 파티셔닝을 이용하면 필요한 파티션만 Full Scan하면 되겠지만 그 기간내의 데이터를 모두 읽는 비효율이 생긴다.
  * IOT로 구성하면 읽기 성능은 개선되겠지만, 초대용량 테이블을 단일 IOT로 구성하는 것은 쉽지 않다.
* 이럴 경우 Partitioned IOT가 좋은 해결책이 된다.
  * `거래일자` 컬럼을 기준으로 Range 파티셔닝
  * `[상품번호 + 거래일자]` 순으로 PK를 정의하고 IOT를 구성

## Overflow 영역
* PK 이외 컬럼이 많은 테이블일수록 IOT로 구성하기엔 부적합하다.
  * 인덱스 분할에 의한 DML 부하 및 검색을 위한 스캔량도 늘어난다.
* 그럼에도 불구하고 IOT가 꼭 필요하다면 `Overflow` 기능을 사용해볼 수 있다.
```oracle
CREATE TABLE 불공정거래적축 (
    종목코드        VARCHAR2(12) NOT NULL  -- PK속성
  , 적출일자        VARCHAR2(12) NOT NULL  -- PK속성
  , 회원번호        VARCHAR2(12) NOT NULL  -- PK속성
  , 지점번호        VARCHAR2(12) NOT NULL  -- PK속성
  , 계좌번호        VARCHAR2(12) NOT NULL  -- PK속성
  , 적출유형코드     VARCHAR2(12) NOT NULL  -- PK속성
  , 상품구분코드     VARCHAR2(12) NOT NULL 
  , 적출건수        VARCHAR2(12) NOT NULL
  , 생성자ID        VARCHAR2(12) NOT NULL  -- 시스템 관리 속성
  , 수정자ID        VARCHAR2(12) NOT NULL  -- 시스템 관리 속성
  , 생성일시        VARCHAR2(12) NOT NULL  -- 시스템 관리 속성
  , 수정일시        VARCHAR2(12) NOT NULL  -- 시스템 관리 속성
  , CONSTRAINT 불공정거래적출_PK PRIMARY KEY
      ( 종목코드, 적출일자, 회원번호, 지점번호, 계좌번호, 적출유형코드 )
)
ORGANIZATION INDEX
PCTTHRESHOLD 30
INCLUDInG 적출건수
OVERFLOW TABLESPACE TBS_OVRFL01
```
* 위와같이 Overflow를 사용할 수 있다.
  * `OVERFLOW TABLESPACE` : Overflow 세그먼트가 저장될 Tablespace를 지정
  * `PCTTHRESHOLD` : 값이 30인 경우엔 Block 크기의 30%를 초과하기 직전 컬럼까지만 Index Block에 저장하고, 뒤 쪽 컬럼은 Overflow 세그먼트에 저장한다.
    * 로우 전체 크기가 지정된 비율 크기보다 작다면 모두 인덱스 블록에 저장하게 된다.
    * 따라서 테이블 생성 시점에모든 컬럼의 데이터타입 Max길이를 합산한 크기가 이 비율 크기보다 크면 `OVERFLOW TABLESPACE` 옵션을 반드시 지정하도록 강제하는 에러를 던진다.
    * DEFAULT값은 50이다.
  * `INCLUDING` : 여기에 지정한 컬럼까지만 인덱스 블록에 저장하고 나머지는 무조건 Overflow 세그먼트에 저장한다.
* Overflow영역을 읽을 때 건건이 Random 액세스는 발생한다.
  * Overflow 세그먼트에 저장된 컬럼 중 일부를 자주 액세스하는 상황에서는 부적절하다.
* Overflow 영역에도 버퍼 Pinning 은 동작하기 때문에 연속적으로 같은 Overflow블록을 읽을 때에는 Random 액세스를 최소화할 수 있다.

## Secondary 인덱스
* IOT는 secondary 인덱스 추가 가능성이 크지 않을 때만 선택하는 것이 바람직하다.

### 오라클 Logical Rowid
* IOT 레코드의 위치는 영구적이지 않기 때문에 오라클은 secondary 인덱스로부터 IOT 레코드를 가리킬 때 물리적 주소 대신 logical rowid를 사용한다.
  * `Logical Rowid = PK + physical guess`
* physical guess는 secondary 인덱스를 최초로 생성하거나 재생성한 시점에 IOT레코드가 위치했던 데이터 블록 주소(DBA)이다.
  * 인덱스 분할에 의해 IOT 레코드가 다른 블록으로 이동하더라도, secondary 인덱스에 저장된 physical guess 값은 갱신되지 않는다.

### PCT_DIRECT_ACCESS
* `dba/all/user_indexes` 테이블을 조회하면 pct_direct_access 값을 확인할 수 있다.
* secondary 인덱스가 유효한 physical guess를 가진 비율을 나타내는 지표로, secondary 인덱스 탐색 효율을 결정짓는 중요한 값이다.
* 레코드 위치가 자주 변하는 IOT의 경우 시간이 지나면서 physical guess에 의한 액세스 실패 확률이 높아지기 때문에 성능이 저하된다.
* 이럴 경우 통계정보를 다시 수집해 pct_direct_access가 실제 physical guess 성공률을 반영하도록 해줘야 한다.
  * 물론, 인덱스를 `REBUILD` 하거나 `UPDATE BLOKC REFERENCES`를 주기적으로 갱신해줄 수 있다면 가장 효과적이다.

### 비휘발성 IOT에 대한 Secondary 인덱스 튜닝 방안
* 비휘발성 IOT의 경우 Direct 액세스 성공률이 높다.
* 따라서 pct_direct_access 값이 100을 가리키도록 유지하는것이 좋다.
  * 한달에 한번이나 일년에 한번 정도 physical guess를 갱신해주면 된다.

### 비휘발성 IOT에 대한 Secondary 인덱스 튜닝 방안
* 휘발성이 강한 IOT에 secondary 인덱스를 추가할 때에는 주의가 필요하며, 처음 IOT 설계때부터 이에 대한 고려가 있어야 한다.
* 휘발성이어서 physical guess에 의한 Direct 액세스 성공률이 낮다면 두가지 방법이 있다.
  1) 주기적으로 physical guess를 정확한 값으로 갱신해준다.
  2) 주기적으로 physical guess를 갱신할 수 없다면 pct_direct_access 값을 100미만으로 떨어뜨린다.

### Right-Growing IOT에서 pct_direct_access가 100 미만으로 떨어지는 이유
* 우측 leaf 블록에서 split이 반복적으로 발생할 수 있고, 누적되면 branch split, root block split으로 이어질 수 있다.
* 인덱스 높이가 증가하는 시점에서는 secondary 인덱스에서 대부분의 physical guess가 부정확해진다.

### IOT_REDUNDANT_PKEY_ELIM
* secondary 인덱스에는 physical guess와 함께 PK 컬럼 값을 저장한다.
* 오라클은 secondary 인덱스의 logical rowid가 인덱스 키와 중복되면 이를 제거하고 젖아한다.
* `dba/all/user_indexes`를 조회하면 `iot_redundant_pkey_elim` 통계치를 볼 수 있다.
  * 이 값이 `YES`이면 secondary 인덱스 키와 PK 컬럼 간 하나 이상의 중복 컬럼이 있어 오라클이 이를 제거했다는 것을 의미한다.

## 인덱스 클러스터 테이블
* 인덱스 클러스터 테이블은 클러스터 키 값이 같은 레코드가 한 블록에 모이도록 저장하는 구조를 사용한다.
* 한 블록에 모두 담을 수 없을 경우에는 새로운 블록을 할당해 클러스터 체인으로 연결한다.
* 여러 테이블 레코드가 물리적으로 같이 저장될 수도 있다.
  * 일반적으로는 하나의 데이터 블록이 여러 테이블에 의해 공유될 수 없다.
* 인덱스 클러스터는 키 값이 같은 데이터를 한 곳에 저장해둘 뿐 IOT와 같이 정렬하진 않는다.

### 인덱스 클러스터 테이블 사용 방법
#### 인덱스 클러스터 생성
* 아래와 같이 클러스터를 생성한다.
  ```oracle
  create cluster c_deptno# ( deptno number(2) ) index;
  ```

#### 클러스터 인덱스 생성
* 그리고 클러스터에 테이블을 담기 전 클러스터 인덱스를 반드시 정의해야 한다.
  * 클러스터 인덱스는 데이터 검색 용도로 사용될 뿐만 아니라, 데이터가 저장될 위치를 찾을 때도 사용되기 때문이다.
  ```oracle
  create index i_deptno# on cluster c_deptno#
  ```
* 클러스터 인덱스는 일반적인 B-Tree 구조를 사용하지만, 해당 키 값을 저장하는 첫 번째 데이터 블록만을 기리킨다.
* 클러스터 인덱스의 키 값은 항상 Unique하며, 테이블 레코드와 1:M 관계를 갖는다.
* 클러스터 인덱스를 스캔하면서 값을 찾을 때에는 Random 액세스가 값 하나당 한번만 발생하며, 클러스터에 도달해서는 Sequential 방식으로 스캔하기 때문에 넓은 범위를 읽어도 비효율이 없다.

#### 인덱스 클러스터 테이블 생성
* 인덱스 클러스터 테이블에는 단일 테이블 인덱스 클러스터와, 다중 테이블 인덱스 클러스터 2가지 유형이 있다.
* 아래는 다중 테이블 인덱스 클러스터를 생성하는 방법이다.
  ```oracle
  create table emp
  cluster c_deptno# (deptno)
  as
  select * from scott.emp;
      
  create table dept
      cluster c_deptno# (deptno)
  as
  select * from scott.dept;
  ```
* 이렇게 다중 테이블 인덱스 클러스터를 만든 경우, `c_deptno#` 클러스터에 생성한 `i_deptno#` 인덱스를 두 테이블이 공유한다.

### 인덱스 클러스터의 장단점
1) 장점
   * 인덱스 클러스터 테이블은 넓은 범위를 검색할 때 유리하다.
     * 클러스터 키로 조회 및 조인 시 블록 I/O가 많이 줄어든다.
2) 단점
   * 하지만 클러스터 테이블은 DML부하가 심해진다.
     * 클러스터 테이블은 IOT처럼 정렬상태를 유지하진 않지만, 정해진 블록을 찾아서 값을 입력해야 해서 DML 성능이 조금 떨어진다. (클러스터 구성 없이 어차피 인덱스를 생성할거면 DML 부하는 비슷)
     * 전체 데이터 삭제 시 Truncate Table 문장을 사용할 순 없고, 클러스터를 Truncate하거나 Drop하는것이 빠르다.
   * Direct Path Loading을 수행할 수 없다.
   * 파티셔닝 기능을 함께 쓸 수 없다.
   * 다중 테이블 클러스터를 Full Scan할 때에는 다른 테이블 데이터까지 스캔하기 때문에 불리해진다.

## SIZE 옵션
* 클러스터 키 하나당 레코드 개수가 많지 않은데 클러스터마다 한 블록씩 통째로 할당하는것은 비효율적이다.
* 따라서 오라클의 경우 하나의 블록에 여러 키 값이 같이 상주할 수 있도록 SIZE 옵션을 제공한다.
* 한 블록에 여러 클러스터 키가 같이 담기더라더 하나당 가질 수 있는 최소 공간을 미리 예약하는 기능이다.
  * 즉, 하나의 블록에 담을 최대 클러스터 키 개수를 결정한다.
```oracle
create cluster emp_cluster# ( empno number(4) ) pctfree 0 size 2000 index; -- 블록크기가 8KB인 경우, 한 블록당 최대 4개 클러스터 키만 담을 수 있다.
create index emp_cluster_idx on cluster emp_cluster#;
```
* 같은 키 값을 가진 데이터를 물리적으로 서로 모아 저장하려고 클러스터 테이블을 사용하는데, 이 옵션을 너무 작게 설정하면 그 효과가 반감된다.

## 해시 클러스터 테이블
* 해시 함수에서 반환된 값이 같은 데이터를 물리적으로 함께 저장하는 구조로, 클러스터 키로 데이터를 검색하고 저장할 위치를 찾을 때 해시 함수를 사용한다.
  * 해시 함수가 클러스터 인덱스 역할을 대신 해주는 것이다.
* 해시 클러스터는 `=` 검색만 가능하다.

## IOT와 클러스터 테이블을 동시에 적용한 튜닝 사례
* p128 ~ p131 참고

# 인덱스 스캔 효율
## 비교 연산자 종류와 컬럼 순서에 따른 인덱스 레코드의 군집성
* 선행컬럼이 모두 `=` 조건인 상태에서, 첫 번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 연속되게 모여있다.
* 하지만 그 이하 조건까지 만족하는 레코드는 비교연산자 종류에 상관없이 흩어진다.
  * 선두컬럼이 범위검색 조건이면, 나머지 조건까지 만족하는 레코드는 비교연산자 종류와 상관 없이 흩어지게 된다.

## 인덱스 선행컬럼이 등치(=)조건이 아닐 때 발생하는 비효율
* 인덱스 선행컬럼이 모두 `=`조건이면 조건을 만족하는 레코드가 모두 모여있기 때문에, 필요한 범위만 스캔하고 멈출 수 있다.
* 인덱스 선행컬럼에 비교연산자를 사용하면 나머지 조건을 만족하는 레코드들이 흩어지기 때문에 조건을 만족하지 않는 레코드까지 스캔하고 버려야 하는 비효율이 생긴다.

## BETWEEN 조건을 IN-List로 바꾸었을 때 인덱스 스캔 효율
* BETWEEN 조건을 IN-List로 바꿀 수 있는 상황에서는, IN-List로 바꿔주면 큰 효과를 볼 수 있다.
* 실행계획상에서 `INLIST ITERATOR` 오퍼레이션을 확인할 수 있으며, IN-List의 수 만큼 수직적 탐색이 발생하며 레코드를 찾는다.
```
------------------------------------------------------------------------
| Id  | Operation                      | Name            | Rows | Bytes |
-------------------------------------------------------------------------
|  0  | SELECT STATEMENT               |                 |    1 |    37 |
|  1  |  INLIST ITERATOR               |                 |      |       |
|  2  |   TABLE ACCESS BY INDEX ROWID  | 매물아파트매매     |      |       |
|  3  |    INDEX RANGE SCAN            | 매물아파트매매_PK  |    1 |    37 |
------------------------------------------------------------------------
```
* IN-List 값들을 코드 테이블로 관리하고 있다면, NL방식의 조인문이나 서브쿼리로 구현하면 된다.

### BETWEEN 조건을 IN-List로 바꿀 때 주의사행
* IN-List 개수가 많지 않아야 한다.
  * 개수가 많다면 범위를 스캔하는 비효율은 사라지지만 수직적 탐색이 여러번 발생한다.
  * 따라서 브랜치 블록을 반복 탐색하는 비효율이 더 클 수 있으며, 인덱스 높이가 높을 때 더욱 그렇다.
* 인덱스 스캔 과정에서 선택되는 레코드들이 멀리 떨어져 있을 때만 유용하다.
  * 많은 레코드를 스캔하는 비효율이 있더라도, 블록 I/O 측면에서는 대개 소량에 그치는 경우가 많다.
  * 인덱스 리프 블록에는 테이블 블록과 다르게 매우 많은 레코드가 담기기 때문이다.

## Index Skip Scan을 이용한 비효율 해소
* 인덱스 선두컬럼이 누락되었을 때 뿐만 아니라, 선두컬럼이 범위검색 조건일 경우에도 `Index Skip Scan`이 유용할 수 있다.
* 선두 컬럼이 between과 같은 범위검색 조건일 경우엔, 나머지 검색조건을 만족하는 데이터들이 멀리 떨어져있다.
* 따라서 이럴경우엔 `Index Skip Scan`의 효과를 볼 수 있다.

## 범위검색 조건을 남용할 때 발생하는 비효율
* SQL을 편하게 작성하려는 목적으로 조건절을 모두 like로 작성하는 사람들이 있다.
```oracle
SELECT *
FROM 가입상품
WHERE 회사 = :com
  AND 지역 LIKE :reg || '%'
  AND 상품명 LIKE :prod || '%'
```
* 인덱스 스캔 범위가 늘어나 성능상 문제가 생길 수 있다. (대량일 경우엔 더 문제가 심해짐)

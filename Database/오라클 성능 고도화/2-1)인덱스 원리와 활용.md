# 인덱스 구조
## 범위 스캔
* 인덱스는 키 컬럼 순으로 정렬되어 있기 때문에, 특정 위치에서 스캔을 시작해 검색조건에 일치하지 않는 값을 만나는 순간 멈출 수 있다.
  * 즉, 인덱스는 범위 스캔이 가능하다.
* 테이블의 경우 IOT는 특정 컬럼 순으로 정렬상태를 유지하기 때문에 범위스캔이 가능하지만, IOT를 제외하면 범위스캔은 불가능하다.
  * 일반적인 힙 구조 테이블에서 범위스캔은 불가능하다.

## 인덱스 기본 구조
* 여러 종류의 인덱스 중 가장 일반적으로 사용되는 구조는 B-Tree 구조이다.
  * 루트를 포함한 브랜치 블록에 저장된 엔트리에는, 하위 노드 블록을 찾아가기 위한 DBA(Data Block Address) 정보를 갖고 있다.
  * 리프 블록에는 인덱스 키 컬럼과 함께 해당 테이블 레코드를 찾아가기 위한 주소정보 ROWID를 갖는다.

> LMC(Left Most Child)
> * 브랜치 노드의 각 엔트리는 키 값과 하위 노드를 가리키는 블록 주소를 갖는다.
> * 각 브랜치 노드의 첫 번 째 엔트리는 키 값을 갖지 않는데, 이를 LMC라고 한다.
> * LMC는 명시적인 키 값을 갖지 않더라도, 키 값을 가진 첫 번째 엔트리보다 작은 값의 의미를 갖는다.
> * 즉, 그 브랜치 블록의 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다.

* 리프 노드상의 인덱스 레코드와, 테이블 레코드 간에는 1:1 관계이다. (인덱스의 구성 컬럼이 모두 null인경우는 제외, 클러스터 인덱스인 경우는 1:M)
  * 오라클은 인덱스 구성 컬럼이 모두 null인 레코드는 저장하지 않는다. 
* 리프 노드상의 키 값과 테이블 레코드 키 값은 서로 일치한다.
* 브랜치 노드상의 레코드 개수는 하위 레벨 블록 개수와 일치한다.
* 브랜치 노드상의 키 값은 하위 노드가 갖는 값의 범위를 의미한다.

## 인덱스 탐색
* 인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 구분해 설명할 수 있다.
  * 수평적 탐색 : 범위 스캔
  * 수직적 탐색 : 수평적 탐색을 위한 시작 지점을 찾는 과정
* 특정 조건으로 검색 시 탐색이 어떤식으로 이루어지는지 알아야 한다.


## ROWID 포맷
* rowid에는 데이터파일, 번호, 로우번호 같은 테이블 레코드의 물리적 위치 정보를 포함한다.
* 오라클 7버전 까지
  * 데이터 파일 번호(4자리)
    * 데이터베이스 내에서 유일한 값
  * 블록 번호(8자리)
    * 해당 로우가 저장된 데이트 블록 번호로, 데이터파일 내에서의 상대적 번호
  * 로우 번호(4자리)
    * 블록 내에서 각 로우에 붙여진 일련번호로, 0부터 시작
  * `(블록).(로우).(데이터파일)`의 형태
* 오라클 8버전 이후
  * 데이터 오브젝트 번호(6자리)
    * 데이터베이스 세그먼트를 식별하기 위해 사용되는 데이터 오브젝트 번호
  * 데이터파일 번호(3자리)
    * 로우가 속한 데이터파일 번호로, 테이블스페이스 내에서의 상대적인 파일 번호
  * 블록번호(6자리)
    * 해당 로우가 저장된 데이터 블록 번호로, 데이터파일 내에서의 상대적 번호
  * 로우번호(3자리)
    * 블록 내에서 각 로우에 붙여진 일련번호로, 0부터 시작
  * `(데이터 오브젝트)(데이터파일)(블록)(로우)`의 형태

# 인덱스 기본 원리
## 인덱스 사용이 불가능하거나, 범위 스캔이 불가능한 경우
* 인덱스를 정상적으로 사용할 수 없는 예시
  * 인덱스 컬럼을 조건절에서 가공
    ```oracle
    select * from 업체 where substr(업체명, 1, 2) = '대한';
    ```
  * 부정형 비교를 사용
    ```oracle
    select * from 고객 where 직업 <> '학생';
    select * from 사원 where 부서코드 is not null;
    ```
  * 단일컬럼 인덱스인 경우 `is null` 조건 사용 (결합 인덱스일 때에는 구성컬럼이 모두 `null` 조건)
    ```oracle
    select * from emp where empno is null;
    ```
    * 위 예시에서도 옵티마이저가 인덱스를 사용하는 경우가 있긴 하다.
    * `empno`컬럼에 `not null` 제약이 있다면, 어차피 테이블을 스캔해도 해당 조건을 만족하는 레코드가 없음을 알기 때문에 인덱스 스캔을 통해 공집합을 리턴하기 때문이다.
    * 하지만 애초에 `not null` 컬럼을 `is null` 조건으로 검색하는 것 자체가 모순이다.

## 인덱스 컬럼의 가공
* 인덱스 컬럼을 가공하면 정상적인 `Index Range Scan`이 불가능하다.
* 특정 상황에서는 함수기반 인덱스(FBI) 생성을 고려해볼 수도 있다.

## 묵시적 형변환
* 묵시적 형변환으로, 인덱스 컬럼이 가공되어 인덱스를 사용하지 못하는 상황이 발생할 수 있다.
  * 이를 확인하고 파악하려면, 옵티마이저에 의해 일어나는 내부적인 형변환 원리를 이해하고 있어야 하고, 조인 컬럼의 데이터타입을 일일이 따져봐야 한다.
* 또한 묵시적 형변환으로, 아예 쿼리 수행 도중 에러가 발생하거나 잘못된 결과가 나오는 상황도 생긴다.
  ```oracle
  select round(avg(sal)) avg_sal
       , max(sal) max_sal 
       , max(decode(job, 'PRESIDENT', NULL, sal)) max_sal2  -- 4번째 인자 sal을 문자열로 변환했을 때 가장 큰 값을 출력하게 됨
                                                             
  from scott.emp
  ```
  * `decode`로 4번째 인자를 출력될 때, 데이터 타입은 3번째 인자의 타입으로 결정되며, `decode`는 3번째 인자가 `null`이면 `varchar2`로 취급한다.
  * 즉, 묵시적 형변환으로 인한 오류가 발생하는 예시이다.
* 묵시적 형변환 기능에 절대 의존해선 안된다.
  * 필요하다면 항상 명시적으로 변환 함수를 사용해야 한다.

# 다양한 인덱스 스캔 방식
## Index Range Scan
* 인덱스 루트 블록에서 리프 블록까지 수직적 탐색 후, 리프블록을 필요한 범위만 스캔하는 방식이다.
* B-Tree 인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식이다.
* `Index Range Scan`이 가능하게 하려면 인덱스를 구성하는 선두 컬럼이 조건절에 사용되어야 한다.
  * 그렇지 못한 상황에서 인덱스를 사용하도록 힌트로 강제한다면, `Index Full Scan` 방식으로 처리된다.
* `Index Range Scan` 과정을 거쳐 생성된 결과 집합은 인덱스 컬럼 순으로 정렬된 상태가 되기 때문에 `sort order by` 연산을 생략하거나 `min/max` 값을 빠르게 추출해낼 수 있다.
* 실행계획 상에서 `Index Range Scan`이 나타난다고해서 항상 빠른 속도를 보장하는 것은 아니며, 인덱스를 스캔하는 범위를 줄이고 테이블로 액세스하는 횟수를 줄이는게 중요하다.

## Index Full Scan
* 수직적 탐색 없이(최초 1번은 일어남), 인덱스 리프블록을 처음부터 끝까지 수평적으로 탐색하는 방식이다.
* 보통은 데이터 검색을 위한 최적의 인덱스가 없을 때 차선으로 선택된다.
* 상황에 따라, `Index Full Scan`이 전체적인 I/O면에서 유리할 수도 있다. 
  * 인덱스 선두 컬럼이 조건절에 없으면, 옵티마이저는 우선적으로 `Table Full Scan`을 고려한다.
  * 하지만 대용량 테이블이어서 `Table Full Scan`의 부담이 크다면 상황에 따라 옵티마이저는 인덱스를 활용하는 방법을 생각해볼 수 있는데, 데이터 저장 공간은, 보통 인덱스가 차지하는 면적이 테이블보다 훨씬 적기 때문이다.
  * 따라서 **인덱스 스캔 단계에서 대부분의 레코드를 필터링할 수 있고, 일부에 대해서만 테이블 액세스가 발생할 수 있다면** 전체적인 I/O에서 더 유리해진다.
* `Index Full Scan`은 `Index Range Scan`과 마찬가지로, 결과 집합이 인덱스 컬럼 순으로 정렬되므로 `Sort Order By` 연산을 생략할 목적으로 사용될 수 있다.

## Index Unique Scan
* 수직적 탐색만으로 데이터를 찾는 스캔 방식이다.
* Unique 인덱스를 통해 `=`조건으로 탐색하는 경우에 작동한다.
  * 이 경우엔 데이터 한 건을 찾는 순간 더 이상 탐색할 필요가 없기 때문이다.

## Index Skip Scan
* 루트 또는 브랜치 블록에서 읽은 컬럼 값 정보를 이용해 조건에 부합하는 레코드를 포함할 가능성이 있는 리프 블록만 골라서 액세스 하는 방식이다.
* **조건절에 빠진 선두 컬럼의 Distinct Value 개수가 적고, 후행 컬럼의 Distinct Value 개수가 많을 때 유용**하다.
* Skip에는 버퍼 `Pinning`이 활용된다.
  * 브랜치 블록 버퍼를 `Pinning` 한 채로 리프 블록을 방문했다가 다시 브랜치 블록으로 돌아와 다음 방문할 리프 블록을 찾는 과정을 반복한다.
  * 브랜치 블록 간에는 서로 연결할 수 있는 주소 정보가 없기 때문에 하나의 브랜치 블록을 모두 처리하면 그 상위 노드를 재방문한다.
  * 루트 또는 브랜치 블록을 재방문하더라도, `Pinning` 한 상태이기 때문에 추가적인 블록 I/O는 발생하지 않는다.
* `index_ss`, `no_index_ss`힌트를 사용해 유도하거나 방지할 수 있다.

### Index Skip Scan이 동작하기 위한 조건
* 인덱스 중간 컬럼에 대한 조건절이 누락된 경우에 사용될 수 있다.
  ```oracle
  -- 일별업종별거래_PK : 업종유형코드 + 업종코드 + 기준일자
  SELECT /*+ INDEX_SS(A 일별업종거래_PK) */
         기준일자, 업종코드, 체결건수, 체결수량, 거래대금
  FROM 일별업종거래 A
  WHERE 업종유형코드 = '01'
    AND 기준일자 BETWEEN '20080501' AND '20080531'
  ```
* Distinct Value가 적은 선두컬럼들이 모두 누락된 경우에도 유용하게 사용될 수 있다.
  ```oracle
  -- 일별업종별거래_PK : 업종유형코드 + 업종코드 + 기준일자
  SELECT /*+ INDEX_SS(A 일별업종거래_PK) */
         기준일자, 업종코드, 체결건수, 체결수량, 거래대금
  FROM 일별업종거래 A
  WHERE 기준일자 BETWEEN '20080501' AND '20080531'
  ```
* 선두컬럼이 부등호, between, like 같은 범위검색 조건일 경우에도 사용될 수 있다.
  ```oracle
  -- 일별업종별거래_PK : 기준일자 + 업종유형코드
  SELECT /*+ INDEX_SS(A 일별업종거래_PK) */
         기준일자, 업종코드, 체결건수, 체결수량, 거래대금
  FROM 일별업종거래 A
  WHERE 기준일자 BETWEEN '20080501' AND '20080531'
    AND 업종유형코드 = '01'
  ```

## Index Fast Full Scan
* 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock Read 방식으로 스캔하는 방식이다.
  * `Index Full Scan` 방식은 Single Block I/O 이기 때문에, 대기 이벤트가 주로 `db file squential read`로 찍힌다. 
  * `Index Fast Full Scan` 방식은 Multiblock I/O이기 때문에, 대기 이벤트가 주로 `db file scattered read`로 찍힌다.
* `Index Fast Full Scan` 방식은 인덱스 리프 노드가 갖는 연결 리스트 구조를 이용하지 않기 때문에 결과집합이 인덱스 키 순서대로 정렬되지 않는다.
* 인덱스가 파티션되어있지 않더라도 병렬 쿼리가 가능하다.
  * `Index Full Scan`의 경우 병럴스캔이 불가능하다. 
  * 병렬쿼리시 Direct Path Read 방식을 사용하기 때문에 I/O 속도가 더 빨라진다.
* `index_ffs`, `no_index_ffs` 힌트로 유도하거나 방지할 수 있다.

### Index Fast Full Scan를 고려해보면 좋을 상황
* 인덱스의 정렬이 필요 없고, `Stopkey(Top-N)`로 일찍 멈출 이점이 없는 경우
* 대량 스캔이 필요한데, 인덱스를 멀티블록으로 빠르게 읽는 게 유리한 경우
* 인덱스만으로 거의 처리 가능해서 테이블 액세스가 적거나 없는 경우 (인덱스 크게 훑고 끝)

## Index Range Scan Descending
* Index Range Scan과 기본적으로 동일한 스캔 방식으로, 인덱스를 뒤에서 앞쪽으로 스캔한다.

## And-Equal, Index Combine, Index Join
* 인덱스가 아무리 많아도 테이블당 하나만 사용하는게 일반적이지만, 오라클은 두 개 이상 인덱스를 함께 사용하는 방법도 제공한다.

### And-Equal
* 8i에서 `Index Combine` 방식 도입 후 사용할 일은 없고, 10g부터는 폐기되었다.
* 단일 컬럼의 Non-Unique 인덱스여야 함과 동시에 인덱스 컬럼이 대한 조건절이 `=`여야 동작한다.
* 인덱스 필터링을 거친 양쪽 집합은 rowid순으로 정렬되며, 양쪽을 번갈아 스캔하면서 rowid가 같은 레코드를 찾아 테이블을 액세스하는 방식이다.
* 데이터 분포도가 좋지 않아 단독으로 테이블 Random 액세스를 많이 발생시키는 단일 컬럼 인덱스를 두 개 이상(최대 5개) 결합해 테이블 액세스를 줄이려는 목적이 있다.
  * 인덱스 스캔량이 아무리 많더라도 두 인덱스를 결합하고 나서의 테이블 액세스량이 소량일때 효과가 있다.

### Index Combine
* Index Combine의 과정은 아래와 같다.
  1. 일반 B-Tree 인덱스를 스캔하면서 각 조건을 만족하는 레코드의 rowid 목록을 얻는다.
  2. 위에서 얻은 rowid 목록을 가지고 비트맵 인덱스 구조를 하나씩 만든다.
      * 이미 비트맵인덱스가 있는 테이블은 위 1~2과정을 생략한다.
  3. 비트맵 인덱스에 대한 Bit-Wise 오퍼레이션을 수행한다.
  4. Bit-Wise 오퍼레이션을 수행한 결과가 true인 비트 값들을 rowid값으로 환산해 최종적으로 방문할 테이블 rowid 목록을 얻는다.
  5. rowid를 이용해 테이블을 액세스한다.
* Index Combine은 And-Equal과 마찬가지로, 데이터 분포도가 좋지 않은 두 개 이상의 인덱스를 결합해 Random 액세스량을 줄이려는 목적이 있다.
  * 하지만 조건절이 `=`이어야 할 필요도 없고, Non-Unique 인덱스일 필요도 없다.
  * 또한 비트맵 인덱스를 이용하므로, 조건절이 OR로 결합된 경우에도 유용하다.
* `_b_tree_bitmap_plans` 파라미터가 true일때에만 동작하며, 9i부터는 기본적으로 true로 설정되어있다.

```oracle
select /*+ index_combine(e emp_deptno_idx emp_job_idx */ *
from emp e
where deptno = 30
  and job = 'SALESMAN'
```
```
-----------------------------------------------------------------------------
| Id  | Operation                          | Name            | Rows  | Cost |
-----------------------------------------------------------------------------
|  0  | SELECT STATEMENT                   |                 |       |      |
|  1  |  TABLE ACCESS BY INDEX ROWID       | EMP             |       |      |
|  2  |   BITMAP CONVERSION TO ROWIDS      |                 |       |      |
|  3  |    BITMAP AND                      |                 |       |      |
|  4  |     BITMAP CONVERSION FROM ROWIDS  |                 |       |      |
|  5  |      INDEX RANGE SCAN              | EMP_JOB_IDX     |       |      |
|  6  |     BITMAP CONVERSION FROM ROWIDS  |                 |       |      |
|  7  |      INDEX RANGE SCAN              | EMP_DEPTNO_IDX  |       |      |
-----------------------------------------------------------------------------
```

### Index Join
* `Index Join`은 한 테이블에 속한 여러 인덱스를 이용해 테이블 액세스 없이 결과집합을 만들 때 사용하는 인덱스 스캔 방식이다.
* `Index Join`의 과정은 아래와 같다.
  1. 크기가 비교적 작은 쪽 인덱스에서, 키 값과 rowid를 읽어 PGA 메모리에 해시 맵을 생성한다. (해시 키로 rowid 사용)
  2. 다른쪽 인덱스를 스캔하면서 위에서 생성한 해시맵에 같은 rowid값을 갖는 레코드가 있는지 탐색한다.
  3. rowid끼리 조인에 성공한 레코드만 결과집합에 포함시킨다. (각 인덱스 컬럼에 대한 조건을 모두 만족한다는 의미)
* `Index Join`은 쿼리에 사용된 컬럼들이 인덱스에 모두 포함될 때에만 작동한다.
  * 둘 중 어느 한쪽에 포함되기만 하면 된다.
```oracle
select /*+ index_join(e emp_deptno_idx emp_job_idx) */ deptno, job
from emp e
where deptno = 30
  and joib = 'SALESMAN';
```
```
------------------------------------------------------------------------
| Id  | Operation                      | Name            | Rows | Cost |
------------------------------------------------------------------------
|  0  | SELECT STATEMENT               |                 |    1 |    3 |
|  1  |  VIEW                          | index$_join$_001|    1 |    3 |
|  2  |   HASH JOIN                    |                 |      |      |
|  3  |    INDEX RANGE SCAN            | EMP_JOB_IDX     |    1 |    1 |
|  4  |    INDEX RANGE SCAN            | EMP_DEPTNO_IDX  |    1 |    1 |
------------------------------------------------------------------------
```

# 테이블 Random 액세스 부하
## 인덱스 ROWID에 의한 테이블 액세스
* rowid는 물리적 주소정보라고 말하는 사람도 많지만, 논리적 주소정보라고 표현하기도 한다.
  * rowid가 물리적 위치 정보로 구성되어있긴 하지만, 테이블 레코드로 직접 연결된 구조는 아니기 때문이다.
* 오라클은 테이블 블록이 수시로 버퍼 캐시에서 밀려났다가 다시 캐싱되며, 그때마다 다른 공간에 캐싱되기 때문에 인덱스에서 직접 포인터로 연결할 수 없는 구조이다.
* 인덱스 rowid는 테이블 레코드와 물리적으로 연결되어있지 않기 때문에 인덱스를 통한 테이블 액세스는 생각보다 고비용 구조이다.
  * 모든 데이터가 메모리에 캐싱되어 있더라도 테이블 레코드를 찾기 위해 매번 DBA를 해싱하고 래치획득 과정을 반복해야 한다.
  * 동시 액세스가 심할 때에는 래치와 버퍼 Lock에 대한 경합까지 발생하게 된다.

## 인덱스 클러스터링 팩터
* 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다.
* CF가 좋은 컬럼에 생성한 인덱스는 검색효율이 매우 좋다.
* 데이터가 물리적으로 근접해 있다면 흩어져 있을 때보다 데이터를 찾는 속도가 빨라진다.

### 클러스터링 팩터 조회
* 오라클은 아래와 같이 CF를 계산한다.
  * counter 변수를 하나 선언한다.
  * 인덱스 리프 블록을 처음부터 끝까지 스캔하며 인덱스 rowid로부터 블록 번호를 취한다.
  * 현재 읽고 있는 인덱스 레코드의 블록 번호가 바로 직전에 읽은 레코드의 블록 번호와 다를때마다 counter 변수 값을 1씩 증가시킨다.
  * 스캔 완료 후 최종 counter 변수 값을 `clustering_factor`로 인덱스 통계에 저장한다.
* 이런식으로 측정된 CF는 옵티마이저가 `Index Range Scan`을 통한 테이블 액세스 비용을 평가하는데 사용된다.
  ```
  비용 = blevel +                           -- 인덱스 수직적 탐색 비용
        (리프 블록 수 * 유효 인덱스 선택도) +   -- 인덱스 수평적 탐색 비용
        (클러스터링 팩터 * 유효 테이블 선택도)   -- 테이블 Random 액세스 비용
  ```

### 클러스터링 팩터와 I/O
#### 물리적 I/O
* 오라클에서 I/O는 블록 단위로 이루어지기 때문에, 인덱스를 통해 하나의 레코드를 읽으면 같은 블록에 속한 다른 레코드들도 함께 캐싱되는 결과를 가져온다.
* 따라서 CF가 좋은 인덱스였다면 그 레코드들도 가까운 시점에 읽힐 가능성이 높기 때문에, 인덱스를 스캔하면서 읽는 테이블 블록들의 캐시 히트율이 높아져 물리적인 디스크 I/O 횟수가 감소한다.

#### 논리적 I/O
* 인덱스 CF는, 인덱스를 경유해 테이블 전체 로우를 액세스할 때 읽을 것으로 예상되는 논리적인 블록 개수를 의미한다.
* CF가 가장 좋을 때는 통계에 나타나는 `clustering_factor`가 전체 테이블 블록 개수와 일치하며, 가장 안좋을 때는 총 레코드 개수와 일치한다.
  * 만약 모든 블록에 레코드가 하나씩만 저장되어 있다면 `clustering_factor`는 총 레코드 개수와 일치할 것이다.
* 똑같은 개수의 레코드를 읽어도 인덱스 CF에 따라 논리적인 블록 I/O가 차이나는 이유는 버퍼 Pinning 때문이다.
  * 연속된 인덱스 레코드가 같은 블록을 가리키면, 래치 획득 과정을 생략하고 버퍼를 Pin한 상태에서 읽기 때문에 논리적인 블록 읽기 횟수가 증가하지 않는다.

## 인덱스 손익분기점
* 인덱스 rowid에 의한 테이블 액세스는 생각보다 고비용구조이기 때문에, 일정량을 넘는 순간 `Full Table Scan`보다 느려질 수 있다.
  * 인덱스 rowid에 의한 테이블 액세스는 Random 액세스이지만, `Full Table Scan`은 Sequential 액세스 방식으로 이루어진다.
  * 디스크 I/O 시, 인덱스 rowid에 의한 테이블 액세스는 `Single Block Read` 방식을 사용하지만, `Full Table Scan`은 `Multiblock Read` 방식을 사용한다. 
* 인덱스 손익분기점은 CF에 따라 크게 달라진다.
  * 인덱스 손익분기점은 일반적으로 5~20%의 낮은 수준에서 결정되지만, CF가 나쁘면 5%미만에서 결정되며, CF가 좋을 경우엔 90%까지 올라가기도 한다.

### 손익분기점을 극복하기 위한 기능
#### IOT
* IOT는 테이블을 인덱스 구조로 생성하는 것이다.
* 테이블 자체가 인덱스 구조이므로 항상 정렬된 상태를 유지한다.
* 인덱스 리프 블록이 곧 데이터 블록이기 때문에, 인덱스를 수직 탐색한 다음에 테이블 레코드를 읽기 위한 Random 액세스가 불필요하다.

#### 클러스터 테이블
* 키 값이 같은 레코드는 같은 블록에 모이도록 저장한다.
* 클러스터 인덱스를 이용할 때는 테이블 Random 액세스가 키 값별로 한 번씩만 발생한다.
* 클러스터에 도달해서는 Sequential 방식으로 스캔하기 때문에 넓은 범위를 읽더라도 비효율은 없다.

#### 파티셔닝
* 읽고자 하는 데이터가 많을 때는 인덱스를 이용하지 않는것이 좋지만, 초대용량 테이블은 Full Scan하기 쉽지 않다.
* 대량 범위 조건으로 자주 사용되는 컬럼을 기준으로 테이블을 파티셔닝 한다면 Full Table Scan 하더라도 일부 파티션만 읽고 멈추도록 할 수 있다.
* 클러스터 테이블은 기준 키 값이 같은 레코드를 블록 단위로 모아놓지만, 파티셔닝은 세그먼트 단위로 모아놓는다는 것이다.

# 테이블 Random 액세스 최소화 튜닝
* 인덱스 컬럼 추가 예시 (p79 ~ p82)
  * 기존 사용하던 인덱스가 있었고, 인덱스를 새로만들기에는 부담이 되는 상황에서 기존 인덱스에 컬럼을 하나 추가하는 예시
* PK 인덱스에 컬럼 추가 예시 (p82 ~ p84)
  * 조인 시 효율을 위해 `[PK 컬럼 + 필터조건 컬럼]` 구조의 새로운 인덱스를 추가해야 하는 상황에서, PK 제약을 drop 후 `[PK 컬럼 + 필터조건 컬럼]`의 인덱스로 새로운 PK제약을 만드는 예시
* 컬럼 추가에 따른 클러스터링 팩터 변화 예시 (p84 ~ p86)
  * 인덱스 추가 후 CF 변화가 생기는 예시 
  * 인덱스에 컬럼을 추가함으로써 Random 액세스 부하를 줄이는 효과는 있지만, 인덱스 클러스터링 팩터가 나빠질 수 있다.
  * 인덱스에 변별력이 좋지 않은 컬럼 뒤에 변별력이 좋은 다른 컬럼을 추가할 때 CF 변화의 주의를 해야 한다.  
* 인덱스만 읽고 처리하는 예시 (p86 ~ p92)
  * 실행계획 상에서, 많은 Random 액세스를 발생시키는 부분을 Covered 인덱스를 사용해 Random 액세스를 줄이는 예시
* 버퍼 Pinning 효과 활용 예시 (p92 ~ p94)
  * 인라인 뷰에서 읽은 rowid 값을 이용해 테이블을 액세스하는 예시
  * 오라클의 경우 한번 입력된 테이블 레코드는 rowid가 절대 바뀌지 않는다.
  * 따라서 미리 알고 있던 테이블 rowid값을 이용해 레코드를 조회하는 것이 가능하다.
* 수동으로 클러스터링 팩터를 높이는 예시 (p94 ~ p97)
  * CF가 나쁜 인덱스를 기준으로 테이블을 재생성하여 CF를 인위적으로 좋게 만드는 예시
  * 인위적으로 CF를 높일 목적으로 테이블을 Reorg할 때에는 가장 자주 사용되는 인덱스를 기준으로 삼아야 한다.
  * 인덱스들 컬럼 간 상관관계가 높지 않다면 CF가 좋은 인덱스는 테이블당 하나이다.

# IOT, 클러스터 테이블 활용
* 오라클에선 테이블을 아예 인덱스 구조로 생성할 수 있도록 기능을 제공하는데, 이것을 IOT(Index-Organized Table)라고 한다.
* IOT에서는 인덱스 리프 블록이 곧 데이터 블록이다.

## IOT의 장단점
1) 장점
   * 같은 값을 가진 레코드들이 정렬된 상태로 모여있기 때문에, Random 액세스가 아닌 Sequential 방식으로 데이터를 액세스할 수 있어 넓은 범위를 액세스할 때 유리하다.
   * PK 인덱스를 위한 별도의 세그먼트를 생성하지 않아도 되기 때문에 저장공간이 절약된다.
2) 단점
   * 데이터 입력 시 성능이 느리다.
   * 인덱스 분할(Split) 발생량으로 인한 성능 차이가 크며, 컬럼수가 많을수록 인덱스 분할 발생 빈도도 높아진다.
   * Direct Path Insert가 작동하지 않는다.

## IOT가 유용한 상황
### 크기가 작고 NL 조인으로 반복 룩업하는 테이블
* 코드성 테이블이 주로 여기에 속한다. 
  * NL 조인에서 Inner 쪽 룩업 테이블로서 액세스 되는 동안 건건이 인덱스와 테이블 블록을 다 읽으면 비효율적이다.
* 하지만 IOT 구성 시 PK 이외의 속성이 커 인덱스 높이가 증가한다면 역효과가 날 수 있다.

### 폭이 좁고 긴(로우수가 많은) 테이블 
* N:M 관계를 해소하기 위한 Association 테이블이 주로 여기에 속한다.
  * PK 컬럼 이외의 컬럼이 전혀 없거나 있더라도 아주 소수에 불과하기 때문이다.

### 넓은 범위를 주로 검색하는 테이블
* Between, Like 같은 조건으로 넓은 범위를 검색하는 테이블이라면 IOT를 고려해볼만하다.
* PK 이외의 컬럼이 별로 없는 통계성 테이블에 최적이다. 
  * 이런 통계성 테이블은 PK 컬럼은 많고 일반 속성은 적은 상황이 많다.
 
### 데이터 입력과 조회 패턴이 서로 다른 테이블
* 조회패턴에 맞게 IOT를 구성해 주면 작은 블록만 읽고 처리할 수 있다.

## Partitioned IOT
```oracle
select 거래일자, 지점번호, 계좌번호, sum(거래량), sum(거래금액)
from 일별상품별계좌별거래
where 상품번호 = 'P7001234123'
and 거래일자 between '20250101' and '20250630'
group by 거래일자, 지점번호, 계좌번호
```
* 위 예시와 같이 대용량의 테이블에서 기간검색이 필요한 경우, 아래와같은 문제들이 발생할 수 있다.
  * 인덱스를 사용하면 Random 액세스 부하가 심하게 발생한다.
  * Range 파티셔닝을 이용하면 필요한 파티션만 Full Scan하면 되겠지만 그 기간내의 데이터를 모두 읽는 비효율이 생긴다.
  * IOT로 구성하면 읽기 성능은 개선되겠지만, 초대용량 테이블을 단일 IOT로 구성하는 것은 쉽지 않다.
* 이럴 경우 Partitioned IOT가 좋은 해결책이 된다.
  * `거래일자` 컬럼을 기준으로 Range 파티셔닝
  * `[상품번호 + 거래일자]` 순으로 PK를 정의하고 IOT를 구성

## Overflow 영역
* PK 이외 컬럼이 많은 테이블일수록 IOT로 구성하기엔 부적합하다.
  * 인덱스 분할에 의한 DML 부하 및 검색을 위한 스캔량도 늘어난다.
* 그럼에도 불구하고 IOT가 꼭 필요하다면 `Overflow` 기능을 사용해볼 수 있다.
```oracle
CREATE TABLE 불공정거래적축 (
    종목코드        VARCHAR2(12) NOT NULL  -- PK속성
  , 적출일자        VARCHAR2(12) NOT NULL  -- PK속성
  , 회원번호        VARCHAR2(12) NOT NULL  -- PK속성
  , 지점번호        VARCHAR2(12) NOT NULL  -- PK속성
  , 계좌번호        VARCHAR2(12) NOT NULL  -- PK속성
  , 적출유형코드     VARCHAR2(12) NOT NULL  -- PK속성
  , 상품구분코드     VARCHAR2(12) NOT NULL 
  , 적출건수        VARCHAR2(12) NOT NULL
  , 생성자ID        VARCHAR2(12) NOT NULL  -- 시스템 관리 속성
  , 수정자ID        VARCHAR2(12) NOT NULL  -- 시스템 관리 속성
  , 생성일시        VARCHAR2(12) NOT NULL  -- 시스템 관리 속성
  , 수정일시        VARCHAR2(12) NOT NULL  -- 시스템 관리 속성
  , CONSTRAINT 불공정거래적출_PK PRIMARY KEY
      ( 종목코드, 적출일자, 회원번호, 지점번호, 계좌번호, 적출유형코드 )
)
ORGANIZATION INDEX
PCTTHRESHOLD 30
INCLUDInG 적출건수
OVERFLOW TABLESPACE TBS_OVRFL01
```
* 위와같이 Overflow를 사용할 수 있다.
  * `OVERFLOW TABLESPACE` : Overflow 세그먼트가 저장될 Tablespace를 지정
  * `PCTTHRESHOLD` : 값이 30인 경우엔 Block 크기의 30%를 초과하기 직전 컬럼까지만 Index Block에 저장하고, 뒤 쪽 컬럼은 Overflow 세그먼트에 저장한다.
    * 로우 전체 크기가 지정된 비율 크기보다 작다면 모두 인덱스 블록에 저장하게 된다.
    * 따라서 테이블 생성 시점에모든 컬럼의 데이터타입 Max길이를 합산한 크기가 이 비율 크기보다 크면 `OVERFLOW TABLESPACE` 옵션을 반드시 지정하도록 강제하는 에러를 던진다.
    * DEFAULT값은 50이다.
  * `INCLUDING` : 여기에 지정한 컬럼까지만 인덱스 블록에 저장하고 나머지는 무조건 Overflow 세그먼트에 저장한다.
* Overflow영역을 읽을 때 건건이 Random 액세스는 발생한다.
  * Overflow 세그먼트에 저장된 컬럼 중 일부를 자주 액세스하는 상황에서는 부적절하다.
* Overflow 영역에도 버퍼 Pinning 은 동작하기 때문에 연속적으로 같은 Overflow블록을 읽을 때에는 Random 액세스를 최소화할 수 있다.

## Secondary 인덱스
* IOT는 secondary 인덱스 추가 가능성이 크지 않을 때만 선택하는 것이 바람직하다.

### 오라클 Logical Rowid
* IOT 레코드의 위치는 영구적이지 않기 때문에 오라클은 secondary 인덱스로부터 IOT 레코드를 가리킬 때 물리적 주소 대신 logical rowid를 사용한다.
  * `Logical Rowid = PK + physical guess`
* physical guess는 secondary 인덱스를 최초로 생성하거나 재생성한 시점에 IOT레코드가 위치했던 데이터 블록 주소(DBA)이다.
  * 인덱스 분할에 의해 IOT 레코드가 다른 블록으로 이동하더라도, secondary 인덱스에 저장된 physical guess 값은 갱신되지 않는다.

### PCT_DIRECT_ACCESS
* `dba/all/user_indexes` 테이블을 조회하면 pct_direct_access 값을 확인할 수 있다.
* secondary 인덱스가 유효한 physical guess를 가진 비율을 나타내는 지표로, secondary 인덱스 탐색 효율을 결정짓는 중요한 값이다.
* 레코드 위치가 자주 변하는 IOT의 경우 시간이 지나면서 physical guess에 의한 액세스 실패 확률이 높아지기 때문에 성능이 저하된다.
* 이럴 경우 통계정보를 다시 수집해 pct_direct_access가 실제 physical guess 성공률을 반영하도록 해줘야 한다.
  * 물론, 인덱스를 `REBUILD` 하거나 `UPDATE BLOKC REFERENCES`를 주기적으로 갱신해줄 수 있다면 가장 효과적이다.

### 비휘발성 IOT에 대한 Secondary 인덱스 튜닝 방안
* 비휘발성 IOT의 경우 Direct 액세스 성공률이 높다.
* 따라서 pct_direct_access 값이 100을 가리키도록 유지하는것이 좋다.
  * 한달에 한번이나 일년에 한번 정도 physical guess를 갱신해주면 된다.

### 비휘발성 IOT에 대한 Secondary 인덱스 튜닝 방안
* 휘발성이 강한 IOT에 secondary 인덱스를 추가할 때에는 주의가 필요하며, 처음 IOT 설계때부터 이에 대한 고려가 있어야 한다.
* 휘발성이어서 physical guess에 의한 Direct 액세스 성공률이 낮다면 두가지 방법이 있다.
  1) 주기적으로 physical guess를 정확한 값으로 갱신해준다.
  2) 주기적으로 physical guess를 갱신할 수 없다면 pct_direct_access 값을 100미만으로 떨어뜨린다.

### Right-Growing IOT에서 pct_direct_access가 100 미만으로 떨어지는 이유
* 우측 leaf 블록에서 split이 반복적으로 발생할 수 있고, 누적되면 branch split, root block split으로 이어질 수 있다.
* 인덱스 높이가 증가하는 시점에서는 secondary 인덱스에서 대부분의 physical guess가 부정확해진다.

### IOT_REDUNDANT_PKEY_ELIM
* secondary 인덱스에는 physical guess와 함께 PK 컬럼 값을 저장한다.
* 오라클은 secondary 인덱스의 logical rowid가 인덱스 키와 중복되면 이를 제거하고 젖아한다.
* `dba/all/user_indexes`를 조회하면 `iot_redundant_pkey_elim` 통계치를 볼 수 있다.
  * 이 값이 `YES`이면 secondary 인덱스 키와 PK 컬럼 간 하나 이상의 중복 컬럼이 있어 오라클이 이를 제거했다는 것을 의미한다.

## 인덱스 클러스터 테이블
* 인덱스 클러스터 테이블은 클러스터 키 값이 같은 레코드가 한 블록에 모이도록 저장하는 구조를 사용한다.
* 한 블록에 모두 담을 수 없을 경우에는 새로운 블록을 할당해 클러스터 체인으로 연결한다.
* 여러 테이블 레코드가 물리적으로 같이 저장될 수도 있다.
  * 일반적으로는 하나의 데이터 블록이 여러 테이블에 의해 공유될 수 없다.
* 인덱스 클러스터는 키 값이 같은 데이터를 한 곳에 저장해둘 뿐 IOT와 같이 정렬하진 않는다.

### 인덱스 클러스터 테이블 사용 방법
#### 인덱스 클러스터 생성
* 아래와 같이 클러스터를 생성한다.
  ```oracle
  create cluster c_deptno# ( deptno number(2) ) index;
  ```

#### 클러스터 인덱스 생성
* 그리고 클러스터에 테이블을 담기 전 클러스터 인덱스를 반드시 정의해야 한다.
  * 클러스터 인덱스는 데이터 검색 용도로 사용될 뿐만 아니라, 데이터가 저장될 위치를 찾을 때도 사용되기 때문이다.
  ```oracle
  create index i_deptno# on cluster c_deptno#
  ```
* 클러스터 인덱스는 일반적인 B-Tree 구조를 사용하지만, 해당 키 값을 저장하는 첫 번째 데이터 블록만을 기리킨다.
* 클러스터 인덱스의 키 값은 항상 Unique하며, 테이블 레코드와 1:M 관계를 갖는다.
* 클러스터 인덱스를 스캔하면서 값을 찾을 때에는 Random 액세스가 값 하나당 한번만 발생하며, 클러스터에 도달해서는 Sequential 방식으로 스캔하기 때문에 넓은 범위를 읽어도 비효율이 없다.

#### 인덱스 클러스터 테이블 생성
* 인덱스 클러스터 테이블에는 단일 테이블 인덱스 클러스터와, 다중 테이블 인덱스 클러스터 2가지 유형이 있다.
* 아래는 다중 테이블 인덱스 클러스터를 생성하는 방법이다.
  ```oracle
  create table emp
  cluster c_deptno# (deptno)
  as
  select * from scott.emp;
      
  create table dept
      cluster c_deptno# (deptno)
  as
  select * from scott.dept;
  ```
* 이렇게 다중 테이블 인덱스 클러스터를 만든 경우, `c_deptno#` 클러스터에 생성한 `i_deptno#` 인덱스를 두 테이블이 공유한다.

### 인덱스 클러스터의 장단점
1) 장점
   * 인덱스 클러스터 테이블은 넓은 범위를 검색할 때 유리하다.
     * 클러스터 키로 조회 및 조인 시 블록 I/O가 많이 줄어든다.
2) 단점
   * 하지만 클러스터 테이블은 DML부하가 심해진다.
     * 클러스터 테이블은 IOT처럼 정렬상태를 유지하진 않지만, 정해진 블록을 찾아서 값을 입력해야 해서 DML 성능이 조금 떨어진다. (클러스터 구성 없이 어차피 인덱스를 생성할거면 DML 부하는 비슷)
     * 전체 데이터 삭제 시 Truncate Table 문장을 사용할 순 없고, 클러스터를 Truncate하거나 Drop하는것이 빠르다.
   * Direct Path Loading을 수행할 수 없다.
   * 파티셔닝 기능을 함께 쓸 수 없다.
   * 다중 테이블 클러스터를 Full Scan할 때에는 다른 테이블 데이터까지 스캔하기 때문에 불리해진다.

## SIZE 옵션
* 클러스터 키 하나당 레코드 개수가 많지 않은데 클러스터마다 한 블록씩 통째로 할당하는것은 비효율적이다.
* 따라서 오라클의 경우 하나의 블록에 여러 키 값이 같이 상주할 수 있도록 SIZE 옵션을 제공한다.
* 한 블록에 여러 클러스터 키가 같이 담기더라더 하나당 가질 수 있는 최소 공간을 미리 예약하는 기능이다.
  * 즉, 하나의 블록에 담을 최대 클러스터 키 개수를 결정한다.
```oracle
create cluster emp_cluster# ( empno number(4) ) pctfree 0 size 2000 index; -- 블록크기가 8KB인 경우, 한 블록당 최대 4개 클러스터 키만 담을 수 있다.
create index emp_cluster_idx on cluster emp_cluster#;
```
* 같은 키 값을 가진 데이터를 물리적으로 서로 모아 저장하려고 클러스터 테이블을 사용하는데, 이 옵션을 너무 작게 설정하면 그 효과가 반감된다.

## 해시 클러스터 테이블
* 해시 함수에서 반환된 값이 같은 데이터를 물리적으로 함께 저장하는 구조로, 클러스터 키로 데이터를 검색하고 저장할 위치를 찾을 때 해시 함수를 사용한다.
  * 해시 함수가 클러스터 인덱스 역할을 대신 해주는 것이다.
* 해시 클러스터는 `=` 검색만 가능하다.

## IOT와 클러스터 테이블을 동시에 적용한 튜닝 사례
* p128 ~ p131 참고

# 인덱스 스캔 효율
## 비교 연산자 종류와 컬럼 순서에 따른 인덱스 레코드의 군집성
* 선행컬럼이 모두 `=` 조건인 상태에서, 첫 번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 연속되게 모여있다.
* 하지만 그 이하 조건까지 만족하는 레코드는 비교연산자 종류에 상관없이 흩어진다.
  * 선두컬럼이 범위검색 조건이면, 나머지 조건까지 만족하는 레코드는 비교연산자 종류와 상관 없이 흩어지게 된다.

## 인덱스 선행컬럼이 등치(=)조건이 아닐 때 발생하는 비효율
* 인덱스 선행컬럼이 모두 `=`조건이면 조건을 만족하는 레코드가 모두 모여있기 때문에, 필요한 범위만 스캔하고 멈출 수 있다.
* 인덱스 선행컬럼에 비교연산자를 사용하면 나머지 조건을 만족하는 레코드들이 흩어지기 때문에 조건을 만족하지 않는 레코드까지 스캔하고 버려야 하는 비효율이 생긴다.

## BETWEEN 조건을 IN-List로 바꾸었을 때 인덱스 스캔 효율
* BETWEEN 조건을 IN-List로 바꿀 수 있는 상황에서는, IN-List로 바꿔주면 큰 효과를 볼 수 있다.
* 실행계획상에서 `INLIST ITERATOR` 오퍼레이션을 확인할 수 있으며, IN-List의 수 만큼 수직적 탐색이 발생하며 레코드를 찾는다.
```
------------------------------------------------------------------------
| Id  | Operation                      | Name            | Rows | Bytes |
-------------------------------------------------------------------------
|  0  | SELECT STATEMENT               |                 |    1 |    37 |
|  1  |  INLIST ITERATOR               |                 |      |       |
|  2  |   TABLE ACCESS BY INDEX ROWID  | 매물아파트매매     |      |       |
|  3  |    INDEX RANGE SCAN            | 매물아파트매매_PK  |    1 |    37 |
------------------------------------------------------------------------
```
* IN-List 값들을 코드 테이블로 관리하고 있다면, NL방식의 조인문이나 서브쿼리로 구현하면 된다.

### BETWEEN 조건을 IN-List로 바꿀 때 주의사행
* IN-List 개수가 많지 않아야 한다.
  * 개수가 많다면 범위를 스캔하는 비효율은 사라지지만 수직적 탐색이 여러번 발생한다.
  * 따라서 브랜치 블록을 반복 탐색하는 비효율이 더 클 수 있으며, 인덱스 높이가 높을 때 더욱 그렇다.
* 인덱스 스캔 과정에서 선택되는 레코드들이 멀리 떨어져 있을 때만 유용하다.
  * 많은 레코드를 스캔하는 비효율이 있더라도, 블록 I/O 측면에서는 대개 소량에 그치는 경우가 많다.
  * 인덱스 리프 블록에는 테이블 블록과 다르게 매우 많은 레코드가 담기기 때문이다.

## Index Skip Scan을 이용한 비효율 해소
* 인덱스 선두컬럼이 누락되었을 때 뿐만 아니라, 선두컬럼이 범위검색 조건일 경우에도 `Index Skip Scan`이 유용할 수 있다.
* 선두 컬럼이 between과 같은 범위검색 조건일 경우엔, 나머지 검색조건을 만족하는 데이터들이 멀리 떨어져있다.
* 따라서 이럴경우엔 `Index Skip Scan`의 효과를 볼 수 있다.

## 범위검색 조건을 남용할 때 발생하는 비효율
* SQL을 편하게 작성하려는 목적으로 조건절을 모두 like로 작성하는 사람들이 있다.
```oracle
SELECT *
FROM 가입상품
WHERE 회사 = :com
  AND 지역 LIKE :reg || '%'
  AND 상품명 LIKE :prod || '%'
```
* 인덱스 스캔 범위가 늘어나 성능상 문제가 생길 수 있다. (대량일 경우엔 더 문제가 심해짐)

## 같은 컬럼에 두 개의 범위검색 조건을 사용 시 주의사항
* 같은 컬럼에 두 개의 범위검색 조건을 사용할 때에도 문제가 생길 수 있다.

```oracle
select *
from (
    -- 이전페이지의 마지막 레코드와 같은 이름의 도서가 있을 수 있음
    select /*+ index(도서 도서명_idx)*/ 
           rowid rid, 도서번호, 도서명, 가격, 저자, 출판사, isbn
    from 도서
    where 도서명 like :book_nm || '%'
      and 도서명 = :last_book_nm
      and rowid > :last_rid
    union all
    -- 이전페이지 마지막 레코드와 다른 이름의 도서를 출력
    select /*+ index(도서 도서명_idx) */
           rowid rid, 도서번호, 도서명, 가격, 저자, 출판사, isbn
    from 도서
    where 도서명 like :book_nm || '%'
    and 도서명 > :last_book_nm
     )
where rownum <= 10
```
* 위 예시에서는 union all 아래쪽 쿼리에서 인덱스 스캔단계에서 많은 블록을 읽는다.
* `도서명`에대한 범위검색 조건이 2개인데, 그 중에서 like 조건을 인덱스 액세스 조건으로 사용했기 때문이다.
* 따라서 아래와 같이 쿼리를 수정할 수 있다.
  ```oracle
  select *
  from (
      -- 이전페이지의 마지막 레코드와 같은 이름의 도서가 있을 수 있음
      select /*+ index(도서 도서명_idx)*/ 
             rowid rid, 도서번호, 도서명, 가격, 저자, 출판사, isbn
      from 도서
      where 도서명 like :book_nm || '%'
        and 도서명 = :last_book_nm
        and rowid > :last_rid
      union all
      -- 이전페이지 마지막 레코드와 다른 이름의 도서를 출력
      select /*+ index(도서 도서명_idx) */
             rowid rid, 도서번호, 도서명, 가격, 저자, 출판사, isbn
      from 도서
      where rtrim(도서명) like :book_nm || '%' -- 좌변 컬럼을 가공하여
      and 도서명 > :last_book_nm               -- 이 조건이 인덱스 액세스 조건으로 사용되도록 수정
       )
  where rownum <= 10
  ```

### OR-Expansion을 이용하는 방법 및 주의사항
* 위 예시에서, `use_concat`힌트를 사용하면 union all 을 사용할 때보다 간편하게 쿼리를 작성할 수 있다.
* OR-Expansion이 일어나면, 뒤쪽 조건절이 먼저 실행된다는 특징을 이용한 것이다.
```oracle
select /*+ index(도서 도서명_idx) use_concat ordered_predicates */
       rowid rid, 도서번호, 도서명, 가격, 저자, 출판사, isbn
from 도서
where 도서명 like :book_nm || '%'
  and ((도서명 > :last_book_nm)
        or
       (도서명 =:last_book_nm and rowid > :last_rid))
  and rownum <= 10
```
* 하지만 주의해야 할 점은, 버전에 따라 실행되는 순서가 달라진다.
  * 9i까지는 I/O 비용 모델, CPU 비용 모델 상관 없이 뒤쪽에 있는 조건 값을 먼저 실행한다.
  * 10g CPU 비용 모델에서는 계산된 카디널리티가 낮은 쪽을 먼저 실행한다.
* 따라서 값 분포에 상관없이 뒤쪽에 있는 조건식이 먼저 처리되도록 하려면 `ordered_predicates` 힌트를 명시해야 한다.

### rowid를 concatenation하면 결과에 오류 발생
```oracle
select /*+ indeX(도서 도서명_idx) */
       rowid rid, 도서번호, 도서명, 가격, 저자, 출판사, isbn
from 도서
where 도서명 like :book_nm || '%'
  and 도서명 >= :last_book_nm
  and lpad(도서명, 50) || rowid > lpad(:last_book_nm, 50) || :last_rid
  and rownum <= 10
```
* rowid 값 비교에 의해 한번 더 필터링이 이루어지도록 만든 쿼리이지만, 위 쿼리는 아래와 같은 형태로 형변환이 일어난다.
  ```oracle
  select /*+ indeX(도서 도서명_idx) */
         rowid rid, 도서번호, 도서명, 가격, 저자, 출판사, isbn
  from 도서
  where 도서명 like :book_nm || '%'
    and 도서명 >= :last_book_nm
    and lpad(도서명, 50) || rowidtochar(rowid) > lpad(:last_book_nm, 50) || :last_rid -- 이부분
  ```
* 또한 문자형으로 변환된 rowid는 rowid값 그대로 비교할 때와 정렬 순서가 다르기 때문에, 쿼리의 결과 집합이 틀려질 수 있다.

### 인덱스를 스캔하면서 rowid를 필터링할 때 발생하는 비효율
```oracle
select /*+ index(도서 도서명_idx)*/ 
           rowid rid, 도서번호, 도서명, 가격, 저자, 출판사, isbn
    from 도서
    where 도서명 like :book_nm || '%'
      and 도서명 = :last_book_nm
      and rowid > :last_rid
```
* 위 쿼리는 rowid를 이용한 액세스여서 비효율이 없을 것 같지만 그렇지 않다.
* rowid를 가지고 `=`조건으로 액세스할 때에는 어떤 액세스보다 빠르지만, 인덱스를 스캔하면서 rowid를 필터링할 때에는 아니다.
* 인덱스의 rowid는 리프블록에만 있기 때문에, 필터링하려면 다른 액세스 조건만으로 리프블록을 찾아가야 한다.
* 즉, 같은 `도서명`을 가진 레코드가 아주 많다면 비효율이 커진다.
* 따라서 아래와 같이 `도서명` 관련 인덱스 뒤에 PK를 붙이고 쿼리를 아래와 같이 수정하면 된다.
  ```oracle
  create index 도서명_idx on 도서(도서명, 도서번호);
  
  select /*+ index(도서 도서명_idx)*/ 
             rowid rid, 도서번호, 도서명, 가격, 저자, 출판사, isbn
      from 도서
      where 도서명 like :book_nm || '%'
        and 도서명 = :last_book_nm
        and 도서번호 > :last_book_no
  ```
  * 하지만 인덱스 뒤에 PK컬럼을 붙여가며 개발하는 것은 쉽지 않고, PK가 다중컬럼이면 더 힘들어진다.
  * 중복값이 아주 많은 경우가 아니라면 rowid를 이용하는 방안이 현실적이다.

## Between과 Like 스캔 범위 비교
```oracle
-- 1) like 사용
select * from 월별고객별판매집계
where 판매월 like '2009%';

-- 2) between 사용
select * from 월별고객별판매집계
where 판매월 between '200901' and '200912'
```
* 위 두 방식 중에서, 1번방식으로 많이 사용하는데 이유는 단지 개발이 편하기 때문이다.
* 하지만 실제 데이터 상황에 따라 두 쿼리의 인덱스 스캔량이 다를 수 있다.
```oracle
-- 데이터가 200902 까지 있는 상황이다.

-- 2009년 2월 데이터는 판매구분이 'A'인 데이터만 읽고 멈춘다.
select count(*)
from 월별고객판매집계 t
where 판매월 BETWEEN '200901' and '200902'
  and 판매구분 = 'A';

-- 2009년 1월과 2월 데이터를 모두 읽는다.
select count(*)
from 월별고객판매집계 t
where 판매월 LIKE '2009%' 
  and 판매구분 = 'A';

-- 2009년 1월과 2월 데이터를 모두 읽는다.
select count(*)
from 월별고객판매집계 t
where 판매월 >= '200901' 
  and 판매월 < '200903'
  and 판매구분 = 'A';
```
* 실제 테이블에 존재하는 값을 수직적탐색 조건으로 사용할 수 있다.
* 물론 이 스캔 범위의 차이를 상황마다 정확히 인지하는건 쉽지 않지만, 적어도 between을 사용하면 like보다 더 넓은 범위를 스캔할 일은 없다.

## 선분이력의 인덱스 스캔 효율
### 선분이력?
* 이력의 시작지점만을 관리하는 것은 점이력 모델이라 하며, 시작지점과 종료시점을 함께 관리하는 것을 선분이력 모델이라고 한다.
1) 선분이력의 장점
   * 선분이력을 사용하면, 쿼리가 간단해지며 성능상 유리할 때가 많다.
2) 선분이력의 단점
   * 이력이 추가될 때마다 이력의 종료일자도 같이 변경해 주어야 한다.
     * DML 성능이 나빠지며 이력 데이터를 관리한느 프로그램이 복잡해진다.
   * 개체 무결성을 사용자가 직접 관리해줘야 한다.
     * 선분의 중복을 없애야 하는데, 이러한 무결성은 애플리케이션 레벨에서 구현할 수 밖에 없고 사용자가 직접 데이터를 입력/수정하면 정합성이 깨질 수 있다. 
     * 점이력일 경우엔 PK제약을 설정하는 것만으로 개체 무결성이 완벽히 보장된다.

### 선분이력 기본 조회 패턴
* 아래와 같은 쿼리는, 과거 현재 미래시점을 모두 조회할 수 있다.
  ```oracle
  select 연체개월수, 연체금액
  from 고객별연체금액
  where 고객번호 = '123'
    and :dt between 시작일 and 종료일
  ```
* 현재시점을 조회할 때에는 '99991231' 상수조건을 이용해 `=` 조건으로 검색하는 것이 성능상 좋다.
  ```oracle
  select 연체개월수, 연체금액
  from 고객별연체금액
  where 고객번호 = '123'
    and 종료일 ='99991231'
  ```
  * 이렇게 선분이력의 장점을 살리려면, 최종 이력의 레코드는 종료일에 `99991231`과 같이 데이터를 넣어야 한다.
  * 하지만 이 방식은, 미래 데이터를 미리 넣는 상황에서는 불가능하다.

### 인덱스에 선분이력 스캔 효율 최적화 
* 인덱스가 `[고객번호 + 시작일 + 종료일]` 순으로 구성된 상태에서의 예시이다.
```oracle
select *
from 고객별연체금액
where 고객번호 = '123'
  and '20050131' between 시작일 and 종료일;

select *
from 고객별연체금액
where 고객번호 = '123'
  and 시작일 <= '20050131'
  and 종료일 >= '20050131';
```
* 위와 같은 예시에서는 `=`조건인 `고객번호` 다음, `시작일`과 `종료일`은 인덱스 스캔 범위를 효율적으로 줄이지 못한다.

#### [시작일 + 종료일] 구성일 때 최근 시점
  ```oracle
  select /*+ index_desc(a index_x01) */ *
  from 고객별연체금액 a
  where 고객번호 = '123'
    and '20050131' between 시작일 and 종료일
    and rownum <= 1
  ```
  * 이럴경우엔 인덱스를 거꾸로 한 건만 스캔 후 원하는 이력을 빠르게 찾는 방법을 사용할 수 있다.  
#### [시작일 + 종료일] 구성일 때 과거 시점 조회
```oracle
select /*+ index_desc(a index_x01) */ *
from 고객별연체금액 a
where 고객번호 = '123'
  and '20020901' between 시작일 and 종료일
  and rownum <= 1
```

#### [종료일 + 시작일] 구성일 때 최근 시점 조회
```oracle
select *
from 고객별연체금액 a
where 고객번호 = '123'
  and '20050131' between 시작일 and 종료일
  and rownum <= 1
```

#### [종료일 + 시작일] 구성일 때 과거 시점 조회
```oracle
select *
from 고객별연체금액 a
where 고객번호 = '123'
  and '20050131' between 시작일 and 종료일
  and rownum <= 1
```

#### [시작일 + 종료일] 구성일 때 중간 시점 조회
```oracle
select /*+ index_desc(a index_x01) */ *
from 고객별연체금액 a
where 고객번호 = '123'
  and '20031010' between 시작일 and 종료일
  and rownum <= 1
```

#### [종료일 + 시작일] 구성일 때 중간 시점 조회
```oracle
select *
from 고객별연체금액 a
where 고객번호 = '123'
  and '20031010' between 시작일 and 종료일
  and rownum <= 1
```

### 선분이력 스캔 효율 정리
* 최근 데이터를 주로 조회한다면 `[종료일 + 시작일]` 순으로 구성하는 것이 효과적이고, 과거 데이터를 주로 조회한다면 `[시작일 + 종료일]` 순으로 구성하는 것이 효과적이다.
* 하지만 rownum과 `index_desc`힌트를 적절히 사용하면 항상 필요한 한건만 스캔하도록 할 수 있다.
* 업무적으로 미래시점 데이터를 미리 입력하는 경우가 없다면 현재시점 데이터를 조회할 때는 `종료일 = '99991231` 조건을 사용하는 것이 효과적이다.

## Access Predicate와 Filter Predicate
* `explain plan` 명령을 통해 실행계획을 수집하고, dbms_xplan 패키지를 통해 실행계획을 출력해보면 `Predicate`정보를 확인할 수 있다.
  * 오라클 9i부터 plan_table에 추가된 `access_predicates`와 `filter_predicates` 컬럼으로 부터 가져온 값이다.
  * 오라클 10gR2부터는 Autotrace 명령을 통해서도 Predicate정보를 출력해볼 수 있다.

* 인덱스를 경유할 경우 아래와같은 3가지 Predicate 정보가 확인될 수 있다.
  1) 인덱스 단계에서의 Access Predicate
     * 인덱스 스캔 범위를 결정하는데 영향을 미치는 조건절을 의미한다.
     * 범위검색 조건을 뒤따르는 조건이거나, 선행 컬럼이 조건절에서 누락될지라도 액세스 범위를 결정하는데 기여하기 때문에 대부분 Access Predicate에 포함된다.
  2) 인덱스 단계에서의 Filter Predicate
     * 테이블로의 액세스 여부를 결정짓는 조건절을 의미한다.
     * 첫 번째 나타나는 범위조건부터 이후 모든 조건절 컬럼들이 여기에 포함되며, 조건절에서 누락된 컬럼 뒤쪽에 놓인 인덱스 컬럼들도 포함한다.
  3) 테이블 단계에서의 Filter Predicate
     * 테이블을 액세스하고 나서 최종 결과집합으로의 포함여부를 결정짓는 조건절을 의미한다.
* 테이블 전체를 스캔할 때에는 항상 하나의 Predicate 정보만 확인할 수 있다.
  1) 테이블 단계에서의 Filter Predicate

## Index Fragmentation
* 오라클에서는 인덱스 불균형 상태가 생기지 않는다.
  * B-Tree구조이기 때문에, 모든 인덱스 루트에서 리프블록까지의 수직적 탐색 시 읽는 블록 수는 같다.
* 불균형은 생기지 않지만, Index Skew 또는 Sparse현상이 생기는 경우가 종종 있다.

### Index Skew
* Index Skew는 인덱스 엔트리가 왼쪽 또는 오른쪽에 치우치는 현상을 의미한다.
* 레코드가 삭제되어 리프블록이 비게 되면, 해당 블록은 커밋 시점에 freelist로 반환되지만, 인덱스 구조 자체에서는 제거되지 않고 그대로 유지된다. 
  * 상위 브랜치에서 해당 리프 블록을 가리키는 엔트리가 그대로 남아있기 때문에, 인덱스 정렬 순서상 해당 위치에 들어올 새로운 값이 있으면 언제든 재사용될 수 있다.
  * 새로운 값이 입력되기 전, 다른 노드에서 인덱스 분할이 발생하면 이 블록들이 재사용될 수 있다.
    * 이 경우 상위 브랜치에서 해당 리프블록을 가리키는 엔트리가 제거되어 다른 쪽 브랜치의 자식 노드로 이동하고, freelist에서도 제거된다.
* 레코드가 모두 삭제된 블록은 언제든 재사용 가능하지만, 다시 채워질 때까지 인덱스 스캔 효율이 낮다.
  * 이로인해 성능이 나빠지는 경우는 보통 Index Full Scan할 때이다.
* 대량의 데이터를 매일 지웠다가 새로 입력하는 통계성 테이블일 경우엔, 트랜잭션 패턴에 신경을 써줘야 한다.
  * delete 후 commit을 하지 않고 insert 작업을 진행하면, 새로운 공간을 할당받아 저장되기 때문에 작업이 끝나고 나서 많은 블록들이 텅 빈 상태로 유지된다.
  * 따라서 Index Skew 및 스캔 성능 저하를 유발할 수 있다.

### Index Sparse
* Index Sparse는 인덱스 블록 전반에 걸쳐 밀도가 떨어지는 현상을 의미한다.
* Index Skew처럼 블록이 아예 비어버리면 곧바로 freelist로 반환되어 언제든 재사용되지만, Index Sparse는 지워진 자리에 새로운 값이 입력되지 않으면 영영 재사용되지 않을 수도 있다.
* 총 레코드 건수가 일정한데 인덱스 공간 사용량이 커지면 보통 이러한 현상때문이다.

### Index Rebuild
* Fragmentation 때문에 인덱스 크기가 계속 증가하고 스캔 효율이 나빠지면 `coalesce` 명령을 수행해주면 된다.
  ```oracle
  alter table t_idx coalesce; 
  ```
* `coalesce` 명령을 수행하면 인덱스 분할과 반대의 작업이 일어나는데, 여러 블록을 하나로 병합하고 그 결과로 생긴 빈 블록들은 freelist에 반환한다.
* `coalesce` 명령을 수행해도 인덱스 세그먼트에 할당된 미사용 공간은 반환되지 않는다. (HWM 아래쪽 freelist에 등록된 블록, HWM 위쪽 미사용 블록)
* Index Fragmentation을 해소하면서 공간까지 반환하려면 `shrink space` 명령을 수행하면 된다. (ASSM에서만 동작) 
  ```oracle
  alter index t_idx shrink space
  ```
* `compact` 옵션을 지정하면 공간을 반환하지 않기 때문에 `coalesce`와 같은 명령어가 된다.
  ```oracle
  alter index t_idx shrink space compact
  ```
* `coalesce`나 `shrink space`는 레코드를 건건이 지웠다가 다시 입력하는 방식이기 때문에, 작업량이 많은 경우엔 `rebuild` 명령어가 나을 수 있다.
  ```oracle
  alter index t_idx rebuild;
  alter index t_idx rebuild online;
  ```
* 하지만 인덱스 블록에 공간이 전혀 없으면 인덱스 분할이 자주 일어나기 DML 성능이 떨어지기 때문에, 어느정도 공간을 남겨두는것이 좋다.
  * 인덱스 분할 때문에 Shared 모드 `enq:TX - index contention` 대기 이벤트가 자주 나타나면, `pctfree`를 높게 설정하는 것을 고려할 수 있다.
  * 인덱스에서의 `pctfree`는 인덱스를 처음 생성하거나 rebuild할 때만 적용되기 때문에, `pctfree`를 높이고 인덱스를 rebuild해야 한다.
  * 하지만, 언젠가는 빈공간이 다시 채워지기 때문에 rebuild 작업은 계속 해줘야 한다.
* rebuild 하는 동안 걸리는 시간과 부하를 무시할 수 없다.
* 대량의 delete작업이 없으면 주기적으로 rebuild하지 않더라도 별로 나쁘지 않다.
* 인덱스 rebuild는 아래와 같은 상황에서 고려해봐야 한다.
  * 인덱스 분할에 의한 경합이 현저히 높을 때
  * 자주 사용되는 인덱스 스캔 효율을 높이고자 할 때 (NL조인에서 반복 액세스되는 인덱스 높이가 증가했을 때)
  * 대량의 delete 작업을 수행한 이후 다시 레코드가 입력되기까지 오랜 기간이 소요될 때
  * 총 레코드 수가 일정한대도 인덱스가 계속 커질 때

> 인덱스 freelist
> * 테이블에서의 pctfree와 pctused는 freelist에서 제외되는 시점과 다시 등록되는 시점을 지정하는 파라미터이다.
>   * 테이블은 Heap방식으로 데이터를 입력하기 때문에 매번 freelist를 참조해 데이터 삽입이 가능한 블록을 찾아야 한다.
> * 반면에, 인덱스는 정렬된구조로 자료를 삽입하므로, 값이 입력될 때마다 freelist를 참조하지 않아도 된다.
>   * 인덱스 freelist는 인덱스 분할로 빈 블록이 필요할 때만 참조한다.
> 1) PCTFREE
>   1) 테이블
>      * 블록에 더이상 insert가 발생하지 못하도록 freelist로부터 제외되는 시점을 지정하는 것이다.
>      * 이렇게 남겨진 빈 공간은 나중에 update를 위해 사용된다.
>   2) 인덱스
>      * 인덱스가 생성되는 시점에 공간을 꽉 채워두면 인덱스 분할이 번번하게 발생하는데, 이를 방지하기 위해 pctfree를 사용한다.
>      * 최초 생성 또는 재생성 시에만 적용되고, 지정한 비율만큼 공간을 남겨두었다가 insert를 위해 사용된다.
> 2) PCTUSED
>   1) 테이블
>      * freelist에서 제거된 테이블 블록에 빈 공간이 일정 수준 이상 확보되었을 때만 다시 freelist에 등록되도록 하기 위해 사용한다.
>      * insert, delete가 자주 발생하는 테이블에 pctused와 pctfree의 합이 100에 가까우면 freelist변경이 자주 발생하게 된다.
>      * delete가 적게 발생한다면 100에 가깝도록 설정해야 테이블 블록 저장 효율을 높일 수 있다.
>   2) 인덱스 (없음)
>      * 인덱스에서 빈 공간은 항상 재사용가능하다.
> * 인덱스에서의 freelist는 인덱스 분할에 사용가능한 빈 블록들을 관리한다.
> * delete에 의해 비워진 인덱스 블록은 커밋시점에 freelist에 반환되지만, insert 시점에 다시 값이 입력되더라도 곧바로 freelist에서 제거되지 않는다.
>   * 인덱스 분할 때문에 freelist를 스캔하는 프로세스에 의해 정리되는데, freelist에서 얻은 블록이 비어있지 않으면 다른 블록을 재요청하기 전에 해당 블록을 freelist에서 제거한다.
>   * 커밋시점 수행해야 할 일을 최소화하기 위함이다.

# 인덱스 설계
## 가장 중요한 두 가지 선택 기준
1. 조건절에 항상 사용되거나 적어도 자주 사용되는 컬럼들을 선정한다.
2. `=`조건으로 자주 조회되는 컬럼들을 앞쪽에 두어야 한다.

## 인덱스 설계는 공식이 아닌 전략과 선택의 문제
* 가장 중요한 두 가지 선택 기준이 기본공식이지만, 인덱스 설계는 이렇게 단순하지 않다.
* 이 두 공식만 지키려고 하다 보면 인덱스 개수가 계속 늘어나게 된다.
* 인덱스 설계에 정답은 없고, 시스템 전체적인 관점에서의 효율은 여러 상황적 요소를 고려해야만 한다.
* 이러한 상황적 요소들을 해석하는 기준은 사람마다 다르고, 설계자의 성향이나 스타일에 따라 달라질 수 밖에 없다.
* 정답은 없지만, 설계 시 왜 그런 선택을 했는지 판단 근거를 제시할 수 있어야 한다.

### 인덱스 설계 연습 예시
* 특정 상황에서 인덱스를 어떤식으로 설계했을 때 어떠한 장점 및 단점들이 있는지 설명하는 예시이다. (p181 ~ p191 참고)
* 아래와 같은 요소들을 종합해 설계를 해야 한다.
  * 쿼리 수행 빈도
  * 업무상 중요도
  * 클러스터링 팩터
  * 데이터량
  * DML 부하
  * 저장 공간
  * 인덱스 관리 비용 등
* 인덱스 설계 시에는 개별 쿼리 성능 뿐만 아니라, 인덱스 수를 최소화 해서 DML 부하까지 줄이는 것을 목표로 해야 한다.
* 최적을 달성해야 할 핵심적인 액세스 경로 한두 개를 전략적으로 선택 후, 그것을 중심으로 나머지 액세스 경로는 비효율이 좀 있더라도 목표한 성능 수준에만 도달하도록 구성해주는 방향으로 가는 것이 좋다.
* 실무에선 파티셔닝기능도 함께 고려해야 하며, 파티션 설계를 먼저 진행하거나 최소한 인덱스 설계와 병행해야 한다.

## 결합 인덱스 컬럼 순서 결정 시, 선택도 이슈
* 결합 인덱스에서, 컬럼간 순서를 정할 때 선택도가 낮은 컬럼을 앞에 두는것이 유리하다고 알려져 있지만, 사실은 그렇지 않다.

### 선택도가 액세스 효율에 영향을 주지 않는 경우
* `=`조건으로 항상 사용되는 컬럼들은 앞쪽에 위치시켰을 때, 그 중 선택도가 낮은 것을 앞쪽에 두는 것은 의미가 없거나 오히려 손해일 수 있다.
* 모두 `=`조건으로 사용된 컬럼들은 앞쪽에 있던 뒤쪽에 있던 수직적 탐색 과정은 동일하게 진행된다.
* 따라서 변별력이 좋지 않은 컬럼을 앞에 두더라도 수평적 탐색을 위한 스캔 범위는 최소화 되며, 인덱스 액세스 효율에 전혀 영향을 미치지 않는다.

### 선택도가 높은 컬럼을 앞쪽에 두는 것이 유리한 경우
* 오히려 변별력이 낮은 컬러믈 선두에 두면, 이 컬럼이 조건절에서 누락되거나 범위검색 조건으로 조회되는 일이 생겨도 `Index Skip Scan`을 효과적으로 활용할 수 있어 유리할 수 있다.
  * `Index Skip Scan`의 경우 선행 컬럼의 Distinct Value 개수가 적고, 후행 컬럼의 Distinct Value 개수가 많아야 효율적이다.
* 또한 굳이 `Index Skip Scan`이 아니더라도, IN-List로 값을 제공함으로써 쉽게 튜닝할 여지가 생긴다.
  * 변별력이 좋은 컬럼을 선두에 두었는데, 조건에서 누락되거나 범위검색 조건으로 조회된다면 이러한 튜닝 기법을 활용하기 힘들다.
* 인덱스 압축 기능을 고려하더라도, 변별력이 낮은 컬럼을 앞쪽에 두는 것이 유리하다.
  * 선택도가 높은 컬럼을 앞쪽에 두어야 인덱스 압축률이 좋아진다.
  * 변별력이 좋은 컬럼을 선두에 두어야 좋다는 상식은 오라클 5버전에서 사용하던 인덱스 압축방식때문에 생긴 얘기고, 오라클6부터는 그런 특징이 사라졌다.

### 상황에 따라 유/불리가 바뀌는 경우
* 아래 예시에서, `고객번호`는 변별력이 높은 컬럼이고, `고객등급`은 변별력이 낮은 컬럼이다. 

|고객번호|고객등급| 고객번호+고객등급+거래일자                                                                         | 고객등급+고객번호+거래일자|
|---|---|--------------------------------------------------------------------------------------------|---|
|>=|=| 스캔범위가 넓어져 불리하지만, 고객번호에 입력되는 값의 범위가 좁을 때에는 비효율이 크지 않다. 입력범위가 넓을 때 ISS나 IN-List기법을 활용하지 못한다. | 유리|
|=|>=|유리|선택도가 높은 고객등급에 의해 스캔범위가 결정되므로 불리하지만, ISS또는 IN-List를 활용하면 큰 비효율은 없다.|
|>=|>=|고객번호에 입력되는 값의 범위가 좁을 때는 비효율이 크지 않다. 입력범위가 넓을 때 ISS나 IN-List기법을 활용하지 못한다.|선택도가 높은 고객등급에 의해 스캔 범위가 결정되므로 불리하지만, ISS 또는 In-List를 활용한다면 큰 비효율은 없다.|
|=|누락|유리|ISS 또는 IN-List 활용 가능|
|누락|=|Full Table Scan이 유리| Full Table Scan이 유리|

* 선택도가 높은 컬럼을 선두에 두면 나중에 범위검색 조건이 사용되거나, 아예 조건절에서 누락되더라도 ISS나 IN-List를 활용할 수 있어 유리하다.
* 선택도가 낮은 컬럼을 선두에 두면 범위 검색 조건으로 조회하는 일이 생겼을 때 불리하지만, 입력 값의 범위가 좁다면 비효율이 크지 않아 ISS나 IN-List를 활용하지 못하더라도 유리할 수 있다.

### 선택도가 낮은 컬럼을 앞쪽에 두는 것이 유리한 경우
```oracle
select * 
from 주문
where 고객번호 = :a
  and 상품번호 = :b
  and 거래일자 between :c and :d
```
```
X01 : 고객번호 + 거래일자 + 상품번호
X02 : 상품번호 + 거래일자 + 고객번호
```
* 위 예시에서, 고객은 100만명이고 상품 수는 1만명이라고 할 때 `X01` 인덱스가 유리하다
  * `상품번호`는 필터 역할만 하는데, 변별력이 좋은 `고객번호`에 의해 스캔 범위가 최소화 되기 때문이다.
* 하지만 위 쿼리만 있다고 하면 당연히 `[고객번호 + 상품번호 + 거래일자]` 순으로 구성하는 것이 좋다.

### 결합 인덱스 컬럼간 순서를 정하는 기준
* 개별 컬럼의 선택도보다는, 조건절에서 어떤 형태로 자주 사용되는지, 사용비도는 어느쪽이 높은지, 데이터를 빠르게 검색하는 데에 어느 쪽 효용성이 높은 지 등이 더 중요한 판단기준이다.

### 소트 오퍼레이션을 생략하기 위한 컬럼 추가
* 인덱스는 항상 정렬 상태를 유지하므로, order by, group by를 위한 소트 연산을 생략할 수 있도록 해준다.
* 조건절에 사용하지 않더라도 이렇게 소트 연산을 대체할 목적으로 인덱스 구성에 포함시켜 성능개선을 할 수 있다.
* order by절에 기술한 순서가 인덱스 순서와 일치하기만 한다면, 조건절에서 어떤 연산자로 비교되더라도 정렬 작업이 생략될 수 있다.
  * 하지만 항상 생략되는 것은 아니고, 옵티마이저가 Table Full Scan을 선택하거나 다른 인덱스를 선택한다면 정렬 작업은 별도로 수행된다.

### 인덱스 설계도 작성
* p198~p199 참고

# 비트맵 인덱스
## 비트맵 인덱스의 기본 구조
* 일반 B-Tree인덱스는 rowid목록을 키 값과 함께 트리구조로 관리한다.
* 비트맵 인덱스는 값마다 비트 벡터를 만들어 각 행이 해당 값이면 1, 아니면 0으로 표시해두는 방식이다.
* 따라서 조건 필터링을 비트 연산으로 매우 빠르게 합성할 수 있다.

## 비트맵 인덱스의 장점
* 값의 종류가 적은 컬럼에서 매우 효율적이다.
* 여러 조건을 동시에 거는 분석 쿼리에서 강하다.
* 대량 스캔/집계/분석(OLAP, DW) 쿼리에 유리하다.
* OR조건을 잘 처리한다.
  * B-Tree는 OR조건에서 비용이 커지거나 UNION/OR Expansion 등이 필요할 수 있는데 비트맵은 OR도 비트 OR로 합성 가능하다.
* null값에 대한 검색도 가능하다.

## 비트맵 인덱스의 단점
* DML이 많은 OLTP에는 부적합한 경우가 많다.
* 동시성/락 이슈가 생기기 쉽다.
  * 비트맵은 개별 행이 아니라, 비트 범위를 갱신하는데, 이 과정에서 여러 행이 엮이며 락 경합이 커질 수 있다.
  * 특정값에 여러 세션이 동시에 변경을 시도하면 병목/대기 가능성이 증가한다.
* 값의 종류가 많아지면 비트맵 개수/크기/관리비용이 커질 수 있다.

## 비트맵 인덱스를 활요하면 좋은 경우
* DW/리포팅/배치 중심 환경
* 자주 변경되지 않는 읽기 위주의 테이블
* 값의 종류가 적은 컬럼들에 대해 조건 조합이 많은 쿼리

## 비트맵 인덱스를 활용하면 안좋은 경우
* 트랜잭션이 빈번한 OLTP 테이블
* 특정 플래그/상태값이 빈번하게 바뀌는 컬럼
* 동시 업데이트가 많은 서비스 (락/대기 민감)
* 값의 종류가 많은 컬럼이 주인 경우

## 비트맵 vs B-Tree
* B-Tree
  * 장점 : OLTP DML에 강하며, 범위검색/정렬에도 유리하다.
  * 단점 : OR 조건/다중 조건 조합에서 비용이 커질 수 있다.
* 비트맵
  * 장점 : 다중 조건 조합, 저카디널리티 분석 쿼리에 매우 강하다.
  * 단점 : DML/동시성에 취약할 수 있어 OLTP엔 적합하지 않다.

## RECORDS_PER_BLOCK
* 오라클은 한 블록에 저장할 수 있는 최대 레코드 개수를 제한한다.
  * 이래야 비트맵 위치와 rowid를 매핑할 수 있다.
* 하지만 실제 블록에 저장되는 평균적인 레코드 개수는 여기에 한참 못미치는 경우가 많다.
  * 그 결과 비트맵 인덱스에서의 불필요한 비트가 많이 생겨 공간 낭비가 발생할 수 있다.
* 따라서 오라클은 블록에 저장될 수 있는 최대 레코드 개수를 사용자가 지정할 수 있는 기능을 제공한다.
* `RECORDS_PER_BLOCK`은 한 데이터 블록 안에 평균적으로 몇 개의 레코드가 들어가는가를 나타낸다.
  * 블록하나를 읽으면 평균적으로 몇 행을 얻는지로, 인덱스/테이블에서 I/O관점의 밀도에 대한 감을 잡을 때 쓰인다.
* 오라클에선 `minimize records_per_block`이란 기능을 제공한다.
  ```oracle
  alter table t minimize records_per_block
  ```
  * 테이블을 스캔해 블록당 최대 레코드 개수를 계산하고, 이후 한 블록에 그 이상 레코드가 저장되지 않도록 제한한다.
  * 블록을 의도적으로 덜 채우는 방향으로 동작하며, 비트맵 인덱스를 더 작고 안정적으로 생성하기 위한 목적이다.
  * 하지만 이미 블록당 레코드 수가 낮은 상태에서 적용하면 테이블이 더 팽창되고 I/O가 증가할 수 있다.
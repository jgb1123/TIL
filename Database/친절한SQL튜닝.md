# SQL 처리과정과 I/O
## SQL 파싱과 최적화
### SQL?
* SQL은 Structured Query Language 의 줄임말이다.
* SQL은 깁노적으로 구조적(structured)이고, 집합적(set-based)이고, 선언적(declarative)인 질의 언어이다.
* 원하는 결과 집합을 구조적, 집합적으로 선언하지만 그 결과 집합을 만드는 과정은 절차적일 수 밖에 없다.
* 결국 프로시저가 필요한데, 그 프로시저를 만들어내는 DBMS 내부 엔진이 바로 SQL 옵티마이저이다.
* DBMS 내에서 프로시저를 작성하고 컴파일해 실행 가능한 상태로 만드는 모든 과정을 SQL 최적화라고 한다.


### SQL 최적화 과정
1) SQL 파싱
   * 사용자로부터 SQL을 전달받으면, 가장 먼저 SQL 파서가 파싱을 진행한다.
   * 파싱 트리 생성 : SQL문을 이루는 개별 구성 요소를 분석해 파싱 트리를 생성한다.
   * Syntax 체크 : 문법적 오류가 없는지 확인한다.
   * Semantic 체크 : 의미상 오류가 없는지 확인한다.

2) SQL 최적화
   * SQL최적화는 옵티마이저가 진행한다.
   * 옵티마이저가 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 실행 경로를 생성해 비교한 후 가장 효울적인 하나를 선택한다.
3) 로우 소스 생성
   * SQL 옵티마이저가 선택한 실행 경로를 실행가능한 코드나 프로시저 형태로 포맷팅한다.
   * 로우 소스 생성기(Row-Source Generator)가 그 역할을 맡는다.

### SQL 옵티마이저
* SQL옵티마이저는 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 액세스 경로를 선택해주는 DBMS의 핵심 엔진이다.
1) 사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 찾아낸다.
2) 데이터 딕셔너리에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상 비용을 산정한다.
3) 최저 비용을 나타내는 실행 계획을 선택한다.

### 실행계획과 비용
* DBMS에 SQL 실행경로 미리 보기 기능이 있는데, 실행 계획(Execution Plan)이다.
* 이를 통해 자신이 작성한 SQL이 테이블을 스캔하는지, 인덱스를 스캔하는지, 인덱스를 스캔한다면 어떤 인덱스인지를 확인할 수 있으며, 예상과 다른 방식으로 처리되면 실행경로를 변경할 수 있다.
* SQL 실행계획에 표시되는 Cost도 예상치이며, 실행경로를 선택하기 위해 옵티마이저가 여러 통계 정보를 활용해 계산해낸 값이다.

### 옵티마이저 힌트
* 옵티마이저가 보통 좋은 선택을 하지만, 그 선택이 최선은 아니다.
* 옵티마이저 힌트를 이용해 데이터 액세스 경로를 바꿀 수 있다.
* 중요한 시스템이라면, 옵티마이저의 판단에 맡기긴 어렵지만, 힌트를 쓸거면 빈틈없이 써야 한다.
```oraclesqlplus
/*+ INDEX(T1 TEST_PK) */
```
#### 주의사항
* `--+ INDEX(A TEST_PK)`방식은 가급적 쓰지 말아야 한다.
* 인자를 나열할 땐 `,`를 사용할 수 있지만 힌트와 힌트 사이에 사용하면 안된다.
* 테이블을 지정할 때 스키마 명까지 명시하면 안된다.
* FROM절 옆에 ALIAS를 지정했으면 힌트에도 반드시 ALIAS를 사용해야 한다.

## SQL 공유 및 재사용
### 소프트 파싱 vs 하드 파싱
* SQL 파싱, 최적화, 로우소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복해서 재사용할 수 있도록 캐싱해두는 메모리 공간을 **라이브러리 캐시**라고 한다.
  * 라이브러리 캐시는 SGA의 구성 요소이다.
    > SGA(System Global Area)
    >* 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간
* 사용자가 SQL문을 전달하면 DBMS는 SQL을 파싱한 후 해당 SQL이 라이브러리 캐시에 존재하는지부터 확인한다.
* SQL을 캐시에서 찾아 바로 실행단계로 넘어가는것을 **소프트파싱** 이라고 한다.
* 찾는데 실패 해 최적화 및 로우 소스 생성 단계까지 모두 거치는것을 **하드파싱** 이라고 한다.
  * 하드파싱은 CPU를 많이 소비하는 몇 안되는 작업 중 하나이다.
  * 쿼리를 수행할 때, 후보군이 될만한 많은 실행경로를 도출하고, 딕셔너리와 통계정보를 읽어 각각의 효율성을 판단하는 과정은 결코 가볍지 않다.

### 바인드 변수의 중요성
#### 이름이 없는 SQL 문제
* 사용자 정의 함수/프로시저, 트리거, 패키지 등은 생성할 때 부터 이름을 갖기 때문에, 컴파일한 상태로 딕셔너리에 영구적으로 보관된다. 
* SQL은 이름이 따로 없고, 전체 텍스트가 이름 역할을 한다.
#### 공유 가능 SQL
* 바인드 변수를 사용하지 않으면, DBMS에서 발생하는 부하는 대개 I/O가 원인인데, I/O가 거의 발생하지 않음에도 CPU사용률은 급격히 올라갈 수 있다. (SQL 하드파싱 문제)
* 따라서 바인드 변수를 사용해 파라미터 Driven 방식으로 SQL을 작성하면 이러한 하드파싱 문제를 방지할 수 있다.

## 데이터 저장 구조 및 I/O 메커니즘
* I/O 튜닝이 곧 SQL 튜닝이라 해도 과언이 아니다.
* 즉 SQL튜닝 원래를 제대로 이해하려면 I/O에 대한 이해가 필수적이다.

### SQL이 느린 이유
* I/O는 잠 이라고 설명할 수 있다.
* I/O를 처리하는 동안 프로세스는 잠을 자기 때문이다.
* 프로세스가 잠을 자는 이유는 여러가지가 있지만, I/O가 가장 대표적이고 많은 비중을 차지한다.
* interrupt 없이 일하는 프로세스도 디스크에서 데이터를 읽어야 할 땐 CPU를 OS에 반환하고 waiting 상태에서 I/O가 완료되기를 기다린다.
  * CPU를 반환한 채 대기 큐에서 잠을 자는 것이다.
* 열심히 일해야 할 프로세스가 잠을 자게 되므로, I/O가 많으면 성능이 느릴 수 밖에 없다.
* SQL이 느린 이유는 여기에 있으며, 즉 디스크 I/O 때문이다.

### 데이터베이스 저장 구조
* 데이터를 저장하려면 **테이블 스페이스**를 생성해야 한다.
  * 테이플 스페이스는 세그먼트를 담는 콘테이너로, 여러 개의 데이터파일로 구성된다.
* 테이플스페이스를 생성했으면, **세그먼트**를 생성한다.
  * 세그먼트는 테이블, 인덱스 처럼 데이터 저장공간이 필요한 오브젝트이다.
    * 따라서 테이블, 인덱스를 생성할 때 데이터를 어떤 테이블 스페이스에 저장할지를 지정한다.
  * 파티션 구조가 아니라면 테이블도 하나의 세그먼트, 인덱스도 하나의 세그먼트이다.
  * 파티션구조라면 각 파티션이 하나의 세그먼트가 된다.
  * LOB컬럼은 그 자체가 하나의 세그먼트를 구성하므로 자신이 속한 테이블과 다른 공간에 값을 저장한다. (작은 LOB는 설정에 따라 in-row 저장 가능)
* 세그먼트는 여러 **익스텐트**로 구성된다.
  * 익스텐트는 공간을 확장하는 단위이다.
  * 테이블이나 인덱스에 데이터를 입력하다 공간이 부족해지면 오브젝트가 속한 테이블 스페이스로부터 익스텐트를 추가로 할당받는다.
  * 익스텐트는 연속된 블록들의 집합이기도 하다.
* 익스텐트 단위로 공간을 확장하지만, 레코드를 실제로 저장하는 공간은 **데이터 블록**이다.
  * 한 블록은 하나의 테이블이 독점한다.
  * 즉, 한 블록에 저장된 레코드는 같은 테이블 레코드이다.
  * 추가로, 한 익스텐트도 하나의 테이블이 독점한다.
  * 즉, 한 익스텐트에 담긴 블록은 모두 같은 테이블 블록이다. (MS-SQL은 한 익스텐트를 여러 오브젝트가 사용할 수도 있음)
* 세그먼트 공간이 부족해지면 테이블 스페이스로부터 익스텐트를 추가로 할당받지만, 세그먼트에 할당된 모든 익스텐트가 같은 데이터파일에 위치하지 않을 수도 있다.
  * 서로 다른 데이터 파일에 위치할 가능성이 더 높다.
  * 하나의 테이블스페이스를 여러 데이터파일로 구 성하면 파일 경합을 줄이기 위해 DBMS가 가능한 여러 데이터로 분산해 저장하기 때문이다.

#### DBA(Data Block Address)
* 데이터 블록은 디스크 상에서 몇 번 데이터 파일의 몇 번째 블록인지를 나타내는 고유 주소값(DBA)을 갖는다.
* 데이터를 읽으려면 DBA부터 확인해야 한다.
* 인덱스를 이용해 테이블 레코드를 읽을 때에는 인덱스 ROWID를 이용한다.
* ROWID 는 DBA + 로우 번호(블록 내 순번)으로 구성되므로, 이를 통해 읽어야 할 테이블 레코드가 저장된 DBA를 알 수 있다.
* 테이블 스캔 시에는 테이블 세그먼트 헤더에 저장된 익스텐트 맵을 이용한다.
* 익스텐트 맵을 통해 각 익스텐트의 첫 번쨰 블록 DBA를 알 수 있다.
* 즉, 익스텐트는 연속된 블록의 집합이므로 테이블을 스캔할 때에는 첫 번쨰 블록 뒤에서 연속해서 저장된 블록을 읽으면 된다.

### 블록 단위 I/O
* 데이터베이스에서 데이터를 읽고 쓰는 단위는 블록이다.
* 데이터 I/O 단위가 블록이므로, 특정 레코드를 하나 읽고 싶어도 해당 블록을 통째로 읽는다.
* 오라클은 기본적으로 8KB 크기의 블록을 사용한다. (1Byte를 읽기 위해 8KB를 읽는다)

### 시퀀셜 액세스 vs 랜덤 액세스
#### 시퀀셜 액세스
* 시퀀셜 액세스는 논리적또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식이다.
* 인덱스 리프 블록은 앞뒤를 가리키는 주소값을 통해 논리적으로 연결되어 있다.
  * 이 주소값에 따라 앞 또는 뒤로 순차적으로 스캔하는 방식이 시퀀셜 액세스이다.
* 테이블 블록 간에는 논리적인 연결고리를 갖고있지 않다.
  * 세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더에 맵으로 관리한다.
  * 이 익스텐트 맵은 첫 번째 블록 주소 값을 갖는다.
  * 따라서 읽어야 할 익스텐트 목록을 익스텐트 맵에서 얻고, 각 익스텐트의 첫 번째 블록 뒤에 연속해서 저장된 블록을 순서대로 읽으면, 바로 Full Table Scan이다.

#### 랜덤 액세스
* 랜덤 액세스는 논리적, 물리적 순서를 따르지 않고 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식이다.

### 논리적 I/O vs 물리적 I/O
#### DB 버퍼캐시
* SGA 구성요소로 라이브러리 캐시가 있는데, 데이터를 캐싱하는 DB 버퍼캐시도 SGA의 중요한 구성요소중 하나이다.
* 라이브러리 캐시가 SQL과 실행계획, DB 저장형 함수/프로시저 등을 캐싱하는 코드캐시라고 한다면, DB버퍼캐시는 데이터 캐시라고 할 수 있다.
* 디스크에서 읽은 데이터 블록을 캐싱해 같은 블록에 대한 반복적인 I/O Call을 줄이는데 목적이 있다.
* 서버 프로세스와 데이터 파일 사이에 버퍼 캐시가 있으므로, 데이터 블록을 읽을 때에는 항상 버퍼캐시부터 탐색한다.
  * 버퍼캐시는 공유메모리 영역이므로, 같은 블록을 읽는 다른 프로세스도 득을 본다.


#### 논리적 I/O vs 물리적 I/O
* 논리적 블록 I/O는 SQL을 처리하는 과정에 발생한 총 블록 I/O를 말한다.
* 물리적 블록 I/O는 디스크에서 발생한 총 블록 I/O를 말한다.
  * 읽어야 할 블록을 버퍼캐시에서 찾지 못할 때만 디스크를 액세스 하므로, 논리적블록 I/O의 일부가 물리적 I/O이다.
* 메모리 I/O는 전기적신호이지만, 디스크 I/O는 액세스 암을 통해 물리적 작용이 일어나므로 메모리 I/O에 비해 상당히 느리다. (보통 10000배 느림)
* Direct Path Read방식으로 읽는 경우를 제외하면, 모든 블록은 DB 버퍼캐시를 경유해서 읽는다.
* 즉, 일반적으로 논리적 I/O횟수는 DB버퍼캐시에서 블록을 읽은 횟수와 일치한다.
* DB버퍼캐시에서 블록을 찾지 못해 디스크에서 읽은 블록 I/O가 물리적 I/O이다.


#### 버퍼캐시 히트율
* 버퍼캐시 효율을 측정하는데 가장 많이 사용해 온 지표는 버퍼캐시 히트율(BCHR)이다.
 ```
BCHR = (캐시에서 찾은 블록 수 / 총 읽은 블록 수 ) * 100
     = ((논리적 I/O - 물리적 I/O) / 논리적 I/O) * 100
     = (1 - (물리적 I/O) / (논리적 I/O)) * 100
 ```
* 애플리케이션 특성에 따라 다르지만, 온라인 트랜잭션을 주로 처리하는 애플리케이션이라면 시스템 레벨에서 평균 99% 히트율을 달성해야 한다.
  * 핵심 트랜잭션이 시스템 전체 부하의 대부분을 차지하므로, 열심히 튜닝하면 99%는 달성하기 어려운 수치가 아니다.
* 논리적 I/O는 일정하므로, 물리적 I/O 는 버퍼캐시 히트율에 의해 결정된다.
* 결국 SQL 성능을 높이기 위해 할 수 있는 일은 논리적 I/O를 줄이는 일이다.
* 따라서 SQL을 튜닝해서 읽는 총 블록 수를 줄이면 된다.
* 논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 SQL 튜닝이다.
* 버퍼캐시 히트율이 SQL 성능을 좌우하지만, 높다고해서 효율적인 SQL을 의미하진 않는다.
  * 같은 블록을 반복해서 읽는 비효율적인 일이었을 수 있다.

### Single Block I/O vs Multiblock I/O
* 한 번에 한 블록씩 요청해서 메모리에 적재하는 방식을 Single Block I/O라고 한다.
* 한번에 여러 블록을 요청해서 메모리에 적재하는 방식을 Bultiblock I/O라고 한다.
* 인덱스를 이용할 때에는 기본적으로 인덱스와 테이블 블록 모두 Single Block I/O방식을 사용한다.
  * 인덱스 루트 블록을 읽을 때
  * 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
  * 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
  * 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
* 많은 데이터 블록을 읽을 때는 Multiblock I/O 방식이 효율적이다.
* Multiblock I/O는 캐시에서 찾지 못한 특정 블록을 읽으려고 디스크 상에 그 블록과 인접함 블록들을 한꺼번에 읽어 캐시에 미리 적재하는 기능이다.
* DBMS의 블록사이즈가 얼마건 간에 OS단에서는 일반적으로 1MB 단위로 I/O를 수행한다. (OS마다 다르다)
  * 오라클 I/O단위가 8KB이므로, db_file_multiblock_read_count를 128로 설정하면 최대가 된다. (8KB * 128)


### Table Full Scan vs Index Range Scan
* Table Full Scan은 테이블에 속한 블록 전체를 읽어 사용자가 원하는 데이터를 찾는 방식이다.
  * Table Full Scan은 시퀀셜 액세스와 Multiblock I/O 방식으로 디스크 블록을 읽는다.
* Index Range Scan은 인덱스에서 일정량을 스캔하면서 얻은 ROWID로 테이블 레코드를 찾아가는 방식이다.
  * Index Range Scan은 랜덤 액세스와 Single Block I/O방식으로 디스크 블록을 읽는다.
* Table Full Scan은 스토리지 스캔 성능이 좋아지는 만큼 성능도 좋아진다.
* Index Range Scan은 스토리지 성능이 많이 좋아져도 성능이 조금만 좋아진다.
* Table Full Scan을 피해야 한다는 인식과 달리 인덱스가 SQL성능을 떨어뜨리는 경우도 많다.
  * 한번에 많은 데이터를 처리하는 집계용 SQL과 배치프로그램이 그렇고, 이 경우엔 오히려 Full Scan으로 유도하면 성능이 좋아진다.
  * 물론 큰 테이블에서 소량의 데이터를 검색할 때에는 반드시 인덱스를 이용해야 한다.
* 인덱스는 굉장히 중요하긴 하지만, 항상 옳은 것은 아니므로 모든 성능문제를 인덱스로 해결하려고 하면 안된다.

### 캐시 탐색 메커니즘
* Direct Path I/O를 제외한 모든 블록 I/O는 메모리 버퍼캐시를 경유한다.
  * 인덱스 루트 블록을 읽을 때
  * 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
  * 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
  * 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
  * 테이블 블록을 Full Scan 할 때
* 버퍼 캐시에서 블록을 찾을 때 해시 알고리즘으로 버퍼 헤더를 찾고, 거기서 얻은 포인터로 버퍼 블록을 액세스하는 방식을 사용한다.
  * 같은 입력값은 항상 동일한 해시 체인에 연결됨
  * 다른 입력값이 동일한 해시 체인에 연결될 수 있음
  * 해시 체인 내에서는 정렬이 보장되지 않음
* 버퍼캐시에 캐싱된 버퍼블록은 모두 공유자원이기 때문에, 동시에 두 개 이상 프로세스가 접근하려고 할 때 정합성에 문제가 생길 수 있다.
* 따라서 한 프로세스씩 순차적으로 접근하도록 구현해야 하며, 이를 위한 직렬화 메커니즘이 필요한데, 이를 지원하는 메커니즘이 래치이다.
> 캐시버퍼 체인 래치
> * 대량의 데이터를 읽을 때 모든 블록에 대해 해시 체인을 탐색한다.
> * DBA를 해시 함수에 입력하고 반환된 값으로 스캔해야 할 해시 체인을 찾는다.
> * 해시체인에는 키를 획득한 프로세스만이 체인으로 진입할 수 있다.
* 버퍼캐시에는 캐시버퍼 체인 래치, 캐시버퍼 LRU 체인 래치 등이 작동한다.
* 캐시I/O도 생각보다 빠르지 않을 수 있는데, 이 래치에 의한 경합이 생길 수 있기 때문이다.
* 캐시버퍼 체인 뿐 아니라 버퍼블록 자체에도 버퍼 Lock이라는 직렬화 메커니즘이 존재한다.
* 따라서 이러한 직렬화 메커니즘에 의한 캐시 경합을 줄이려면 SQL튜닝을 통해 논리적 I/O 자체를 줄여야 한다.

> 버퍼 Lock
> * 래치를 해제한 상태로 버퍼 블록 데이터를 읽고 쓰는 경우 같은 블록에 접근할 수 있다.
> * 같은 블록에 접근해 데이터를 읽고 쓴다면 데이터 정합성에 문제가 생길 수 있다.
> * 이를 방지하기 위해 오라클은 버퍼 Lock을 사용한다.
> * 캐시버퍼 체인 래치를 해제하기 전 버퍼 헤더에 Lock을 설정함으로써 버퍼블록 자체에 대한 직렬화 문제를 해결한다.

# 인덱스 기본
## 인덱스 구조 및 탐색
### 미리보는 인덱스 튜닝
#### 데이터를 찾는 두 가지 방법
* 데이터베이스 테이블에서 데이터를 찾는 방법은 두가지 이다.
  * 테이블 전체를 스캔한다.
  * 인덱스를 이용한다.
#### 인덱스 튜닝의 두 가지 핵심 요소
* 인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용한다.
* 온라인 트랜잭션 처리 시스템에서는 소량 데이터를 주로 검색하므로, 인덱스 튜닝이 무엇보다 중요하다.
* 인덱스 튜닝 방법은 여러가지가 있지만, 크게 두 가지로 나뉜다.
  * 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것으로, 인덱스 스캔 효울화 튜닝이다.
  * 테이블 액세스 횟수를 줄이는 것으로, 랜덤 액세스 최소화 튜닝이다. (인덱스 스캔 후 레코드를 액세스할 때 랜덤 I/O 방식 사용)
* 인덱스 스캔 효울화 튜닝과 랜덤 액세스 최소화 튜닝 모두 중요하지만, 랜덤 액세스 최소화 튜닝이 성능에 미치는 영향이 더 크다.
* 즉, SQL 튜닝은 랜덤 I/O가 가장 중요하다.

#### SQL 튜닝은 랜덤 I/O와의 전쟁
* 성능을 위해 DBMS가 제공하는 많은 기능은 느린 랜덤 I/O를 극복하기 위해 개발되었다.
  * IOT, 클러스터, 파티션, 테이블 Prefetch, Batch I/O 등
* 조인 메서드 중 가장 일방적으로 사용하는 NL조인이 대량 데이터 조인할 때 느린 이유도 랜덤 I/O 때문이다.
  * 그래서 소트머지 조인과 해시 조인이 개발되었다.

### 인덱스 구조
* 인덱스는 대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 액세스하기 위해 사용하는 오브젝트이다.
* 데이터베이스에서 인덱스 없이 데이터를 검색하려면 테이블을 처음부터 끝까지 읽어야 하지만, 인덱스를 이용해 일부만 읽고 멈출 수 있다.
  * 즉 범위스캔이 가능하며, 범위스캔이 가능한 이유는 인덱스가 정렬되어있기 때문이다.
* DBMS는 일반적으로 B-Tree 인덱스를 사용한다.
  * 루트와 브랜치 블록에는 키 값을 갖지 않는 특별한 레코드가 하나 있는데, 첫 번째 레코드이며, LMC(Leftmost Child)라고 한다.
  * LMC는 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다.
  * LMC가 기리키는 주소로 찾아간 블록에는, 키값을 가진 첫 번째 레코ㅓ드보다 작거나 같은 레코드가 저장되어있다.
  * 리프블록에 저장된 레코드는 키값 순으로 정렬되어있을 뿐만 아니라, 테이블 레코드를 가리키는 주소값인 ROWID를 갖는다.
* 인덱스 키값이 같으면 ROW_ID 순으로 정렬된다.
* 인덱스를 스캔하는 이유는 검색조건에 맞는 소량의 데이터를 빨리 찾아 ROWID를 얻기 위함이다.
  * ROWID = 데이터 블록 주소 + 로우번호
  * 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
  * 블록 번호 : 데이터파일 내에서 부여한 상대적 순번
  * 로우 번호 : 블록 내 순번
* 인덱스 탐색 과적은 수직적 탐색과 수평적 탐색으로 나눌 수 있다.
  * 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정
  * 수평적 탐색 : 데이터를 찾는 과정

### 인덱스 수직적 탐색 
* 정렬된 인덱스 레코드 중, 조건을 만족하는 첫 번째 레코드를 찾는 과정으로, 인덱스 스캔 시작 지점을 찾는 과정이다.
* 인덱스 수직적 탐색은 루트블록에서부터 시작한다.
* 루트를 포함해 브랜치 블록에 저장된 각 인덱스 레코드는 하위 블록에 대한 주소값을 갖는다.
* 루트에서 시작해 리프블록까지 수직적으로 탐색이 가능한 이유다.
* 찾고자 하는 값보다 크거나 같은 값을 만나면 직전 레코드가 가리키는 하위 블록으로 이동한다.
* 수직적 탐색은 레코드를 찾는 과정이 아니라, **조건을 만족하는 첫 번째 레코드를 찾는 과정**이다.

### 인덱스 수평적 탐색
* 수직적 탐색을 통해 스캔 시작점을 찾은 후, 찾고자 하는 데이터가 더 안나타날 때까지 인덱스 리프 블록을 수평적으로 스캔한다.
* 즉, 인덱스에서 본격적으로 데이터를 찾는 과정이다.
* 인덱스 리프 블록끼리는 서로 앞뒤 블록에 대한 주소값을 갖고 있는 양방향 연결 리스트 구조이다.
  * 좌에서 우, 우에서 좌로 수평적 탐색이 가능하다.
* 인덱스를 수평적 탐색하는 이유는 조건절을 만족하는 데이터를 모두 찾고, ROWID를 얻기 위해서이다.
  * 일반적으로는 인덱스를 스캔하고 테이블도 액세스 하는데, 이 때 ROWID가 필요하다.

### 결합 인덱스 구조와 탐색
* 두 개 이상 컬럼을 결합해 인덱스를 만들 수 있다.
* 인덱스를 `[고객명 + 성별]`로 하던, `[성별 + 고객명]`으로 하던 읽는 인덱스 블록 개수는 똑같다.
* 인덱스 선두 컬럼을 모두 `=` 조건으로 검색할 때에는 어느 컬럼을 앞쪽에 두든 블록 I/O 개수가 같으므로 성능도 같다.
  * 선택도가 낮은 컬럼을 앞쪽에 둬야 성능에 유리하다는 말은 잘못되었다.
  * `=`조건이 아니라 다른 조건들이 섞여있으면 컬럼 순서의 영향이 있다.

> Balanced
> * B-Tree에서의 B는 Balanced의 약자로, 어떤 값으로 탐색하더라도 인덱스 루트에서 리프까지 도달하기 위해 읽는 블록 수는 같다.

## 인덱스 기본 사용법
### 인덱스를 사용한다는 것
* 인덱스 컬럼을 가공하지 않아야 인덱스를 정상적으로 사용할 수 있다.
* 인덱스를 정상적으로 사용한다는 표현은 리프블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 멈추는걸 의미하며, 리프 블록 일부만 스캔하는 Index Range Scan을 의미한다.
* 인덱스 컬럼을 가공해도 인덱스를 사용할 순 있지만, 스캔 시작점을 찾을 수 없고 멈출 수 없어 리프블록 전체를 스캔해야 하므로, Index Full Scan방식으로 동작하게 된다.

### 인덱스를 Range Scan 할 수 없는 이유
* 인덱스 컬럼을 가공했을 때 인덱스를 정상적으로 사용할 수 없는 이유는, 인덱스 스캔 시작점을 찾을 수 없기 때문이다.
  * 일정 범위를 스캔하려면 시작 지점과 끝 지점이 있어야 한다.
* 인덱스에는 가공되지 않은 생년월일 값이 저장되어 있는데, 가공된 값을 기준으로 검색을 하려면 스캔 시작점과 끝지점을 찾을 수 없다.
  * `where substr(생년월일, 5, 2) = '05'`
* 값이 NULL이면 0으로 치환한 값 기준으로 100보다 작은 레코드를 찾아달라고 하면 인덱스 스캔 시작지점을 알 수가 없다.
  * `where nvl(주문수량, 0) < 100`
* 대한으로 시작하는 값은 특정 구간에 몰려있겠지만, 대한을 포함하는 값은 전체 구간에 흩어져 있어 Range Scan이 불가능하다.
  * `where 업체명 like '%대한%'`
* 전화번호가 01012341234 이거나 고객명이 홍길동인 한 시작점을 찾을 수 없기 떄문에 Range Scan이 불가능하다. 
  * `where (전화번호 = :tel_no OR 고객명 = :cust_nm'`

> OR Expansion
> * 아래 쿼리와 같이 변경하면 고객명, 전화번호 인덱스에 대해 Index Range Scan이 가능하다.
> * OR조건식을 SQL옵티마이저가 위와 같은 형태로 변환할 수 있는데, 이것을 OR Expansion이라고 한다.
> * ```
>   select *
>   from 고객
>   where 고객명 = :cust_nm
>   union all
>   select *
>   from 고객
>   where 전화번호 = :tel_no
>   and (고객명 <> :cust_nm or 고객명 is null)
>   ```
> * `use_concat` 힌트를 이용해 OR Expansion을 유도할 수 있다.

* IN 조건 또한 한 지점을 찾을 수 없다.
  * `where 전화번호 in (:tel_no1, :tel_no2)`
  * IN 조건 또한 UNION ALL 방식으로 작성하면 인덱스 스캔 시작점을 찾을 수 있다.
  * 그래서 IN 조건절에 대해서는 SQL 옵티마이저가 IN-List Iterator 방식을 사용한다.
  > IN-List Iterator
  > * List 개수만큼 Index Range Scan 반복한다.

### 더 중요한 인덱스 사용 조건
* 인덱스를 정상적으로 사용하는 데 있어 중요한 선행조건이 있다.
* 인덱스 Range Scan을 하기 위해선 인덱스 선두 컬럼이 조건절에 있어야 한다. 또한 가공하지 않은 상태여야 한다.
* 인덱스를 잘 탄다고 해도, 스캔 범위를 줄이는데 전혀 역할을 하지 못할 수 있다.

### 인덱스를 이용한 소트 연산 생략
* 테이블과 달리 인덱스는 정렬되어 있다.
* PK 인덱스를 스캔하면서 출력한 집합은 어차피 PK 순으로 정렬되기 때문에 ORDER BY가 있어도 연산을 따로 수행하지 않는다.
* 또한 DESCENDING 정렬에도 인덱스를 활용할 수 있다.
  * 인덱스 리프 블록은 양방향 연결 리스트 구조이기 때문이다.
* 따라서 ORDER BY 절에서 DESC정렬을 요구해도, ORDER BY 연산을 하지 않고, `INDEX (RAGE SCAN DESCENDING)`과 같이 인덱스를 사용한다.

### ORDER BY 절에서 컬럼 가공
* 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다는 말은 대개 조건절에 사용한 컬럼을 의미한다.
* 그런데 조건절이 아닌 ORDER BY 또는 SELECT-LIST에서 컬럼을 가공함으로 인해 인덱스를 정상적으로 사용할 수 없는 경우도 있다.
* 아래 예시는 주문_PK 인덱스는 `[주문일자 + 주문번호]` 순으로 구성되어 있는 경우에도 ORDER BY 연산을 하게 된다. 
```oracle
SELECT *
FROM (
    SELECT TO_CHAR(A.주문번호, 'FM000000') AS 주문번호, A.업체번호, A.주문금액
    FROM 주문 A
    WHERE A.주문일자 = :dt
        AND A.주문번호 > NVL(:next_ord_no, 0)
    ORDER BY 주문번호   -- TO_CHAR의 FM000000옵션이 사용된 주문번호이기 때문, A.주문번호로 해야 함
    )
WHERE ROWNUM <= 30
```

### SELECT-LIST 에서 컬럼 가공
* 인덱스가 `[장비번호 + 변경일자 + 변경순번]` 순으로 구성되어 있으면서 정렬연산을 생략하는 예시
  ```oracle
  SELECT MIN(변경순번)
  FROM 상태태변경이력
  WHERE 장비번호 = 'C'
    AND 변경일자 = '20180316'
  ```
  ```oracle
  SELECT MAX(변경순번)
  FROM 상태태변경이력
  WHERE 장비번호 = 'C'
    AND 변경일자 = '20180316'
  ```
* 정렬연산을 생략할 수 없는 예시
  ```oracle
  SELECT NVL(MAX(TO_NUMBER(변경순번)), 0)
  FROM 상태변경이력
  WHERE 장비번호 = 'C'
    AND 변경일자 = '20180316'
  ```
  * 인덱스에는 문자열 기준으로 정렬되어 있는데, 이를 숫자값으로 바꾼 값 기준으로 최종 변경순번을 요구했기 때문이다.
  ```oracle
  SELECT NVL(TO_NUMBER(MAX(변경순번)), 0)
  FROM 상태변경이력
  WHERE 장비번호 = 'C'
    AND 변경일자 = '20180316'
  ```
  * 위와같이 바꾸면 정렬연산 없이 변경순번을 쉽게 찾을 수 있다.

### 자동 형변환
* 생년월일이 선두 컬럼인 인덱스가 있을 때, 아래 SQL은 생년월일 컬럼을 가공하지 않았는데도 테이블 전체 스캔을 선택한다.
```oracle
SELECT * FROM 고객
WHERE 생년월일 = 19821225
```
* 옵티마이저가 SQL을 아래와 같이 변환했고 결국 인덱스 컬럼이 가공되었기 때문이다.
```oracle
SELECT * FROM 고객
WHERE TO_NUMBER(생년월일) = 19821225
```
* 각 조건절에 양쪽 값의 데이터 타입이 다르면, 타입체크를 엄격하게 하여 컴파일 시점에 에러를 내는 DBMS가 있고, 자동으로 형변환 처리해주는 DBMS가 있다.
  * 오라클은 자동으로 형변환처리 해준다.
* 오라클에서는 숫자형과 문자형이 만나면 숫자형이 이기므로, 숫자형 컬럼 기준으로 문자형 컬럼을 변환한다.
  * 연산자가 LIKE일때에는 문자열 비교 연산자이므로, 문자형 기준으로 숫자형 컬럼이 변환된다.
* 날짜형과 문자형('01-JAN-2018')이 만나면 날짜형이 이긴다.
* 따라서 아래와 같이 타입을 정확히 지정해주는 습관이 좋다.
```oracle
SELECT * FROM 고객
WHERE 가입일자 = TO_DATE('01-JAN-2018, DD_MON_YYYY')
```
* LIKE 조건을 옵션 처리 목적으로 사용하는 경우가 종종 있다.
  * 아래 예시에서 계좌번호가 숫자형이면 인덱스를 사용할 수 없다.
  ```oracle
  SELECT * FROM 거래
  WHERE 계좌번호 LIKE :acnt_no || '%'
  AND 거래일자 between :trd_dt1 and :trd_dt2
  ```
* 자동 형변환으로 인해 쿼리의 결과가 의도와는 다르게 나오는 경우도 있다.
* 따라서 자동 형변환의 기능에 의존하면 안된다.
* **인덱스 컬럼 기준으로 반대 편 컬럼 또는 값들을 정확하게 형변환 해줘야 한다.**

## 인덱스 확장기능 사용법
### Index Range Scan
* Index Range Scan은 B-Tree 인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식이다.
* 인덱스 루트에서 리프블록까지 수직적으로 탐색 후 필요한 범위만 스캔한다.

### Index Full Scan
* Index Full Scan은 수직적 탐색 없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식이다.
* 보통 데이터 검색을 위한 최적의 인덱스가 없을 경우 차선으로 선택된다.

#### Index Full Scan의 효용성
* 인덱스 선두컬럼이 조건절에 없으면 옵티마이저는 Table Full Scan을 고려한다.
* 하지만 대용량 테이블이어서 Table Full Scan에 따른 부담이 큰 경우 옵티마이저는 인덱스 활용을 다시 고려하지 않을 수 있다.
* 데이터 저장공간은 (컬럼길이 * 레코드 수)에 의해 결정되므로 인덱스가 차지하는 면적은 테이블보다 훨씬 적다.
* 인덱스 스캔 단계에서는 대부분 레코드를 필터링하고 아주 일부만 테이블을 액세스 하는 상황이라면 면적이 큰 테이블보다 인덱스를 스캔하는쪽이 유리하다.
* 옵티마이저가 이럴경우엔 Index Full Scan 방식을 선택한다.

#### 인덱스를 이용한 소트 연산 생략
* 인덱스를 Full Scan하면 결과 집함이 인덱스 컬럼 순으로 정렬된다.
* 따라서 옵티마이저가 전략적으로 선택한 경우, Sort Order By 연산을 생략할 목적으로 사용할 수도 있다.
* 하지만 대부분이 조건을 만족하는 상황에서 Index Full Scan을 선택하면 거의 모든 레코드에 대해 테이블 액세스가 발생하므로, Table Full Scan보다 오히려 불리하다.

### Index Unique Scan
* Index Unique Scan은 수직적 탐색만으로 데이터를 찾는 스캔 방식으로, Unique 인덱스를 `=` 조건으로 탐색하는 경우 작동한다.
* Unique Index가 존재하는 컬럼은 중복 값이 입력되지 않게 DBMS가 데이터 정합성을 관리해준다.
* 그러므로 해당 인덱스 키 컬럼을 모두 `=` 조건으로 검색할 때는 데이터를 한 건 찾는 순간 더이상 탐색할 필요가 없다.

### Index Skip Scan
* 인덱스 선두 컬럼을 조건절에 사용하지 않으면 옵티마이저는 기본적으로 Table Full Scan을 선택한다.
* 하지만 Table Full Scan 보다 I/O를 줄일 수 있거나 정렬된 결과를 쉽게 얻을 수 있다면 Index Full Scan을 사용하기도 한다.
* 오라클은 인덱스 선두컬럼이 조건절에 없어도 인덱스를 활용하는 새로운 스캔 방식을 9i버전에서 선보였는데, 이게 Index Skip Scan이다.
* Index Skip Scan은 조건절에 빠진 인덱스 선두 컬럼의 Distinct Value 개수가 적고 후행 컬럼의 Distinct Value 개수가 많을 때 유용하다.
* `index_ss`, `no_index_ss` 힌트를 사용해 이 스캔 방식을 유도하거나 방지할 수 있다.

#### Index Skip Scan이 작동하기 위한 조건
* Index Skip Scan은 Distinct Value 개수가 적은 선두 컬럼이 조건절에 없고, 후행 컬럼의 Distinct Value 개수가 많을 때 효과적이다.
* 하지만 인덱스 선두 컬럼이 없을 때만 Index Skip Scan이 작동하는건 아니다.
* 선두컬럼에 대한 조건절은 있고, 중간컬럼에 대한 조건절이 없는 경우에도 Skip Scan을 사용할 수 있다.
  ```oracle
  -- 일별업종별거래_PK : 업종유형코드 + 업종코드 + 기준일자
  SELECT /*+ INDEX_SS(A 일별업종별거래_PK) */
        기준일자, 업종코드, 체결건수, 체결수량, 거래대금
  FROM 일별업종별거래 A
  WHERE 업종유형코드 = '01'
      AND 기준일자 BETWEEN '20080501' AND '20080531'
  ```
  * 위 예시에서 Index Range Scan을 사용하면 업종코드유형이 '01'인 인덱스 구간을 모두 스캔해야 한다.
  * Index Skip Scan을 사용하면 업종코드유형이 '01'인 구간에서 기준일자 조건의 레코드를 포함할 가능성이 있는 리프 블록만 골라서 액세스할 수 있다.
* 선두컬럼이 부등호, BETWEEN, LIKE같은 범위 검색 조건일 때도 Index Skip Scan을 사용할 수 있다.
  ```oracle
  -- 일별업종별거래_X01 : 기준일자 + 업종유형코드
  SELECT /*+ INDEX_SS(A 일별업종별거래_X01) */
        기준일자, 업종코드, 체결건수, 체결수량, 거래대금
  FROM 일별업종별거래 A
  WHERE 기준일자 BETWEEN '20080501' AND '20080531'
    AND 업종유형코드 = '01'
  ```
  * 위 예시에서 Index Range Scan을 사용한다면, 기준일자 BETWEEN 조건을 만족하는 인덱스 구간을 모두 스캔해야 한다.
  * 조건을 만족하는 인덱스 구간에서 업종유형코드 = '01'인 레코드를 포함할 가능성이 있는 리프블록만 골라서 액세스할 수 있다.
* Index Range Scan이 불가능하거나 효율적이지 못한 상황에서 Index Skip Scan이 종종 빛을 발할 수 있다.
* **인덱스는 기본적으로 최적의 Index Range Scan을 목표로 설계해야 하며, 수행횟수가 적은 SQL을 위해 인덱스를 추가하는것이 비효율적일 때 이러한 스캔 방식을 차선책으로 활용하는 전략이 바람직하다.**

### Index Fast Full Scan
* Index Fast Full Scan은 Index Full Scan보다 빠르다
* 논리적인 인덱스 트리구조를 무시하고 인덱스 세그먼트 전체를 Multiblock I/O 방식으로 스캔하기 때문에 Index Full Scan보다 빠르다.
* `index_ffs`, `no_index_ffs` 힌트로 이 스캔방식을 유도하거나 방지할 수 있다.
* Index Fast Full Scan은 루트와 브랜치블록은 읽지만 필요없으므로 무시한다.
* Index Fast Full Scan은 Multiblock I/O 방식을 사용하므로, 디스크로부터 대량의 인덱스 블록을 읽어야 할 때 큰 효과를 발위한다.
* 연결리스트 구조를 무시한 채 데이터를 읽기 때문에, 결과 집합이 인덱스 키 순서대로 정렬되지 않는다.
* 쿼리에 사용한 컬럼이 모두 인덱스에 포함되어 있을 때만 사용할 수 있다.
* Index Range Scan 또는 Index Full Scan과 달리 인덱스가 파티션 되어있지 않더라도 병렬쿼리가 가능하다.
* 병렬 쿼리 시에는 Direct Path I/O 방식을 사용하기 때문에 I/O 속도가 더 빨라진다.

### Index Range Scan Descending
* Index Range Scan과 기본적으로 동일한 스캔 방식으로, 인덱스를 뒤에서 앞쪽으로 스캔하기 떄문에 내림차순으로 정렬된 결과집합을 얻는다.
* `index_desc` 힌트를 이용해 유도할 수 있다.
* MAX 값을 구하고자 할 때에 해당 컬럼에 인덱스가 있으면 인덱스를 뒤에서부터 한 건만 읽고 멈추는 실행계획이 자동으로 수립된다.

# 인덱스 튜닝
## 테이블 액세스 최소화
### 테이블 랜덤 액세스
#### 인덱스 ROWID는 물리적? 논리적?
* 인덱스 ROWID는 물리적 주소보다 논리적 주소에 가깝다.
* 물리적으로 직접 연결되지 않고 테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고있기 때문이다.
* 메모리상 데이터를 찾아가는데 있어 포인터의 비용은 0에 가깝고, 물리적으로 직접 연결된 구조와 다름없다.
* 인덱스 ROWID는 포인터와는 다르다. 테이블 레코드를 찾아가기위한 위치 정보만을 담고 있으며, 테이블 레코드와 물리적으로 연결된 구조가 아니다.
* 오라클은 테이블 블록이 수시로 버퍼캐시에서 밀려났다 다시 캐싱되기를 반복한다.
* 그때마다 다른 공간에 캐싱되기 때문에 인덱스에서 포인터로 직접 연결할 수 없는 구조이다.
* 메모리 주소 정보(포인터)가 아닌 디스크 주소 정보(Data Block Address)를 이용해 해시 알고리즘으로 버퍼 블록을 찾아간다.

#### I/O 메커니즘
* DBA는 디스크 상에서 블록을 찾기 위한 주소 정보이다.
* I/O성능을 높으려면 매번 디스크에서 블록을 읽을 수 없기 때문에 버퍼캐시를 활용해야 한다.
* 그래서 블록을 읽을 때 디스크로 가기 전 버퍼캐시부터 찾아본다.
  * 읽고자 하는 DBA를 해시함수에 입력해 해시 체인을 찾고 거기서 버퍼 헤더를 찾는다.
* 캐시에 적재할 때와 읽을 때 같은 해시 함수를 사용하므로, 버퍼 헤더는 항상 같은 해시 체인에 연결된다.
* 하지만 실제 데이터가 담긴 버퍼 블록은 매번 다른 위치에 캐싱되는데, 그 메모리 주소값을 버퍼 헤더가 갖고 있다.
* 따라서 해싱 알고리즘으로 버퍼 헤더를 찾고 거기서 얻은 포인터로 버퍼블록을 찾아간다.
* 인덱스로 테이블 블록을 액세스할 때에는 리프블록에서 읽은 ROWID를 분해해 DBA정보를 얻고, 테이블을 Full Scan할 때는 익스텐트 맵을 통해 읽은 블록들의 DBA정보를 얻는다.
* 즉, ROWID는 포인터가 아니고 테이블 레코드를 찾아가기 위한 논리적인 주소정보이다.
  * ROWID가 가리키는 테이블 블록을 버퍼캐시에서 먼저 찾은 후, 못 찾을 때만 디스크에서 블록을 읽는다. (버퍼캐시 적재 후 읽음)
  * 모든 데이터가 캐싱되어 있어도 테이블 레코드를 찾기 위해 DBA 해싱과 래치 획득 과정을 반복해야 한다.
  * 캐시버퍼 체인 래치와 버퍼 Lock에 대한 경합까지 발생한다.
* ROWID를 이용한 테이블 액세스는 생각보다 고비용 구조이다. 

* `TABLE ACCESS BY INDEX ROWID` 오퍼레이션을 볼 때마다 이러한 복잡한 처리과정을 떠올려야 한다.

### 인덱스 클러스터링 팩터
* 클러스터링 팩터(CF)는 군집성 계수로, 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다.
* CF가 좋은 컬럼에 생성한 인덱스는 검색효율이 매우 좋다.
* 테이블 액세스량에 비해 블록 I/O가 적게 발생하기 때문이다.
* 인덱스 ROWID로 테이블을 액세스 할 때, 오라클은 래치 획득과 해시체인 스캔 과정을 거쳐 찾아간 테이블 블록에 대한 포인터를 해제하지 않고 유지한다. (버퍼 Pinning)
* 이 상태에서 다음 인덱스 레코드를 읽었는데, 직전과 같은 테이블 블록을 가리킨 경우, 래치 획득과 해시 체인 스캔 과정을 생략하고 테이블 블록을 읽을 수 있다.
  * 논리적 I/O 과정을 생략할 수 있는 것이다.

### 인덱스 손익 분기점
* 인덱스 ROWID를 이용한 테이블 액세스는 생각보다 고비용 구조이다.
* 읽어야할 데이터가 일정량을 넘는 순간, 테이블 전체를 스캔하는것보다 오히려 느려진다.
  * Table Full Scan은 시퀀셜 액세스인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스 방식이다.
  * Table Full Scan은 Multiblock I/O인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 Single Block I/O 방식이다.
* Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점을 인덱스 손익분기점이라고 부른다.
* 인덱스 CF가 나쁘면 같은 테이블 블록을 여러번 반복 액세스 하면서 논리적 I/O 횟수가 늘어나고, 물리적 I/O 횟수도 늘어나게 된다.
* 인덱스 손익분기점은 보통 5~20%의 낮은 수준에서 결정된다.
  * CF가 나쁘면 손익분기점은 5%미만에서 결정되며, CF가 아주 좋을 땐 90%수준까지도 올라간다.
  * 이 수치는 많아봐야 100만건 이내 테이블에나 적용되는 수치이고, 1000만건 수준의 큰 테이블에선 손익분기점이 더 낮아진다.
    * 버퍼캐시에 할당하는 메모리 크기가 점점 커지는 추세이지만, 요즘 기준으로 보통 수백만개 블록을 캐싱하는 수준이다.
    * 따라서 특정 테이블을 인덱스로 100만건 이상 액세스 한다면 캐시 히트율은 극히 낮을수밖에 없다.
    * 1000만건 정도의 테이블이면 CF도 안좋을 가능성이 높고, 손익분기점 자체가 의미가 없어지므로, 만건만 넘게 읽어도 Table Full Scan방식이 빠를 수 있다.
* 따라서 테이블스캔이 항상 나쁜것은 아니고, 인덱스 스캔이 항상 좋은것도 아니라고 말할 수 있다.

#### 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝
* 온라인 프로그램은 보통 소량 데이터를 읽고 갱신하므로 인덱스를 효과적으로 활용하는것이 무엇보다 중요하다.
  * 조인도 대부분 NL 방식을 사용한다.
  * NL조인은 인덱스를 이용하는 조인 방식으로, 인덱스를 이용해 소트 연산을 생략함으로써 부분범위 처리 방식으로 구현할 수 있다면 온라인 환경에서 대량의 데이터를 조회할 때에도 아주 빠른 응답 속도를 낼 수 있다.
* 배치 프로그램은 항상 전체 범위 처리 기준으로 튜닝해야 한다.
  * 대량의 데이터를 빠르게 처리하려면 인덱스와 NL조인보다 Full Scan과 해시조인이 유리하다.
  * 배치 프로그램에선 인덱스보다 Full Scan이 효과적이지만, 초대용량 테이블을 Full Scan하면 상당히 오래 기다려야 하고 시스템에 주는 부담도 커진다.
  * 따라서 파티션 활용 전략이 매우 중요한 튜닝 요소이며, 병렬처리까지 할 수 있으면 더더욱 좋다.
  * 파티셔닝하는 이유는 결국 Full Scan을 빠르게 처리하기 위해서이다.

### 인덱스 컬럼 추가
* 실 운영 환경에서는 인덱스 구성을 변경하기는 절대 쉽지 않다.
* 그렇다고 인덱스를 새로 만들게 되면, 인덱스를 계속 추가하게 되어 테이블마다 인덱스가 수십개씩 달려 있는 상황이 되어버릴 수 있다.
  * 인덱스 관리 비용이 증가하는것은 물론이며, DML 부하에 따른 트랜잭션 성능 저하가 생길 수 있다.
* 따라서 기존 인덱스에 특정 컬럼만 추가하는것으로 큰 효과를 얻을 수 있다.

### 인덱스만 읽고 처리
* 비효율이 없어도 인덱스 스캔 과정에서 얻은 데이터가 많다면 테이블 랜덤 액세스가 많이 발생하므로 성능은 느릴수밖에 없다.
```oracle
SELECT 부서번호, SUM(수량)
FROM 판매집계
WHERE 부서번호 LIKE '12%'
GROUP BY 부서번호;
```
* 이런 상황에서 고려해볼 수 있는 건 쿼리에 사용된 컬럼을 모두 인덱스에 추가해 테이블 액세스가 아예 발생하지 않도록 할 수 있다.
* 이렇게 인덱스만 읽어서 처리하는 쿼리를 **Covered 쿼리**라고 부르며, 그 쿼리에 사용한 인덱스를 **Covered 인덱스**라고 부른다.
* 하지만 이러한 방법은 추가해야 할 컬럼이 많아 실제로는 적용하기 곤란한 경우가 많다.

#### include 인덱스
* Oracle엔 없고 SQL Server 2005 버전에 추가된 기능이다.
* 인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능이다.
* `create index emp_x01 on emp (deptno) incloude (sal)`
  * 해당 인덱스를 이용하면, 수직적 탐색에는 DEPTNO만 사용하고, 수평적 탐색에는 SAL 컬럼도 필터 조건으로 사용할 수 있다.
  * 즉, SAL 컬럼은 테이블 랜덤 액세스 횟수를 줄이는 용도로 사용된다. 
  * 하지만 소트 연산은 생략할 수 없다.

### 인덱스 구조 테이블
* 랜덤액세스가 아예 발생하지 않도록 테이블을 인덱스 구조로 생성할 수 있다.
* 오라클은 IOT(Index-Organized Table)이라고 부른다.
  * MS-SQL Server는 클러스터형(Clustered) 인덱스라고 부른다.
* 테이블을 찾아가기위한 ROWID를 갖는 일반 인덱스와는 달리 IOT는 그 자리에 테이블 데이터를 갖는다.
  * 테이블 블록에 있어야할 데이터를 리프블록에 모두 저장하고 있다.
  * 즉, IOT에서는 인덱스 리프블록이 곧 데이터 블록이다.
* 아래와 같이 테이블을 인덱스 구조로 만들 수 있다.
  ```oracle
  create table index_org_t(t number, b varchar(10), constraint index_org_t_pk primary key (a))
  organization index ;
  ```
* 일반 테이블은 힙구조 테이블이라 부르며, 테이블 생성 시 보통 생략하지만 직접 명시할 수도 있다.
  ```oracle
  create table heap_org_t(a number, b varchar(10), constraint heap_org_t_pk primary key (a))
  organization heap ;
  ```
* 일반 힙구조 테이블에 데이터를 입력할 때에는 랜덤 방식을 사용하지만(Freelist로부터 할당받은 블록에 순서 없이 데이터 입력), IOT는 인덱스 구조 테이블이므로 정렬 상태를 유지하며 데이터를 입력한다.
* IOT는 인위적으로 CF를 좋게 만드는 방법 중 하나이다.

### 클러스터 테이블
* 클러스터 테이블에는 인덱스 클러스터와 해시 클러스터 두 가지가 있다.
#### 인덱스 클러스터 테이블
* 인덱스 클러스 테이블은 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조이다.
* 한 블록에 모두 담을 수 없을 때는 새로운 블록을 할당해서 클러스터 체인으로 연결한다.
* 또한 여러 테이블 레코드를 한 블록에 저장할 수 있는데, 이를 다중 테이블 클러스터라고 부른다.
  * 일반 테이블은 하나의 데이터 블록을 여러 테이블이 공유할 수 없다.
* 아래와 같이 인덱스 클러스터형 테이블을 만들 수 있다.

  ```oracle
  create cluster c_dept# ( deptno number(2) ) index ;
  ```
* 클러스터에 테이블을 담기 전 아래와 같이 클러스터 인덱스를 반드시 정의해야 한다.

  ```oracle
  create index c_dept#idx on cluster c_dept#;
  ```
  * 클러스터 인덱스는 데이터 검색용도로 사용할 뿐만 아니라 데이터가 저장된 위치를 찾을 때에도 사용한다.

* 클러스터 인덱스도 일반 B-Tree 인덱스 구조를 사용하지만, 테이블 레코드를 일일이 가리키지 않고 해당 키 값을 저장하는 첫 번째 테이블 블록을 가리킨다.
  * 일반 테이블에 생성한 인덱스 레코드는 테이블 레코드와 1:1대응관계를 갖지만 클러스터 인덱스는 테이블 레코드와 1:N 관계를 갖는다.
* 그러므로 클러스터 인덱스의 키 값은 항상 Unique하다.
* 클러스터 인덱스를 스캔하면서 값을 찾을 때에는 랜덤액세스가 값 하나당 한번씩 밖에 발생하지 않는다. (클러스터 체인을 스캔하면서 발생하는 랜덤 액세스는 제외)
* **클러스터에 도달해 시퀀셜 방식으로 스캔하기 때문에 넓은 범위를 읽더라도 비효율이 없다.**

#### 해시 클러스터 테이블
* 해시 클러스터는 인덱스를 사용하지 않고 해시 알고리즘을 사용해 클러스터를 찾아간다.
* 아래와 같이 해시 클러스터를 생성할 수 있다.
  ```oracle
  create cluster c_dept# ( deptno number(2) ) hashkeys 4 ;
  ```
* 그리고 아래와 같이 클러스터 테이블을 생성한다.
  ```oracle
  create table dept (
    deptno number(2) not null
  , dname varchar2(14) not null
  , loc varchar2(13))
  cluster c_dept#( deptno );
  ```

## 부분범위 처리 활용
* 부분범위 처리를 활용하면 인덱스로 액세스할 대상 레코드가 아무리 많아도 아주 빠른 응답속도를 낼 수 있다.

### 부분범위 처리
* 아무리 많은건을 요청을 해도, DBMS가 데이터를 모두 읽고 한번에 전송하지 않고 먼저 읽는 데이터부터 일정량을 전송하고 멈춘다.
* 데이터를 전송하고 나면 서버 프로세스는 CPU를 OS에 반환하고 대기 큐에서 잠을 잔다.
* 다음 Fetch Call을 받으면 대기 큐에서 나와 그다음 데이터부터 일정량(Array Size) 읽어서 전송하기 다시 잠을 잔다.
* 이렇게 전체 쿼리 결과집합을 쉼없이 전송하지 않고 사용자로부터 Fetch Call이 있을 때마다 일정량씩 나눠서 전송하는 것을 부분범위 처리라고 한다.
* JAVA에서 Array Size 기본 값은 10이고, Statement 객체 setFetchSize 메소드를 통해 설정을 변경할 수 있다.

> 잘못된 상식
> * 쿼리 수행 시 결과 집합을 버퍼캐시에 모두 적재하고 사용자에게 전송한다고 알고있는 사람이 있는데, 잘못되었다.

#### 정렬 조건이 있을 때 부분 범위 처리
* DB서버는 모든 데이터를 다 읽어 정렬을 마치고 나서야 클라이언트에게 데이터 전송을 시작할 수 있다.
* Sort Area와 Temp 테이블스페이스까지 이용해 데이터 정렬을 마치고 나면 그때부터 일정량씩 나눠 클라이언트에게 데이터를 전송한다.
* 정렬기준 컬럼이 선두인 인덱스가 있으면 부분범위처리가 가능하다.
* 인덱스는 항상 정렬된 상태를 유지하므로, 전체 데이터를 정렬하지 않고도 정렬된 상태의 결과집합을 바로 전송할 수 있다.

#### Array Size 조정을 통한 Fetch Call 최소화
* 대량의 데이터를 파일로 내려받는다면 어차피 데이터를 모두 전송해야하기 때문에 가급적 Array Size를 크게 해야 한다.
  * Fetch Call 횟수를 그만큼 줄일 수 있다.
* 하지만 앞 쪽 일부 데이터만 Fetch하다 멈추는 프로그램이라면 Array Size를 작게 설정하는 것이 좋다.
  * 불필요하게 많은 데이터를 전송하고 버리는 비효율을 줄일 수 있다.

#### 쿼리 툴에서 부분 범위 처리
* 토드나 오렌지같은 쿼리 툴에서도 쿼리의 결과가 아무리 많아도 일찍 끝나는 것을 볼 수 있다.
* 그 이유는 전체 데이터 중 먼저 읽은 일정 수의 데이터만 출력하도록 해놓았기 때문이다. 즉, Array Size가 기본적으로 설정되어있기 때문이다.
* 모든 DBMS는 부분범위 처리 방식으로 결과집합을 전송한다. 
* 이 특징을 이용해 중간에 멈췄다 사용자의 추가 요청이 있을 때마다 데이터를 가져오도록 구현하고 안하고는 클라이언트 프로그램을 개발하는 개발자의 몫이다.

### 부분범위 처리 구현
* 부분범위 처리와 관련된 부분을 개발자가 일일이 구현할 순 없기 때문에, 개발 프레임워크에 미리 구현되어있는 기능을 활용한다.

### OLTP 환경에서 부분범위 처리에 의한 성능개선 원리
* OLTP 시스템도 수천 수만건을 조회하는 경우도 있다.
* 인덱스를 이용해 수천 수만건을 조회하려고 하면 성능을 내기 어려울 수 있다.
  * 많은 랜덤액세스가 발생하기 때문이다.
* OLTP성 업무에서 쿼리 결과 집함이 아주 많을 때 사용자가 모든 데이터를 일일이 확인하진 않고, 특정한 정렬 순으로 상위 일부 데이터만 확인한다.
* 따라서 인덱스와 부분범위 처리 원리를 잘 활용하면 OLTP 환경에서 좋은 성능개선 효과를 얻을 수 있다.

#### 멈출 수 있어야 의미있는 부분범위 처리
* 클라이언트와 DB 서버 사이에 WAS, AP 서버 등이 존재하는 n-Tier 아키텍처에서는 클라이언트가 특정 DB 커넥션을 독점할 수 없다.
* 단위작업을 마치면 DB 커넥션을 커넥션 풀에 반환해야 하므로, 그 전에 SQL조회 결과를 클라이언트에 모두 전송하고 커서를 닫아야 한다.
* 그렇다고 해서 부분범위 처리는 n-Tier 환경에서 의미없는 개념은 아니다.

> 배치 I/O
> * 디스크 랜덤 I/O 성능을 DBMS업체들이 계속 노력을 하는데, 오라클에서는  배치 I/O 기능으로 눈에 띄는 개선을 했다.
> * 배치 I/O는 읽는 블록마다 건건이 I/O Call을 발생시키는 비효율을 줄이기 위해 고안한 기능이다.
> * 인덱스를 이용해 테이블을 액세스하다 버퍼캐시에서 블록을 찾지 못하면 디스크 블록을 바로 읽는데, 이 기능이 작동하면 테이블 블록에 대한 디스크 I/O Call을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리한다.
>   * 11g에서는 NL 조인 Inner 쪽 테이블 액세스할 때에만 이 기능이 작동했지만, 12c부터는 인덱스 ROWID로 테이블 액세스하는 어떤 부분에서든 이 기능이 작동할 수 있다.
> * 배치 I/O 기능이 작동하면 인덱스를 이용해 출력하는 데이터 정렬 순서가 매번 다를 수 있다.
> * 따라서 배치 I/O 기능이 작동하면 데이터 정렬순서를 보장할 수 없기 때문에 소트연산을 생략할 수 없을 수 있다.
> * 배치 I/O를 통해 얻을 수 있는 이점이 많음에도 이 기능을 비활성화하는 이유가 이러한 이유이다.

## 인덱스 스캔 효율화
### 인덱스 탐색
* 인덱스가 어떻게 설정되어있고, 어떤식으로 조건을 걸 때 인덱스를 어떤식으로 스캔할지 알아야 한다.
* p174 ~ p179 참고

### 인덱스 스캔 효율성
* 인덱스가 어떻게 설정되어있고, 어떤식으로 조건을 걸 때 인덱스를 어떤식으로 스캔할지 알아야 한다.
* 인덱스 선행 컬럼이 조건에 없는 경우 스캔 범위가 늘어난다는 것을 알아야 한다.
* p180 ~ p184 참고

#### 인덱스 스캔 효율성 측정
* 조건절 데이터를 일일이 조회해보는 방법도 있지만, SQL 트레이스를 통해 쉽게 알 수 있다.
* 예를들면 인덱스를 스캔하고 얻은 레코드가 적은데데, 그 과정에 읽은 블록수가 많으면 비효율적이라고 볼 수 있다.

### 액세스 조건과 필터 조건
* 인덱스를 스캔하는 단계에 처리하는 조건절은 액세스 조건과 필터 조건으로 나뉜다.
* 인덱스 액세스 조건은 인덱스 스캔 범위를 결정하는 조건절이다.
  * 인덱스 수직적 탐색을 통해 스캔 시작점을 결정하는데 영향을 미친다.
  * 인덱스 리프 블록을 스캔하다가 어디서 멈출지를 결정하는데 영향을 미친다.
* 인덱스 필터 조건은 테이블로 액세스할지를 결정하는 조건절이다.
* 인덱스를 이용하던 테이블을 Full Scan하던 테이블 액세스 단계에서 처리되는 조건절은 모두 필터조건이다.
* 테이블 필터 조건은 쿼리 수행 다음 단계로 전달하거나 최종 결과 집함에 포함할지를 결정한다.

### 비교 연산자 종류와 컬럼 순서에 따른 군집성
* 선행 컬럼이 모두 `=` 조건인 상태에서 첫 번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 연속해서 모여있다.
* 그 이하 조건까지 만족하는 레코드는 비교연산자 종류에 상관없이 흩어지게 된다.

#### 범위검색 조건 맨 처음과 마지막 구간에서의 액세스 조건
```oracle
where C1 between 1 and 3
    and C2 = 'A'
    and C3 = '나'
    and C4 = 'a'
```
* C1, C2, C3, C4로 인덱스가 구성되어있을 때 위 조건일 경우엔 액세스 조건은 C1, 필터조건은 C2, C3, C4이다.
* 하지만 `C1 = 1`, `C1 = 3`인 구간에서 C2, C3, C4도 인덱스 스캔량을 줄이는데 어느정도 역할을 할 수 있다.
  * `C1 = 3` 구간에서 `C2 = 'A'`, `C3 = '나'`, `C4 = 'a'`보다 큰 값을 만나는순간 멈추기 때문이다.
* 첫 범위검색 이후 조건절 컬럼은 스캔범위를 줄이는데 큰 역할을 못함에도, 아래와 같이 몇 가지 케이스를 제외하면 인덱스 컬럼에 대한 조건절은 모두 액세스 조건에 표시된다. 
  * 좌변 컬럼을 가공한 조건절
  * 왼쪽 `%` 또는 양쪽 `%` 기호를 사용한 `like` 조건절
  * 같은 컬럼에 대한 조건절이 두 개 이상일 때 인덱스 액세스 조건으로 선택되지 못한 조건절
  * OR Expansion 또는 INLIST ITERATOR로 선택되지 못한 OR 또는 IN 조건절
* 복잡하게 생각할 것 없이, 첫 번째 나타나는 범위검색 조건까지가 인덱스 액세스 조건이고, 나머지는 필터조건이라고 이해하는게 좋다.

### 인덱스 선행 컬럼이 등치(`=`) 조건이 아닐 때 생기는 비효율
* 인덱스 스캔 효율성은 인덱스 컬럼을 조건절에 모두 `=` 조건으로 사용할 때 가장 좋다.
* 인덱스 컬럼 중 일부가 조건절에 없거나 등치 조건이 아니더라도, 그것이 뒤 쪽 컬럼일 때에는 비효율이 전혀 없다.
* 인덱스 선행 컬럼이 모두 `=` 조건일 때 필요한 범위만 스캔하고 멈출 수 있는 것은 조건을 만족하는 레코드가 모두 한 곳에 모여있기 때문이다.

### BETWEEN을 IN-List로 전환
* 범위검색 컬럼이 맨 뒤로 가도록 인데스를 변경하면 좋겠지만, 운영 시스템에서 인덱스 구성을 바꾸기는 쉽지 않다.
* 이럴 때에는 BETWEEN 조건을 IN-List로 바꿔주면 큰 효과를 얻는 경우가 있다.
* IN-LIST 개수 만큼 UNION ALL 브랜치가 생성되고 각 브랜치마다 모든 컬럼을 `=` 조건으로 검색하기 때문에, BETWEEN을 사용할 때와 같은 비효율이 사라진다.
  * 옵티마이저가 IN-List Iterator 방식 사용하게 된다.
* IN-List 항목 개수가 늘어날 수 있는 경우 BETWEEN을 IN-List로 전환하는 방식은 사용하기 곤란할 수 있다.
  * 이럴 경우엔 NL의 조인문이나 서브쿼리로 구현하면 된다. (IN-List 값들을 코드 테이블로 관리하고 있는 경우만)
* 또한 Index Skip Scan 방식으로 유도해도 비슷한 효과를 얻을 수 있다.

#### BETWEEN 조건을 IN-List로 전환할 때 주의사항
* IN-List의 개수가 많지 않아야 한다.
* IN-List의 개수가 많으면 수직적 탐색이 많이 발생한다.
* 이런 경우엔 리프블록을 많이 스캔하는 비효율보다 IN-List 개수만큼 브랜치 블록을 반복 탐색하는 비효율이 더 클 수 있다.
  * 루트에서 브랜치 블록까지 Depth가 더 깊을 경우 특히 그렇다.
* BETWEEN 조건 때문에 인덱스를 비효율적으로 스캔하더라도, 블록 I/O 측면에서는 보통 소량에 그치는 경우가 많다.
* 인덱스 리프 블록에는 테이블 블록과 달리 많은 레코드가 담기기 때문이다.
* 또한 IN-List 개수가 많으면 수직적 탐색 과정에서 많은 블록을 읽게 된다.
* **데이터 분포나 수직적 탐색 비용을 따져보지도 않고 BETWEEN을 IN-List로 변환하면 안된다.**

#### Index Skip Scan 활용
* BETWEEN 조건을 IN-List 조건으로 변환하면 도움이 되는 상황에서 굳이 조건절을 바꾸지 않고도 효과를 낼 방법이 있는데, Index Skip Scan을 활용하면 된다.
* 선두 컬럼이 BETWEEN이어서 나머지 검색 조건을 만족하는 데이터들이 서로 멀리 떨어져 있을 때 Index Skip Scan이 효율적이다.

### IN 조건은 `=`인가?
* IN 조건은 `=`이 아니다.
* 인덱스를 어떻게 구성하냐에 따라 성능도 달라질 수 있다.
* IN 조건에 `=`이 되려면 IN-List Interator 방식으로 풀려야만 한다.
* 그렇지 않으면 IN 조건은 필터 조건이다.
  * p204~p205 참고
* 또한 IN 조건을 액세스 조건으로 만들기 위해 `=`조건으로 만들어 IN-List Iterator 방식으로 푸는게 항상 효과적이지도 않다.

#### NUM_INDEX_KEYS
* IN-List를 액세스조건 또는 필터조건으로 유도하는 방법이 있다.
* 인덱스가 `[고객번호 + 상품ID]` 순으로 구성된 상황에서 고객번호만 인덱스 액세스 조건으로 사용하려면 아래와 같이 힌트를 사용하면 된다.
```oracle
select /*+ num_index_keys(a 고객별가입상품_X1 1)*/ 
    *
from 고객별가입상품 a
where 고객번호 = :cust_no
and 상품ID in ('T01', 'T05', 'T52')
```
* 3번째 인자 1은 인덱스의 첫 번째 컬럼까지만 액세스 조건으로 사용하라는 의미이다.
* 또한 힌트 사용 없이, 인덱스 컬럼을 일부로 가공하는 방법도 있다.
```oracle
select *
from 고객별가입상품 a
where 고객번호 = :cust_no
and RTRIM(상품ID) in ('T01', 'T05', 'T52')

select *
from 고객별가입상품 a
where 고객번호 = :cust_no
  and 상품ID || ''  in ('T01', 'T05', 'T52')
```

### BETWEEN과 LIKE 스캔 범위 비교
* LIKE와 BETWEEN은 둘 다 범위검색 조건으로, 범위검색 조건을 사용할 때의 비효율 원리가 똑같이 적용된다.
* LIKE보다는 BETWEEN을 사용하는게 좋다.
* 물론 사용하기엔 BETWEEN이 불편하지만, BETWEEN을 사용하면 적어도 손해는 안본다.

### 범위검색 조건을 남용할 때 생기는 비효율
* 사용자 입력에 따라 조건절이 다양하게 바뀌는 경우, SQL을 간편하게 작성하려고 조건절을 모두 LIKE로 개발해버리는 경우가 있다.
* 이럴 경우 액세스 조건이 필터 조건으로 변해버릴 수도 있다.
* 코딩을 쉽게 하기 위해 인덱스 컬럼에 범위검색조건을 남용하면 인덱스 스캔 비효율이 생긴다.
* 대량의 테이블을 넓은 범위로 검색할 경우 더더욱 영향이 심해진다.
* 데이터 분포에 따라 인덱스 컬럼에 대한 비교 연산자를 신중하게 선택해야 한다.

### 다양한 옵션 조건 처리 방식의 장단점 비교
#### OR 조건 활용
```oracle
select * from 거래
where (:cust_id is null or 고객ID = :cust_id)
    and 거래일자 between :dt1 and :dt2
```
* 인덱스가 `[고객ID + 거래일자]`로 구성되어있는 경우, 옵션 조건 컬럼을 선두에 두어도 인덱스를 사용할 수 없다.
* `[거래일자 + 고객ID]`로 구성한 인덱스는 사용할 순 있지만, 고객 ID를 필터조건으로 사용하는 문제가 있다.
* 인덱스에 포함되지 않은 컬럼에 대한 옵션 조건은 어차피 테이블에서 필터링할 수 밖에 없으므로 그럴 때에는 위와같은 방식을 사용해도 무방하다.
* 따라서 OR 조건을 활용한 옵션 조건 처리는 아래를 고려해야 한다.
  * 인덱스 액세스 조건으로 사용 불가
  * 인덱스 필터 조건으로 사용 불가
  * 테이블 필터 조건으로만 사용 가능
  * 인덱스 구성 컬럼 중 하나 이상이 Not Null 컬럼이면 18c부터 인덱스 필터조건으로 사용 가능
* 이런 특성을 항상 고려할 수 있는게 아니라면, OR 조건을 이용한 옵션 조건 처리는 가급적 사용하지 않아야 한다.
  * 이방식의 유일한 장점은 옵션 조건 컬럼이 NULL 허용 컬럼이어도 결과 짛밥을 보장한다는 것이다.

#### LIKE/BETWEEN 조건 활용
* 필수조건의 변별력이 좋은 경우엔 이런 패턴을 사용하는것도 나쁘지 않다.
  ```oracle
  -- 인덱스 : 등록일시 + 상품분류코드
  select * from 상품
  where 등록일시 >= trunc(sysdate)             -- 필수 조건
      and 상품분류코드 like :prd_cls_cd || '%'  -- 옵션 조건
  ```
  * 또한 필수 조건이 `=` 이면 옵션조건까지도 인덱스 액세스 조건이므로 최적의 성능을 낼 수 있다.

* 아래 예시와 같이, 필수조건의 변별력이 좋지 않을 때에는 문제가 된다.
  ```oracle
  -- 인덱스 : 상품대분류코드 + 상품코드
  select * from 상품
  where 상품대분류코드 = :prd_lcls_cd    -- 필수 조건
      and 상품코드 like :prd_cd || '%' -- 옵션조건
  ```
  * 상품 대분류 코드만으로 조회할 때에는 Table Full Scan이 유리하지만, 옵티마이저가 상품코드까지 입력할 때를 기준으로 Index Range Scan을 선택한다.
* 따라서 LIKE/BETWEEN 조건을 활용한 옵션 조건 처리는 아래를 고려해야 한다.
  * 인덱스 선두 컬럼인지
    * 인덱스 선두컬럼인 경우, 모든 데이터를 스캔하는 일이 생김
  * NULL 허용 컬럼인지
    * NULL 허용컬럼인데 실제 NULL 값이 입력되어 있다면 그 데이터는 결과집합에서 누락된다. (BETWEEN도 같음)
  * 숫자형 컬럼인지
    * 자동형변환이 일어나 필터조건으로 사용될 수 있다.
  * 가변 길이 컬럼인지
    * 가변컬럼이면 길이가 다른 값이 같이 조회되어버릴 수 있다.

#### UNION ALL 활용
```oracle
-- 인덱스 : 고객ID + 거래일자
select * from 거래
where :cust_id is null
    and 거래일자 between :dt1 and :dt2
union all
select * from 거래
where :cust_id is not null
    and 거래일자 between :dt1 and :dt2
```
* 위 쿼리는 `:cust_id` 변수에 값에 입력을 하던 안하던 인덱스를 최적으로 활용한다.
* 이 방식은 옵션 조건 컬럼도 인덱스 액세스 조건으로 사용한다.
* 또한 고객ID가 NULL 허용 컬럼이어도 사용하는데 문제가 없다.
* 유일한 단점은 SQL 코딩량이 길어진다는 점이다.

#### NVL/DECODE 함수 활용
```oracle
select * from 거래
where 고객ID = nvl(:cust_id, 고객ID)
and 거래일자 between :dt1 and :dt2

select * from 거래
where 고객ID = decode(:cust_id, null, 고객ID, :cust_id)
  and 거래일자 between :dt1 and :dt2
```
* 고객 ID컬럼을 함수 인자로 사용했는데도 인덱스를 사용할 수 있는 것은 OR Expansion 쿼리변환이 일어났기 때문이다. (UNION ALL 방식으로 변환)
  * 이 기능이 작동하지 않으면 액세스조건으로 사용 불가능하다.
  * 고객ID = 고객ID 형태가 되기 때문에 인덱스에서 이 조건을 만족하는 한 시작점을 찾을 수 없다.
* 이 방식의 큰 장점은 옵션 조건 컬럼을 인덱스 액세스 조건으로 사용할 수 있다는 점이다.
* UNION ALL 보다 단순하면서도 같은 성능을 낼 수 있다.
* 옵션 조건 처리용 NVL/DECODE 함수를 여러개 사용하면 그중 변별력이 가장 좋은 컬럼 기준으로 한 번만 OR Expansion이 일어난다.
  * OR Expansion 기준으로 선택되지 않으면 인덱스 구성컬럼이어도 모두 필터 조건으로 처리된다.
* 즉, NVL/DECODE 함수의 장점에도 불구하고 모든 옵션 조건을 이 방식으로 처리할 수 없다.

> Dynamic SQL
> * Dynamic SQL을 이용해 조건절을 동적으로 구성할 수 있는 환경에서는 위와같은 내용에 대해 공감을 하지 못할 수 있다.
> * Dynamic SQL을 이용해 `=` 연산자를 활용할 경우 변별력있는 컬럼을 액세스 조건으로 사용할 수 있게 인덱스만 잘 구성해주면 된다.
> * 하지만 힌트로 액세스 경로를 고정하려고 할 때 위와같은 튜닝 기법을 적절히 활용해야 한다.
> * Dynamic SQL에 힌트를 명시하면 동적으로 구성된 조건절과 서로 상충하여 성능 문제를 야기할 수 있다.
> * Dynamic SQL을 허용하지 않는 시스템도 있다.(금융권)

### 함수호출부하 해소를 위한 인덱스 구성
#### PL/SQL 함수의 성능적 특성
* PL/SQL 사용자 정의 함수는 생각보다 매우 느리다.
* PL/SQL 사용자 정의 함수가 느린 이유가 있다.
  * 가상머신상에서 실행되는 인터프리터 언어
  * 호출 시마다 컨텍스트 스위칭 발생
  * 내장 SQL에 대한 Recursive Call 발생
* 오라클은 오라클 서버가 아닌 Oracle Form, Oracle Reports 같은 제품에서도 수행될 수 있도록 PL/SQL을 설계하였다.
* 따라서 PL/SQL로 작성한 함수와 프로시저를 컴파일하면 JAVA 언어처럼 바이트코드를 생성해 데이터 딕셔너리에 저장하며, 이를 해석할 수 있는 PL/SQL 엔진만 있으면 어디서든 실행할 수 있다.
  * 바이트 코드를 런타임 시 해석하면서 실행한다.
* 결국 PL/SQL도 인터프리터 언이이기 때문에 Native 코드로 완전 컴파일된 내장 함수에 비해 많이 느리다.
* PL/SQL 함수는 실행 시 SQL 실행엔진과 PL/SQL 가상머신 사이에 컨텍스트 스위칭이 일어난다.
* 따라서 PL/SQL 함수를 작은단위로 모듈화, 공용화하면 안된다.
* PL/SQL 사용자 정의 함수의 성능을 떨어뜨리는 가장 결정적인 요소는 Recursive Call이다.
  ```oracle
  select 회우너번호, 회원명, GET_ADDR(우편번호) as 기본주소
  from 회원
  where 생월일 like '01%'
  ```
  * 조건을 만족하는 회원이 100만명이면 GET_ADDR도 100만번 실행하고, SQL이 내장되어있다면 SQL도 100만번 실행하게 된다.


#### 효과적인 인덱스 구성을 통한 함수 호출 최소화
```oracle
select /*+ full(a) */ 회원번호, 회원명, 생년, 생월일
from 회원 a
where 생년 = '1994' 
    and 암호화된전화번호 = encryption( :phone_no )
```
* 위와 같이 다른 조건절이 있으면, encryption 함수는 그 조건절을 만족하는 만큼만 수행된다.

1. `create index 회원_X01 on 회원(생년);`
   * encryption 함수는 생년 조건을 만족하는 건수만큼 수행된다.
2. `create index 회원_X02 on 회원(생년, 생월일);`
   * encryption 함수는 생년 조건을 만족하는 건수만큼 수행된다.
3. `create index 회원_X03 on 회원(생년, 암호화된전화번호);`
   * encryption 함수는 단 한번만 수행된다.
   * 생년과 함께 암호화된전화번호도 인덱스 액세스 조건으로 사용되기 때문이다.

## 인덱스 설계
* OLTP 시스템에서 인덱스 설계는 매우 중요하다.

### 인덱스 설계가 어려운 이유
* SQL 각각에 최적화된 인덱스를 계속 생성할 수 있다면 SQL튜닝과 인덱스 설계는 매우 쉬운일이 된다.
* 하지만 이렇게 인덱스를 생성하다보면 테이블마다 인덱스가 수십 개씩 달리게 되며, 관리비용 뿐만 아니라 시스템 부하를 증가시키게 된다.
* 인덱스가 많을 경우 아래와같은 문제가 생긴다.
  * DML 성능 저하 (TPS 저하)
  * 데이터베이스 사이즈 증가 (디스크 공간 낭비)
  * 데이터베이스 관리 및 운영 비용 상승
* 인덱스가 여러개 있는 경우, 신규 데이터를 입력할 때마다 여러 인덱스에도 데이터를 입력해야 한다.
  * 테이블과 달리 정렬상태를 유지하기 때문에, 수직적 탐색을 통해 입력할 블록을 찾아야 한다.
  * 찾은 블록에 여유 공간이 없다면 인덱스 분할(Index split)도 발생한다.
* 데이터를 지울 때에도 여러 인덱스에서 일일이 찾아 지워줘야 한다.
* 따라서 개별 쿼리성능 뿐만 아니라, 그 개수를 최소화해야 하므로 인덱스 설계는 어렵다.

> 개발단계에서의 인덱스 설계
> * 운영환경이 되는 순간 인덱스를 변경하는건 쉽지 않다.
> * 그나마 신규 인덱스 추가는 변경 영향도가 작지만, 그럴수록 시스템 수준 TPS는 나빠질 수 밖에 없다.
> * 따라서 개발단계에서 인덱스를 정교하게 설계해야 한다.

### 가장 중요한 두 가지 선택 기준
1. 조건절에 항상 사용하거나 자주 사용하는 컬럼을 선정해야 한다.
2. 이렇게 선정한 컬럼 중 `=`조건으로 자주 조회하는 컬럼을 앞 쪽에 두어야 한다.
* 위 두 선택 기준은 인덱스 스캔 효율성이 판단 기준이다.

### 스캔 효율성 이외의 판단 기준
* 가장 중요한 두 가지 선택 기준만으로 설계를 하다보면, 오히려 인덱스 개수만 더 늘어나는 현상이 발생할 수 있다.
* 즉, 인덱스 스캔 효율성 외 고려해야 할 판단 기준들이 있다.
  * 수행 빈도
  * 업무상 중요도
  * 클러스터링 팩터
  * 데이터량
  * DML 부하
  * 저장 공간
  * 인덱스 관리 비용 등
* 이러한 다양한 판단 기준에 대한 해석이 서로 다르기 때문에, 설계자의 성향이나 스타일에 따라 결과물도 많이 달라진다.

#### 수행빈도
* 여러 판단 기준 중 가장 중요한 하나를 꼽자면 바로 수행빈도이다.
  * 자주 수행하지 않는 SQL이면 인덱스 스캔 과정에 약간의 비효율은 있어도 큰 문제가 안될 수 있기 때문이다.
* 수행빈도가 가장 높은 SQL에는 최적의 인덱스를 구성해줘야 한다.
* NL 조인할 때 어느 쪽에서 자주 액세스되는지도 중요한 판단 기준이 된다.
* NL 조인할 때, Outer쪽에서 액세스하는 인덱스는 스캔과정에 비효율이 있더라도 큰 문제가 아닐 수 있다.
* 하지만 NL 조인에서 Inner 쪽 인덱스 스캔 과정에 비효율이 있다면, 이것은 성능에 큰 문제를 야기할 수 있다.
* 수행빈도가 매우 높은 SQL이라면, 테스트 과정에 성능이 좋게 나오더라도 인덱스를 최적으로 구성해줘야 한다.
* NL조인 Inner 쪽 인덱스는 `=` 조건 컬럼을 선두에 두는것이 중요하고, 될 수 있으면 테이블 액세스 없이 인덱스에서 필터링을 마치도록 구성해야 한다.

#### 데이터량
* 데이터량이 적다면 굳이 인덱스를 많이 만들 필요가 없으며, Full Scan으로도 충분히 빠르다
  * 또한 인덱스를 많이 만들어도 저장 공간이나 트랜잭션 부하 측면에서 그다지 문제될 것이 없다.
  * 즉, 테이블이 작으면 심각하게 고민할 필요가 없다.
* 하지만 초대용량 테이블은 인덱스 설계가 매우 중요하다.
  * 초당 DML 발생량은 TPS에 직접적인 영향을 준다.
  * 인덱스를 하나라도 줄였을 때 그것이 시스템에 미치는 영향은 적지 않다.

### 공식을 초월한 전략적 설계
* SQL 튜닝 전문가라면 가장 핵심적인 액세스 경로 한 두개를 전략적으로 선택해 최적 인덱스를 설계하고, 나머지 액세스 경로는 약간의 비효율이 있더라도 목표 성능을 만족하는 수준으로 인덱스를 구성할 줄 알아야 한다.
* 왜 그렇게 설계를 했는지 근거가 무엇인지 답할 수 있어야 하며, 업무 상황을 이해하고 나름의 판단 기준을 가지고 결정을 내려야 한다.

#### 가계약 테이블 예시
* 이 예시는 인덱스 설계 시, 일자/일시 조건을 선두에 두고 자주 사용하는 필터 조건을 뒤쪽에 추가한다.
  * 일자 조회 구간이 길지 않으면 인덱스 스캔 비효율이 성능에 미치는 영향이 크지 않다.
  * 인덱스 스캔 효율보다 테이블 액세스가 더 큰 부하 요소이다.
    * 가계약은 보통 최근 데이터만 조회하므로, 인덱스 스캔량이 그리 많지 않다.
* 또한, 추가로 가장 많이 사용하는 패턴에 최적의 스캔 효율을 제공하는 인덱스를 추가한다.   

### 소트 연산을 생략하기 위한 컬럼 추가
* 조건절에 사용하지 않는 컬럼이더라도 소트 연산을 생략할 목적으로 인덱스 구성에 포함시킴으로써 성능 개선을 할 수 있다.
```oracle
select 계약ID, 청약일자, 입력자ID, 계약상태코드, 보험시작일자, 보험종료일자
from 계약
where 취급지점ID = :trt_brch_id
  and 청약일자 between :sbcp_dt1 and :sbcp_dt2
  and 입력일자 >= trunc(sysdate - 3)
  and 계약상태코드 in (:crt_stat_cd1, :crt_stat_cd2, :crt_stat_cd3)
order by 청약일자, 입력자ID
```
* 위 예시에서 성능을 고려하지 않고 소트연산을 생략하려고 하면 `[청약일자 + 입력자ID]`로 인덱스를 구성하면 된다.
* `=`조건절 컬럼은 ORDER BY 절에 없더라도 인덱스 구성에 포함할 수 있다.
  * `[청약일자 + 취급지점ID + 입력자ID]` 순으로 구성해도 소트연산을 생략할 수 있다. (앞뒤 중간 어디에 두어도 상관 없음)  
* `=`이 아닌 조건절들은 반드시 ORDER BY 컬럼보다 뒤쪽에 두어야 소트연산을 생략할 수 있다.
* I/O를 최소화하면서 소트 연산을 생략하려면 아래와 같은 공식으로 인덱스를 구성하면 된다.
  * `=` 연산자로 사용한 조건절 컬럼 선정
  * ORDER BY 절에 기술한 컬럼 추가
  * `=` 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정
* 따라서 인덱스를 `[취급지점ID + 청약일자 + 입력자ID]` 순으로 구성하면 된다.

#### IN 조건은 `=`이 아니다.
```oracle
-- 인덱스 : 거주지역 + 혈액형 + 연령
select 고객번호, 고객명, 거주지역, 혈액형, 연령
from 고객
where 거주지역 = '서울'
  and 혈액형 in ('A', 'O')
order by 연령
```
* IN 조건이 `=`이 되려면 IN-List Iterator 방식으로 풀려야 한다.
* 그러면 IN 조건이 `=`이 되었지만 UNION ALL 위아래 두 집합을 묶어 연령 순으로 정렬하는 문제가 남게 된다.
* 따라서 소트연산을 생략하려면 IN 조건절이 IN-List Iterator 방식으로 풀려선 안된다.
* 즉, 위 예시는 `[거주지역 + 연령 + 혈액형]`이 되어야 한다.

### 결합 인덱스 선택도
* 인덱스 생성 여부를 결정할 때, 선택도가 충분히 낮은지가 중요한 판단 기준이다.
* 선택도가 높은 인덱스는 생성해봐야 효용가치가 별로 없다.
  * 테이블액세스가 많이 발생하기 때문이다.

#### 컬럼 순서 결정 시 선택도
* 인덱스 생성 여부를 결정할 때 선택도가 매우 중요하지만, 결합인덱스의 컬럼간 순서를 결정할 때 각 컬럼의 선택도보다는 필수조건의 여부나 연산자의 형태가 더 중요하다
  * 모두 `=` 조건이라면 선택도가 낮은 컬럼이 앞에 오든 뒤에오든 효율에 영향이 없다. 

### 중복 인덱스 제거
* 아래 3개의 인덱스는 완전 중복이므로, 위 2개의 인덱스는 모두 지워도 된다.
  * `[계약ID + 청약일자]`
  * `[계약ID + 청약일자 + 보험개시일자]`
  * `[계약ID + 청약일자 + 보험개시일자 + 보험종료일자]`
  

* 아래 4개의 인덱스는 얼핏 보기엔            중복은 아니다.
  * `[계약ID + 청약일자]`
  * `[계약ID + 보험개시일자]`
  * `[계약ID + 보험종료일자]`
  * `[계약ID + 데이터생성일시]`
* 하지만 계약ID의 카디널리스트가 매우 낮으면 사실상 중복이다. 
  * `[계약ID + 청약일자 + 보험개시일자 + 보험종료일자 + 데이터생성일시]` 와 같이 하나만 만들어도 충분하다.

#### 중복인덱스 실습예시
* p245 ~ p249 참고

### 인덱스 설계도 작성
* 인덱스 설계 시 시스템 전체 효율을 고려해야 한다.
* 따라서 인덱스 설계에도 설계도면이 필요하다.
* p249 참고

# 조인 튜닝
## NL 조인
### 기본 메커니즘
* NL조인은 말그대로 중첩 루프문과 같은 수행구조를 사용한다.
* 일반적으로 NL 조인은 Outer와 Inner 양쪽 테이블 모두 인덱스를 이용한다.
* Outer쪽 테이블은 사이즈가 크지 않으면 인덱스를 이용하지 않을 수 있다.
  * Table Full Scan 하더라도 한번에 그치기 때문이다.
* 반면에, Inner쪽 테이블은 인덱스를 사용해야 한다.
  * Inner 루프에서 인덱스를 이용하지 않으면 Outer 루프에서 읽은 건수만큼 Table Full Scan을 반복하기 때문이다.
* 따라서 NL조인은 인덱스를 이용한 조인 방식이라고 할 수 있다.
* 소트 머지 조인과 해시 조인도 가공해둔 데이터를 이용한다는 점만 다를 뿐 기본적인 프로세싱은 다르지 않다.

### NL 조인 실행계획 제어
* NL조인은 각 테이블을 액세스할 때 인덱스를 이용한다.
* NL조인을 제어할 때에는 `use_nl` 힌트를 사용하면 된다.
  * `ordered` 힌트는 FROM절에 기술한 순서대로 조인하라고 지시할 때 사용한다.

* 아래는 A, B, C, D순으로 조인하되 B, C와조인할때는 NL 방식으로 조인하고, D와 조인할 때는 해시 방식으로 조인하라는 뜻이다.
  ```oracle
  select /*+ ordered use_nl(B) use_nl(C) use_hash(D) */
  from A, B, C, D
  where ...
  ```
  
* `ordered` 대신 `leading` 힌트를 사용할 수도 있다.
  ```oracle
  select /*+ leading(C, A, D, B) use_nl(A) use_nl(D) use_hash(B) */
  from A, B, C, D
  where ...
  ```

* 네 개의 테이블을 NL방식으로 조인하되 순서는 옵티마이저가 정하도록 맡긴 것이다.
  ```oracle
  select /*+ ordered use_nl(A, B, C, D) */
  from A, B, C, D
  where ...
  ```

### Nl 조인 수행 과정 분석
```oracle
select /*+ ordered use_nl(c) index(e) index(c) */
       e.사원번호, e.사원명, e.입사일자
     , c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사원번호 = e.사원번호
  and e.입사일자 >= '19960101'
  and e.부서코드  = 'Z123'
  and c.최종주문금액 >= 20000
```
* 인덱스 구성
  * `[사원_PK : 사원번호]`
  * `[사원_X1 : 입사일자]`
  * `[고객_PK : 고객번호]`
  * `[고객_X1 : 관리사원번호]`
  * `[고객_X2 : 최중주문금액]`
* 사용되는 인덱스는 사원_X1, 고객_X1이다.
* p263 그림 참고


### NL 조인 튜닝 포인트
* 위 예시의 NL조인 튜닝포인트들이 있다.
* 튜닝포인트 1
  * 사원_X1 인덱스를 읽고 나서 테이블을 액세스 하는 부분이다.
  * 사원테이블이 아주 많은 양의 랜덤액세스가 발생할 경우 테이블에서 부서코드에 의해 필터링되는 비율이 높을 수 있다.
  * 인덱스에서 부서코드 컬럼을 추가하는 방안을 고려해야 한다.
* 튜닝포인트 2
  * 고객_X1 인덱스 탐색 부분이다.
  * 조인 액세스 횟수는 Outer 테이블을 읽고 필터링한 결과 건수에 의해 결정된다.
  * 예시로, 부서코드까지 만족하는 레코드가 10만건이고, 고객_X1의 인덱스 Depth가 3이라면 수직적 탐색 과정에서만 30만개 블록을 읽어야 하며, 수평적 스캔 과정에 추가적인 블록 I/O가 생긴다.
* 튜닝포인트 3
  * 고객_X1 인덱스를 읽고 고객 테이블을 액세스하는 부분이다.
  * 최종주문금액 조건에 의해 필터링되는 비율이 높다면 고객_X1 인덱스에 최종주문금액 컬럼을 추가하는 방안을 고려해야 한다.
* 튜닝포인트 4
  * 맨 처음 액세스하는 사원_X1 인덱스에서 얻은 결과 건수에 의해 전체 일량이 좌우된다.
  * 따라서, 사원_X1 인덱스를 스캔하면서 추출한 레코드가 많으면, 사원 테이블로 랜덤액세스하는 횟수, 고객_X1 인덱스를 탐색하는 횟수, 고객테이블로 랜덤액세스하는 횟수가 많아질 수 밖에 없다.

#### 올바른 조인 메소드 선택
* OLTP 시스템에서 튜닝할 때는 일차적으로 NL조인부터 고려하는것이 올바른 순서이다.
* 성능이 느리다면 위 튜닝포인트에 따라 각 단계의 수행 일량을 분석해서 과도한 랜덤액세스가 발생하는 지점을 우선 파악해야 한다.
  * 조인순서를 변경해 랜덤액세스 발생량을 줄일 수 있는지, 더 효과적인 다른 인덱스가 있는지 등을 검토해야 하며, 인덱스 추가 및 구성 변경도 고려해본다.
* 여러 방안을 검토 후, NL 조인으로 결코 좋은 성능을 내기 어렵다고 판단되면, 소트머지 조인이나 해시조인을 검토한다.

### NL 조인 특징 요약
1. 랜덤 액세스 위주의 조인 방식이다.
   * 대량 데이터 처리 시 매우 치명적인 한계가 있다.
2. 조인을 한 레코드씩 순차적으로 진행한다.
   * 아무리 큰 테이블을 조인하더라도 매우 빠른 응답속도를 낼 수 있다.
   * 부분범위처리가 가능한 상황에서 더더욱 그렇다.
3. 다른 조인방식과 비교할 때 인덱스 구성 전략이 특히 중요하다.
   * 인덱스에 따라 조인 효율이 크게 달라진다.
* 따라서 NL 조인은 소량 데이터를 주로 처리하거나, 부분범위 처리가 가능한 시스템에 적합한 조인방식이다. (주로 OLTP)

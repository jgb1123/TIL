# SQL 처리과정과 I/O
## SQL 파싱과 최적화
### SQL?
* SQL은 Structured Query Language 의 줄임말이다.
* SQL은 깁노적으로 구조적(structured)이고, 집합적(set-based)이고, 선언적(declarative)인 질의 언어이다.
* 원하는 결과 집합을 구조적, 집합적으로 선언하지만 그 결과 집합을 만드는 과정은 절차적일 수 밖에 없다.
* 결국 프로시저가 필요한데, 그 프로시저를 만들어내는 DBMS 내부 엔진이 바로 SQL 옵티마이저이다.
* DBMS 내에서 프로시저를 작성하고 컴파일해 실행 가능한 상태로 만드는 모든 과정을 SQL 최적화라고 한다.


### SQL 최적화 과정
1) SQL 파싱
   * 사용자로부터 SQL을 전달받으면, 가장 먼저 SQL 파서가 파싱을 진행한다.
   * 파싱 트리 생성 : SQL문을 이루는 개별 구성 요소를 분석해 파싱 트리를 생성한다.
   * Syntax 체크 : 문법적 오류가 없는지 확인한다.
   * Semantic 체크 : 의미상 오류가 없는지 확인한다.

2) SQL 최적화
   * SQL최적화는 옵티마이저가 진행한다.
   * 옵티마이저가 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 실행 경로를 생성해 비교한 후 가장 효울적인 하나를 선택한다.
3) 로우 소스 생성
   * SQL 옵티마이저가 선택한 실행 경로를 실행가능한 코드나 프로시저 형태로 포맷팅한다.
   * 로우 소스 생성기(Row-Source Generator)가 그 역할을 맡는다.

### SQL 옵티마이저
* SQL옵티마이저는 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 액세스 경로를 선택해주는 DBMS의 핵심 엔진이다.
1) 사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 찾아낸다.
2) 데이터 딕셔너리에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상 비용을 산정한다.
3) 최저 비용을 나타내는 실행 계획을 선택한다.

### 실행계획과 비용
* DBMS에 SQL 실행경로 미리 보기 기능이 있는데, 실행 계획(Execution Plan)이다.
* 이를 통해 자신이 작성한 SQL이 테이블을 스캔하는지, 인덱스를 스캔하는지, 인덱스를 스캔한다면 어떤 인덱스인지를 확인할 수 있으며, 예상과 다른 방식으로 처리되면 실행경로를 변경할 수 있다.
* SQL 실행계획에 표시되는 Cost도 예상치이며, 실행경로를 선택하기 위해 옵티마이저가 여러 통계 정보를 활용해 계산해낸 값이다.

### 옵티마이저 힌트
* 옵티마이저가 보통 좋은 선택을 하지만, 그 선택이 최선은 아니다.
* 옵티마이저 힌트를 이용해 데이터 액세스 경로를 바꿀 수 있다.
* 중요한 시스템이라면, 옵티마이저의 판단에 맡기긴 어렵지만, 힌트를 쓸거면 빈틈없이 써야 한다.
```oraclesqlplus
/*+ INDEX(T1 TEST_PK) */
```
#### 주의사항
* `--+ INDEX(A TEST_PK)`방식은 가급적 쓰지 말아야 한다.
* 인자를 나열할 땐 `,`를 사용할 수 있지만 힌트와 힌트 사이에 사용하면 안된다.
* 테이블을 지정할 때 스키마 명까지 명시하면 안된다.
* FROM절 옆에 ALIAS를 지정했으면 힌트에도 반드시 ALIAS를 사용해야 한다.

## SQL 공유 및 재사용
### 소프트 파싱 vs 하드 파싱
* SQL 파싱, 최적화, 로우소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복해서 재사용할 수 있도록 캐싱해두는 메모리 공간을 **라이브러리 캐시**라고 한다.
  * 라이브러리 캐시는 SGA의 구성 요소이다.
    > SGA(System Global Area)
    >* 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간
* 사용자가 SQL문을 전달하면 DBMS는 SQL을 파싱한 후 해당 SQL이 라이브러리 캐시에 존재하는지부터 확인한다.
* SQL을 캐시에서 찾아 바로 실행단계로 넘어가는것을 **소프트파싱** 이라고 한다.
* 찾는데 실패 해 최적화 및 로우 소스 생성 단계까지 모두 거치는것을 **하드파싱** 이라고 한다.
  * 하드파싱은 CPU를 많이 소비하는 몇 안되는 작업 중 하나이다.
  * 쿼리를 수행할 때, 후보군이 될만한 많은 실행경로를 도출하고, 딕셔너리와 통계정보를 읽어 각각의 효율성을 판단하는 과정은 결코 가볍지 않다.

### 바인드 변수의 중요성
#### 이름이 없는 SQL 문제
* 사용자 정의 함수/프로시저, 트리거, 패키지 등은 생성할 때 부터 이름을 갖기 때문에, 컴파일한 상태로 딕셔너리에 영구적으로 보관된다. 
* SQL은 이름이 따로 없고, 전체 텍스트가 이름 역할을 한다.
#### 공유 가능 SQL
* 바인드 변수를 사용하지 않으면, DBMS에서 발생하는 부하는 대개 I/O가 원인인데, I/O가 거의 발생하지 않음에도 CPU사용률은 급격히 올라갈 수 있다. (SQL 하드파싱 문제)
* 따라서 바인드 변수를 사용해 파라미터 Driven 방식으로 SQL을 작성하면 이러한 하드파싱 문제를 방지할 수 있다.

## 데이터 저장 구조 및 I/O 메커니즘
* I/O 튜닝이 곧 SQL 튜닝이라 해도 과언이 아니다.
* 즉 SQL튜닝 원래를 제대로 이해하려면 I/O에 대한 이해가 필수적이다.

### SQL이 느린 이유
* I/O는 잠 이라고 설명할 수 있다.
* I/O를 처리하는 동안 프로세스는 잠을 자기 때문이다.
* 프로세스가 잠을 자는 이유는 여러가지가 있지만, I/O가 가장 대표적이고 많은 비중을 차지한다.
* interrupt 없이 일하는 프로세스도 디스크에서 데이터를 읽어야 할 땐 CPU를 OS에 반환하고 waiting 상태에서 I/O가 완료되기를 기다린다.
  * CPU를 반환한 채 대기 큐에서 잠을 자는 것이다.
* 열심히 일해야 할 프로세스가 잠을 자게 되므로, I/O가 많으면 성능이 느릴 수 밖에 없다.
* SQL이 느린 이유는 여기에 있으며, 즉 디스크 I/O 때문이다.

### 데이터베이스 저장 구조
* 데이터를 저장하려면 **테이블 스페이스**를 생성해야 한다.
  * 테이플 스페이스는 세그먼트를 담는 콘테이너로, 여러 개의 데이터파일로 구성된다.
* 테이플스페이스를 생성했으면, **세그먼트**를 생성한다.
  * 세그먼트는 테이블, 인덱스 처럼 데이터 저장공간이 필요한 오브젝트이다.
    * 따라서 테이블, 인덱스를 생성할 때 데이터를 어떤 테이블 스페이스에 저장할지를 지정한다.
  * 파티션 구조가 아니라면 테이블도 하나의 세그먼트, 인덱스도 하나의 세그먼트이다.
  * 파티션구조라면 각 파티션이 하나의 세그먼트가 된다.
  * LOB컬럼은 그 자체가 하나의 세그먼트를 구성하므로 자신이 속한 테이블과 다른 공간에 값을 저장한다. (작은 LOB는 설정에 따라 in-row 저장 가능)
* 세그먼트는 여러 **익스텐트**로 구성된다.
  * 익스텐트는 공간을 확장하는 단위이다.
  * 테이블이나 인덱스에 데이터를 입력하다 공간이 부족해지면 오브젝트가 속한 테이블 스페이스로부터 익스텐트를 추가로 할당받는다.
  * 익스텐트는 연속된 블록들의 집합이기도 하다.
* 익스텐트 단위로 공간을 확장하지만, 레코드를 실제로 저장하는 공간은 **데이터 블록**이다.
  * 한 블록은 하나의 테이블이 독점한다.
  * 즉, 한 블록에 저장된 레코드는 같은 테이블 레코드이다.
  * 추가로, 한 익스텐트도 하나의 테이블이 독점한다.
  * 즉, 한 익스텐트에 담긴 블록은 모두 같은 테이블 블록이다. (MS-SQL은 한 익스텐트를 여러 오브젝트가 사용할 수도 있음)
* 세그먼트 공간이 부족해지면 테이블 스페이스로부터 익스텐트를 추가로 할당받지만, 세그먼트에 할당된 모든 익스텐트가 같은 데이터파일에 위치하지 않을 수도 있다.
  * 서로 다른 데이터 파일에 위치할 가능성이 더 높다.
  * 하나의 테이블스페이스를 여러 데이터파일로 구 성하면 파일 경합을 줄이기 위해 DBMS가 가능한 여러 데이터로 분산해 저장하기 때문이다.

#### DBA(Data Block Address)
* 데이터 블록은 디스크 상에서 몇 번 데이터 파일의 몇 번째 블록인지를 나타내는 고유 주소값(DBA)을 갖는다.
* 데이터를 읽으려면 DBA부터 확인해야 한다.
* 인덱스를 이용해 테이블 레코드를 읽을 때에는 인덱스 ROWID를 이용한다.
* ROWID 는 DBA + 로우 번호(블록 내 순번)으로 구성되므로, 이를 통해 읽어야 할 테이블 레코드가 저장된 DBA를 알 수 있다.
* 테이블 스캔 시에는 테이블 세그먼트 헤더에 저장된 익스텐트 맵을 이용한다.
* 익스텐트 맵을 통해 각 익스텐트의 첫 번쨰 블록 DBA를 알 수 있다.
* 즉, 익스텐트는 연속된 블록의 집합이므로 테이블을 스캔할 때에는 첫 번쨰 블록 뒤에서 연속해서 저장된 블록을 읽으면 된다.

### 블록 단위 I/O
* 데이터베이스에서 데이터를 읽고 쓰는 단위는 블록이다.
* 데이터 I/O 단위가 블록이므로, 특정 레코드를 하나 읽고 싶어도 해당 블록을 통째로 읽는다.
* 오라클은 기본적으로 8KB 크기의 블록을 사용한다. (1Byte를 읽기 위해 8KB를 읽는다)

### 시퀀셜 액세스 vs 랜덤 액세스
#### 시퀀셜 액세스
* 시퀀셜 액세스는 논리적또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식이다.
* 인덱스 리프 블록은 앞뒤를 가리키는 주소값을 통해 논리적으로 연결되어 있다.
  * 이 주소값에 따라 앞 또는 뒤로 순차적으로 스캔하는 방식이 시퀀셜 액세스이다.
* 테이블 블록 간에는 논리적인 연결고리를 갖고있지 않다.
  * 세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더에 맵으로 관리한다.
  * 이 익스텐트 맵은 첫 번째 블록 주소 값을 갖는다.
  * 따라서 읽어야 할 익스텐트 목록을 익스텐트 맵에서 얻고, 각 익스텐트의 첫 번째 블록 뒤에 연속해서 저장된 블록을 순서대로 읽으면, 바로 Full Table Scan이다.

#### 랜덤 액세스
* 랜덤 액세스는 논리적, 물리적 순서를 따르지 않고 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식이다.

### 논리적 I/O vs 물리적 I/O
#### DB 버퍼캐시
* SGA 구성요소로 라이브러리 캐시가 있는데, 데이터를 캐싱하는 DB 버퍼캐시도 SGA의 중요한 구성요소중 하나이다.
* 라이브러리 캐시가 SQL과 실행계획, DB 저장형 함수/프로시저 등을 캐싱하는 코드캐시라고 한다면, DB버퍼캐시는 데이터 캐시라고 할 수 있다.
* 디스크에서 읽은 데이터 블록을 캐싱해 같은 블록에 대한 반복적인 I/O Call을 줄이는데 목적이 있다.
* 서버 프로세스와 데이터 파일 사이에 버퍼 캐시가 있으므로, 데이터 블록을 읽을 때에는 항상 버퍼캐시부터 탐색한다.
  * 버퍼캐시는 공유메모리 영역이므로, 같은 블록을 읽는 다른 프로세스도 득을 본다.


#### 논리적 I/O vs 물리적 I/O
* 논리적 블록 I/O는 SQL을 처리하는 과정에 발생한 총 블록 I/O를 말한다.
* 물리적 블록 I/O는 디스크에서 발생한 총 블록 I/O를 말한다.
  * 읽어야 할 블록을 버퍼캐시에서 찾지 못할 때만 디스크를 액세스 하므로, 논리적블록 I/O의 일부가 물리적 I/O이다.
* 메모리 I/O는 전기적신호이지만, 디스크 I/O는 액세스 암을 통해 물리적 작용이 일어나므로 메모리 I/O에 비해 상당히 느리다. (보통 10000배 느림)
* Direct Path Read방식으로 읽는 경우를 제외하면, 모든 블록은 DB 버퍼캐시를 경유해서 읽는다.
* 즉, 일반적으로 논리적 I/O횟수는 DB버퍼캐시에서 블록을 읽은 횟수와 일치한다.
* DB버퍼캐시에서 블록을 찾지 못해 디스크에서 읽은 블록 I/O가 물리적 I/O이다.


#### 버퍼캐시 히트율
* 버퍼캐시 효율을 측정하는데 가장 많이 사용해 온 지표는 버퍼캐시 히트율(BCHR)이다.
 ```
BCHR = (캐시에서 찾은 블록 수 / 총 읽은 블록 수 ) * 100
     = ((논리적 I/O - 물리적 I/O) / 논리적 I/O) * 100
     = (1 - (물리적 I/O) / (논리적 I/O)) * 100
 ```
* 애플리케이션 특성에 따라 다르지만, 온라인 트랜잭션을 주로 처리하는 애플리케이션이라면 시스템 레벨에서 평균 99% 히트율을 달성해야 한다.
  * 핵심 트랜잭션이 시스템 전체 부하의 대부분을 차지하므로, 열심히 튜닝하면 99%는 달성하기 어려운 수치가 아니다.
* 논리적 I/O는 일정하므로, 물리적 I/O 는 버퍼캐시 히트율에 의해 결정된다.
* 결국 SQL 성능을 높이기 위해 할 수 있는 일은 논리적 I/O를 줄이는 일이다.
* 따라서 SQL을 튜닝해서 읽는 총 블록 수를 줄이면 된다.
* 논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 SQL 튜닝이다.
* 버퍼캐시 히트율이 SQL 성능을 좌우하지만, 높다고해서 효율적인 SQL을 의미하진 않는다.
  * 같은 블록을 반복해서 읽는 비효율적인 일이었을 수 있다.

### Single Block I/O vs Multiblock I/O
* 한 번에 한 블록씩 요청해서 메모리에 적재하는 방식을 Single Block I/O라고 한다.
* 한번에 여러 블록을 요청해서 메모리에 적재하는 방식을 Bultiblock I/O라고 한다.
* 인덱스를 이용할 때에는 기본적으로 인덱스와 테이블 블록 모두 Single Block I/O방식을 사용한다.
  * 인덱스 루트 블록을 읽을 때
  * 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
  * 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
  * 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
* 많은 데이터 블록을 읽을 때는 Multiblock I/O 방식이 효율적이다.
* Multiblock I/O는 캐시에서 찾지 못한 특정 블록을 읽으려고 디스크 상에 그 블록과 인접함 블록들을 한꺼번에 읽어 캐시에 미리 적재하는 기능이다.
* DBMS의 블록사이즈가 얼마건 간에 OS단에서는 일반적으로 1MB 단위로 I/O를 수행한다. (OS마다 다르다)
  * 오라클 I/O단위가 8KB이므로, db_file_multiblock_read_count를 128로 설정하면 최대가 된다. (8KB * 128)


### Table Full Scan vs Index Range Scan
* Table Full Scan은 테이블에 속한 블록 전체를 읽어 사용자가 원하는 데이터를 찾는 방식이다.
  * Table Full Scan은 시퀀셜 액세스와 Multiblock I/O 방식으로 디스크 블록을 읽는다.
* Index Range Scan은 인덱스에서 일정량을 스캔하면서 얻은 ROWID로 테이블 레코드를 찾아가는 방식이다.
  * Index Range Scan은 랜덤 액세스와 Single Block I/O방식으로 디스크 블록을 읽는다.
* Table Full Scan은 스토리지 스캔 성능이 좋아지는 만큼 성능도 좋아진다.
* Index Range Scan은 스토리지 성능이 많이 좋아져도 성능이 조금만 좋아진다.
* Table Full Scan을 피해야 한다는 인식과 달리 인덱스가 SQL성능을 떨어뜨리는 경우도 많다.
  * 한번에 많은 데이터를 처리하는 집계용 SQL과 배치프로그램이 그렇고, 이 경우엔 오히려 Full Scan으로 유도하면 성능이 좋아진다.
  * 물론 큰 테이블에서 소량의 데이터를 검색할 때에는 반드시 인덱스를 이용해야 한다.
* 인덱스는 굉장히 중요하긴 하지만, 항상 옳은 것은 아니므로 모든 성능문제를 인덱스로 해결하려고 하면 안된다.

### 캐시 탐색 메커니즘
* Direct Path I/O를 제외한 모든 블록 I/O는 메모리 버퍼캐시를 경유한다.
  * 인덱스 루트 블록을 읽을 때
  * 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
  * 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
  * 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
  * 테이블 블록을 Full Scan 할 때
* 버퍼 캐시에서 블록을 찾을 때 해시 알고리즘으로 버퍼 헤더를 찾고, 거기서 얻은 포인터로 버퍼 블록을 액세스하는 방식을 사용한다.
  * 같은 입력값은 항상 동일한 해시 체인에 연결됨
  * 다른 입력값이 동일한 해시 체인에 연결될 수 있음
  * 해시 체인 내에서는 정렬이 보장되지 않음
* 버퍼캐시에 캐싱된 버퍼블록은 모두 공유자원이기 때문에, 동시에 두 개 이상 프로세스가 접근하려고 할 때 정합성에 문제가 생길 수 있다.
* 따라서 한 프로세스씩 순차적으로 접근하도록 구현해야 하며, 이를 위한 직렬화 메커니즘이 필요한데, 이를 지원하는 메커니즘이 래치이다.
> 캐시버퍼 체인 래치
> * 대량의 데이터를 읽을 때 모든 블록에 대해 해시 체인을 탐색한다.
> * DBA를 해시 함수에 입력하고 반환된 값으로 스캔해야 할 해시 체인을 찾는다.
> * 해시체인에는 키를 획득한 프로세스만이 체인으로 진입할 수 있다.
* 버퍼캐시에는 캐시버퍼 체인 래치, 캐시버퍼 LRU 체인 래치 등이 작동한다.
* 캐시I/O도 생각보다 빠르지 않을 수 있는데, 이 래치에 의한 경합이 생길 수 있기 때문이다.
* 캐시버퍼 체인 뿐 아니라 버퍼블록 자체에도 버퍼 Lock이라는 직렬화 메커니즘이 존재한다.
* 따라서 이러한 직렬화 메커니즘에 의한 캐시 경합을 줄이려면 SQL튜닝을 통해 논리적 I/O 자체를 줄여야 한다.

> 버퍼 Lock
> * 래치를 해제한 상태로 버퍼 블록 데이터를 읽고 쓰는 경우 같은 블록에 접근할 수 있다.
> * 같은 블록에 접근해 데이터를 읽고 쓴다면 데이터 정합성에 문제가 생길 수 있다.
> * 이를 방지하기 위해 오라클은 버퍼 Lock을 사용한다.
> * 캐시버퍼 체인 래치를 해제하기 전 버퍼 헤더에 Lock을 설정함으로써 버퍼블록 자체에 대한 직렬화 문제를 해결한다.

# 인덱스 기본
## 인덱스 구조 및 탐색
### 미리보는 인덱스 튜닝
#### 데이터를 찾는 두 가지 방법
* 데이터베이스 테이블에서 데이터를 찾는 방법은 두가지 이다.
  * 테이블 전체를 스캔한다.
  * 인덱스를 이용한다.
#### 인덱스 튜닝의 두 가지 핵심 요소
* 인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용한다.
* 온라인 트랜잭션 처리 시스템에서는 소량 데이터를 주로 검색하므로, 인덱스 튜닝이 무엇보다 중요하다.
* 인덱스 튜닝 방법은 여러가지가 있지만, 크게 두 가지로 나뉜다.
  * 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것으로, 인덱스 스캔 효울화 튜닝이다.
  * 테이블 액세스 횟수를 줄이는 것으로, 랜덤 액세스 최소화 튜닝이다. (인덱스 스캔 후 레코드를 액세스할 때 랜덤 I/O 방식 사용)
* 인덱스 스캔 효울화 튜닝과 랜덤 액세스 최소화 튜닝 모두 중요하지만, 랜덤 액세스 최소화 튜닝이 성능에 미치는 영향이 더 크다.
* 즉, SQL 튜닝은 랜덤 I/O가 가장 중요하다.

#### SQL 튜닝은 랜덤 I/O와의 전쟁
* 성능을 위해 DBMS가 제공하는 많은 기능은 느린 랜덤 I/O를 극복하기 위해 개발되었다.
  * IOT, 클러스터, 파티션, 테이블 Prefetch, Batch I/O 등
* 조인 메서드 중 가장 일방적으로 사용하는 NL조인이 대량 데이터 조인할 때 느린 이유도 랜덤 I/O 때문이다.
  * 그래서 소트머지 조인과 해시 조인이 개발되었다.

### 인덱스 구조
* 인덱스는 대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 액세스하기 위해 사용하는 오브젝트이다.
* 데이터베이스에서 인덱스 없이 데이터를 검색하려면 테이블을 처음부터 끝까지 읽어야 하지만, 인덱스를 이용해 일부만 읽고 멈출 수 있다.
  * 즉 범위스캔이 가능하며, 범위스캔이 가능한 이유는 인덱스가 정렬되어있기 때문이다.
* DBMS는 일반적으로 B-Tree 인덱스를 사용한다.
  * 루트와 브랜치 블록에는 키 값을 갖지 않는 특별한 레코드가 하나 있는데, 첫 번째 레코드이며, LMC(Leftmost Child)라고 한다.
  * LMC는 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다.
  * LMC가 기리키는 주소로 찾아간 블록에는, 키값을 가진 첫 번째 레코ㅓ드보다 작거나 같은 레코드가 저장되어있다.
  * 리프블록에 저장된 레코드는 키값 순으로 정렬되어있을 뿐만 아니라, 테이블 레코드를 가리키는 주소값인 ROWID를 갖는다.
* 인덱스 키값이 같으면 ROW_ID 순으로 정렬된다.
* 인덱스를 스캔하는 이유는 검색조건에 맞는 소량의 데이터를 빨리 찾아 ROWID를 얻기 위함이다.
  * ROWID = 데이터 블록 주소 + 로우번호
  * 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
  * 블록 번호 : 데이터파일 내에서 부여한 상대적 순번
  * 로우 번호 : 블록 내 순번
* 인덱스 탐색 과적은 수직적 탐색과 수평적 탐색으로 나눌 수 있다.
  * 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정
  * 수평적 탐색 : 데이터를 찾는 과정

### 인덱스 수직적 탐색 
* 정렬된 인덱스 레코드 중, 조건을 만족하는 첫 번째 레코드를 찾는 과정으로, 인덱스 스캔 시작 지점을 찾는 과정이다.
* 인덱스 수직적 탐색은 루트블록에서부터 시작한다.
* 루트를 포함해 브랜치 블록에 저장된 각 인덱스 레코드는 하위 블록에 대한 주소값을 갖는다.
* 루트에서 시작해 리프블록까지 수직적으로 탐색이 가능한 이유다.
* 찾고자 하는 값보다 크거나 같은 값을 만나면 직전 레코드가 가리키는 하위 블록으로 이동한다.
* 수직적 탐색은 레코드를 찾는 과정이 아니라, **조건을 만족하는 첫 번째 레코드를 찾는 과정**이다.

### 인덱스 수평적 탐색
* 수직적 탐색을 통해 스캔 시작점을 찾은 후, 찾고자 하는 데이터가 더 안나타날 때까지 인덱스 리프 블록을 수평적으로 스캔한다.
* 즉, 인덱스에서 본격적으로 데이터를 찾는 과정이다.
* 인덱스 리프 블록끼리는 서로 앞뒤 블록에 대한 주소값을 갖고 있는 양방향 연결 리스트 구조이다.
  * 좌에서 우, 우에서 좌로 수평적 탐색이 가능하다.
* 인덱스를 수평적 탐색하는 이유는 조건절을 만족하는 데이터를 모두 찾고, ROWID를 얻기 위해서이다.
  * 일반적으로는 인덱스를 스캔하고 테이블도 액세스 하는데, 이 때 ROWID가 필요하다.

### 결합 인덱스 구조와 탐색
* 두 개 이상 컬럼을 결합해 인덱스를 만들 수 있다.
* 인덱스를 고객명 + 성별로 하던, 성별 + 고객명으로 하던 읽는 인덱스 블록 개수는 똑같다.
* 인덱스 선두 컬럼을 모두 `=` 조건으로 검색할 때에는 어느 컬럼을 앞쪽에 두든 블록 I/O 개수가 같으므로 성능도 같다.
  * 선택도가 낮은 컬럼을 앞쪽에 둬야 성능에 유리하다는 말은 잘못되었다.
  * `=`조건이 아니라 다른 조건들이 섞여있으면 컬럼 순서의 영향이 있다.

> Balanced
> * B-Tree에서의 B는 Balanced의 약자로, 어떤 값으로 탐색하더라도 인덱스 루트에서 리프까지 도달하기 위해 읽는 블록 수는 같다.

## 인덱스 기본 사용법
### 인덱스를 사용한다는 것
* 인덱스 컬럼을 가공하지 않아야 인덱스를 정상적으로 사용할 수 있다.
* 인덱스를 정상적으로 사용한다는 표현은 리프블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 멈추는걸 의미하며, 리프 블록 일부만 스캔하는 Index Range Scan을 의미한다.
* 인덱스 컬럼을 가공해도 인덱스를 사용할 순 있지만, 스캔 시작점을 찾을 수 없고 멈출 수 없어 리프블록 전체를 스캔해야 하므로, Index Full Scan방식으로 동작하게 된다.

### 인덱스를 Range Scan 할 수 없는 이유
* 인덱스 컬럼을 가공했을 때 인덱스를 정상적으로 사용할 수 없는 이유는, 인덱스 스캔 시작점을 찾을 수 없기 때문이다.
  * 일정 범위를 스캔하려면 시작 지점과 끝 지점이 있어야 한다.
* 인덱스에는 가공되지 않은 생년월일 값이 저장되어 있는데, 가공된 값을 기준으로 검색을 하려면 스캔 시작점과 끝지점을 찾을 수 없다.
  * `where substr(생년월일, 5, 2) = '05'`
* 값이 NULL이면 0으로 치환한 값 기준으로 100보다 작은 레코드를 찾아달라고 하면 인덱스 스캔 시작지점을 알 수가 없다.
  * `where nvl(주문수량, 0) < 100`
* 대한으로 시작하는 값은 특정 구간에 몰려있겠지만, 대한을 포함하는 값은 전체 구간에 흩어져 있어 Range Scan이 불가능하다.
  * `where 업체명 like '%대한%'`
* 전화번호가 01012341234 이거나 고객명이 홍길동인 한 시작점을 찾을 수 없기 떄문에 Range Scan이 불가능하다. 
  * `where (전화번호 = :tel_no OR 고객명 = :cust_nm'`

> OR Expansion
> * 아래 쿼리와 같이 변경하면 고객명, 전화번호 인덱스에 대해 Index Range Scan이 가능하다.
> * OR조건식을 SQL옵티마이저가 위와 같은 형태로 변환할 수 있는데, 이것을 OR Expansion이라고 한다.
> * ```
>   select *
>   from 고객
>   where 고객명 = :cust_nm
>   union all
>   select *
>   from 고객
>   where 전화번호 = :tel_no
>   and (고객명 <> :cust_nm or 고객명 is null)
>   ```
> * `use_concat` 힌트를 이용해 OR Expansion을 유도할 수 있다.

* IN 조건 또한 한 지점을 찾을 수 없다.
  * `where 전화번호 in (:tel_no1, :tel_no2)`
  * IN 조건 또한 UNION ALL 방식으로 작성하면 인덱스 스캔 시작점을 찾을 수 있다.
  * 그래서 IN 조건절에 대해서는 SQL 옵티마이저가 IN-List Iterator 방식을 사용한다.
  > IN-List Iterator
  > * List 개수만큼 Index Range Scan 반복한다.

### 더 중요한 인덱스 사용 조건
* 인덱스를 정상적으로 사용하는 데 있어 중요한 선행조건이 있다.
* 인덱스 Range Scan을 하기 위해선 인덱스 선두 컬럼이 조건절에 있어야 한다. 또한 가공하지 않은 상태여야 한다.
* 인덱스를 잘 탄다고 해도, 스캔 범위를 줄이는데 전혀 역할을 하지 못할 수 있다.

### 인덱스를 이용한 소트 연산 생략
* 테이블과 달리 인덱스는 정렬되어 있다.
* PK 인덱스를 스캔하면서 출력한 집합은 어차피 PK 순으로 정렬되기 때문에 ORDER BY가 있어도 연산을 따로 수행하지 않는다.
* 또한 DESCENDING 정렬에도 인덱스를 활용할 수 있다.
  * 인덱스 리프 블록은 양방향 연결 리스트 구조이기 때문이다.
* 따라서 ORDER BY 절에서 DESC정렬을 요구해도, ORDER BY 연산을 하지 않고, `INDEX (RAGE SCAN DESCENDING)`과 같이 인덱스를 사용한다.

### ORDER BY 절에서 컬럼 가공
* 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다는 말은 대개 조건절에 사용한 컬럼을 의미한다.
* 그런데 조건절이 아닌 ORDER BY 또는 SELECT-LIST에서 컬럼을 가공함으로 인해 인덱스를 정상적으로 사용할 수 없는 경우도 있다.
* 아래 예시는 주문_PK 인덱스는 주문일자 + 주문번호 순으로 구성되어 있는 경우에도 ORDER BY 연산을 하게 된다. 
```oracle
SELECT *
FROM (
    SELECT TO_CHAR(A.주문번호, 'FM000000') AS 주문번호, A.업체번호, A.주문금액
    FROM 주문 A
    WHERE A.주문일자 = :dt
        AND A.주문번호 > NVL(:next_ord_no, 0)
    ORDER BY 주문번호   /* TO_CHAR의 FM000000옵션이 사용된 주문번호이기 때문, A.주문번호로 해야 함 */
    )
WHERE ROWNUM <= 30
```

### SELECT-LIST 에서 컬럼 가공
* 인덱스가 장비번호 + 변경일자 + 변경순번 순으로 구성되어 있으면서 정렬연산을 생략하는 예시
  ```oracle
  SELECT MIN(변경순번)
  FROM 상태태변경이력
  WHERE 장비번호 = 'C'
    AND 변경일자 = '20180316'
  ```
  ```oracle
  SELECT MAX(변경순번)
  FROM 상태태변경이력
  WHERE 장비번호 = 'C'
    AND 변경일자 = '20180316'
  ```
* 정렬연산을 생략할 수 없는 예시
  ```oracle
  SELECT NVL(MAX(TO_NUMBER(변경순번)), 0)
  FROM 상태변경이력
  WHERE 장비번호 = 'C'
    AND 변경일자 = '20180316'
  ```
  * 인덱스에는 문자열 기준으로 정렬되어 있는데, 이를 숫자값으로 바꾼 값 기준으로 최종 변경순번을 요구했기 때문이다.
  ```oracle
  SELECT NVL(TO_NUMBER(MAX(변경순번)), 0)
  FROM 상태변경이력
  WHERE 장비번호 = 'C'
    AND 변경일자 = '20180316'
  ```
  * 위와같이 바꾸면 정렬연산 없이 변경순번을 쉽게 찾을 수 있다.

### 자동 형변환
* 생년월일이 선두 컬럼인 인덱스가 있을 때, 아래 SQL은 생년월일 컬럼을 가공하지 않았는데도 테이블 전체 스캔을 선택한다.
```oracle
SELECT * FROM 고객
WHERE 생년월일 = 19821225
```
* 옵티마이저가 SQL을 아래와 같이 변환했고 결국 인덱스 컬럼이 가공되었기 때문이다.
```oracle
SELECT * FROM 고객
WHERE TO_NUMBER(생년월일) = 19821225
```
* 각 조건절에 양쪽 값의 데이터 타입이 다르면, 타입체크를 엄격하게 하여 컴파일 시점에 에러를 내는 DBMS가 있고, 자동으로 형변환 처리해주는 DBMS가 있다.
  * 오라클은 자동으로 형변환처리 해준다.
* 오라클에서는 숫자형과 문자형이 만나면 숫자형이 이기므로, 숫자형 컬럼 기준으로 문자형 컬럼을 변환한다.
  * 연산자가 LIKE일때에는 문자열 비교 연산자이므로, 문자형 기준으로 숫자형 컬럼이 변환된다.
* 날짜형과 문자형('01-JAN-2018')이 만나면 날짜형이 이긴다.
* 따라서 아래와 같이 타입을 정확히 지정해주는 습관이 좋다.
```oracle
SELECT * FROM 고객
WHERE 가입일자 = TO_DATE('01-JAN-2018, DD_MON_YYYY')
```
* LIKE 조건을 옵션 처리 목적으로 사용하는 경우가 종종 있다.
  * 아래 예시에서 계좌번호가 숫자형이면 인덱스를 사용할 수 없다.
  ```oracle
  SELECT * FROM 거래
  WHERE 계좌번호 LIKE :acnt_no || '%'
  AND 거래일자 between :trd_dt1 and :trd_dt2
  ```
* 자동 형변환으로 인해 쿼리의 결과가 의도와는 다르게 나오는 경우도 있다.
* 따라서 자동 형변환의 기능에 의존하면 안된다.
* **인덱스 컬럼 기준으로 반대 편 컬럼 또는 값들을 정확하게 형변환 해줘야 한다.**

## 인덱스 확장기능 사용법
### Index Range Scan
* Index Range Scan은 B-Tree 인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식이다.
* 인덱스 루트에서 리프블록까지 수직적으로 탐색 후 필요한 범위만 스캔한다.

### Index Full Scan
* Index Full Scan은 수직적 탐색 없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식이다.
* 보통 데이터 검색을 위한 최적의 인덱스가 없을 경우 차선으로 선택된다.

#### Index Full Scan의 효용성
* 인덱스 선두컬럼이 조건절에 없으면 옵티마이저는 Table Full Scan을 고려한다.
* 하지만 대용량 테이블이어서 Table Full Scan에 따른 부담이 큰 경우 옵티마이저는 인덱스 활용을 다시 고려하지 않을 수 있다.
* 데이터 저장공간은 (컬럼길이 * 레코드 수)에 의해 결정되므로 인덱스가 차지하는 면적은 테이블보다 훨씬 적다.
* 인덱스 스캔 단계에서는 대부분 레코드를 필터링하고 아주 일부만 테이블을 액세스 하는 상황이라면 면적이 큰 테이블보다 인덱스를 스캔하는쪽이 유리하다.
* 옵티마이저가 이럴경우엔 Index Full Scan 방식을 선택한다.

#### 인덱스를 이용한 소트 연산 생략
* 인덱스를 Full Scan하면 결과 집함이 인덱스 컬럼 순으로 정렬된다.
* 따라서 옵티마이저가 전략적으로 선택한 경우, Sort Order By 연산을 생략할 목적으로 사용할 수도 있다.
* 하지만 대부분이 조건을 만족하는 상황에서 Index Full Scan을 선택하면 거의 모든 레코드에 대해 테이블 액세스가 발생하므로, Table Full Scan보다 오히려 불리하다.

### Index Unique Scan
* Index Unique Scan은 수직적 탐색만으로 데이터를 찾는 스캔 방식으로, Unique 인덱스를 `=` 조건으로 탐색하는 경우 작동한다.
* Unique Index가 존재하는 컬럼은 중복 값이 입력되지 않게 DBMS가 데이터 정합성을 관리해준다.
* 그러므로 해당 인덱스 키 컬럼을 모두 `=` 조건으로 검색할 때는 데이터를 한 건 찾는 순간 더이상 탐색할 필요가 없다.

### Index Skip Scan
* 인덱스 선두 컬럼을 조건절에 사용하지 않으면 옵티마이저는 기본적으로 Table Full Scan을 선택한다.
* 하지만 Table Full Scan 보다 I/O를 줄일 수 있거나 정렬된 결과를 쉽게 얻을 수 있다면 Index Full Scan을 사용하기도 한다.
* 오라클은 인덱스 선두컬럼이 조건절에 없어도 인덱스를 활용하는 새로운 스캔 방식을 9i버전에서 선보였는데, 이게 Index Skip Scan이다.
* Index Skip Scan은 조건절에 빠진 인덱스 선두 컬럼의 Distinct Value 개수가 적고 후행 컬럼의 Distinct Value 개수가 많을 때 유용하다.
* `index_ss`, `no_index_ss` 힌트를 사용해 이 스캔 방식을 유도하거나 방지할 수 있다.

#### Index Skip Scan이 작동하기 위한 조건
* Index Skip Scan은 Distinct Value 개수가 적은 선두 컬럼이 조건절에 없고, 후행 컬럼의 Distinct Value 개수가 많을 때 효과적이다.
* 하지만 인덱스 선두 컬럼이 없을 때만 Index Skip Scan이 작동하는건 아니다.
* 선두컬럼에 대한 조건절은 있고, 중간컬럼에 대한 조건절이 없는 경우에도 Skip Scan을 사용할 수 있다.
  ```oracle
  /* 일별업종별거래_PK : 업종유형코드 + 업종코드 + 기준일자 */
  SELECT /*+ INDEX_SS(A 일별업종별거래_PK) */
        기준일자, 업종코드, 체결건수, 체결수량, 거래대금
  FROM 일별업종별거래 A
  WHERE 업종유형코드 = '01'
      AND 기준일자 BETWEEN '20080501' AND '20080531'
  ```
  * 위 예시에서 Index Range Scan을 사용하면 업종코드유형이 '01'인 인덱스 구간을 모두 스캔해야 한다.
  * Index Skip Scan을 사용하면 업종코드유형이 '01'인 구간에서 기준일자 조건의 레코드를 포함할 가능성이 있는 리프 블록만 골라서 액세스할 수 있다.
* 선두컬럼이 부등호, BETWEEN, LIKE같은 범위 검색 조건일 때도 Index Skip Scan을 사용할 수 있다.
  ```oracle
  /* 일별업종별거래_X01 : 기준일자 + 업종유형코드 */
  SELECT /*+ INDEX_SS(A 일별업종별거래_X01) */
        기준일자, 업종코드, 체결건수, 체결수량, 거래대금
  FROM 일별업종별거래 A
  WHERE 기준일자 BETWEEN '20080501' AND '20080531'
    AND 업종유형코드 = '01'
  ```
  * 위 예시에서 Index Range Scan을 사용한다면, 기준일자 BETWEEN 조건을 만족하는 인덱스 구간을 모두 스캔해야 한다.
  * 조건을 만족하는 인덱스 구간에서 업종유형코드 = '01'인 레코드를 포함할 가능성이 있는 리프블록만 골라서 액세스할 수 있다.
* Index Range Scan이 불가능하거나 효율적이지 못한 상황에서 Index Skip Scan이 종종 빛을 발할 수 있다.
* **인덱스는 기본적으로 최적의 Index Range Scan을 목표로 설계해야 하며, 수행횟수가 적은 SQL을 위해 인덱스를 추가하는것이 비효율적일 때 이러한 스캔 방식을 차선책으로 활용하는 전략이 바람직하다.**

### Index Fast Full Scan
* Index Fast Full Scan은 Index Full Scan보다 빠르다
* 논리적인 인덱스 트리구조를 무시하고 인덱스 세그먼트 전체를 Multiblock I/O 방식으로 스캔하기 때문에 Index Full Scan보다 빠르다.
* `index_ffs`, `no_index_ffs` 힌트로 이 스캔방식을 유도하거나 방지할 수 있다.
* Index Fast Full Scan은 루트와 브랜치블록은 읽지만 필요없으므로 무시한다.
* Index Fast Full Scan은 Multiblock I/O 방식을 사용하므로, 디스크로부터 대량의 인덱스 블록을 읽어야 할 때 큰 효과를 발위한다.
* 연결리스트 구조를 무시한 채 데이터를 읽기 때문에, 결과 집합이 인덱스 키 순서대로 정렬되지 않는다.
* 쿼리에 사용한 컬럼이 모두 인덱스에 포함되어 있을 때만 사용할 수 있다.
* Index Range Scan 또는 Index Full Scan과 달리 인덱스가 파티션 되어있지 않더라도 병렬쿼리가 가능하다.
* 병렬 쿼리 시에는 Direct Path I/O 방식을 사용하기 때문에 I/O 속도가 더 빨라진다.

### Index Range Scan Descending
* Index Range Scan과 기본적으로 동일한 스캔 방식으로, 인덱스를 뒤에서 앞쪽으로 스캔하기 떄문에 내림차순으로 정렬된 결과집합을 얻는다.
* `index_desc` 힌트를 이용해 유도할 수 있다.
* MAX 값을 구하고자 할 때에 해당 컬럼에 인덱스가 있으면 인덱스를 뒤에서부터 한 건만 읽고 멈추는 실행계획이 자동으로 수립된다.

# 인덱스 튜닝
## 테이블 액세스 최소화
### 테이블 랜덤 액세스
#### 인덱스 ROWID는 물리적? 논리적?
* 인덱스 ROWID는 물리적 주소보다 논리적 주소에 가깝다.
* 물리적으로 직접 연결되지 않고 테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고있기 때문이다.
* 메모리상 데이터를 찾아가는데 있어 포인터의 비용은 0에 가깝고, 물리적으로 직접 연결된 구조와 다름없다.
* 인덱스 ROWID는 포인터와는 다르다. 테이블 레코드를 찾아가기위한 위치 정보만을 담고 있으며, 테이블 레코드와 물리적으로 연결된 구조가 아니다.
* 오라클은 테이블 블록이 수시로 버퍼캐시에서 밀려났다 다시 캐싱되기를 반복한다.
* 그때마다 다른 공간에 캐싱되기 때문에 인덱스에서 포인터로 직접 연결할 수 없는 구조이다.
* 메모리 주소 정보(포인터)가 아닌 디스크 주소 정보(Data Block Address)를 이용해 해시 알고리즘으로 버퍼 블록을 찾아간다.

#### I/O 메커니즘
* DBA는 디스크 상에서 블록을 찾기 위한 주소 정보이다.
* I/O성능을 높으려면 매번 디스크에서 블록을 읽을 수 없기 때문에 버퍼캐시를 활용해야 한다.
* 그래서 블록을 읽을 때 디스크로 가기 전 버퍼캐시부터 찾아본다.
  * 읽고자 하는 DBA를 해시함수에 입력해 해시 체인을 찾고 거기서 버퍼 헤더를 찾는다.
* 캐시에 적재할 때와 읽을 때 같은 해시 함수를 사용하므로, 버퍼 헤더는 항상 같은 해시 체인에 연결된다.
* 하지만 실제 데이터가 담긴 버퍼 블록은 매번 다른 위치에 캐싱되는데, 그 메모리 주소값을 버퍼 헤더가 갖고 있다.
* 따라서 해싱 알고리즘으로 버퍼 헤더를 찾고 거기서 얻은 포인터로 버퍼블록을 찾아간다.
* 인덱스로 테이블 블록을 액세스할 때에는 리프블록에서 읽은 ROWID를 분해해 DBA정보를 얻고, 테이블을 Full Scan할 때는 익스텐트 맵을 통해 읽은 블록들의 DBA정보를 얻는다.
* 즉, ROWID는 포인터가 아니고 테이블 레코드를 찾아가기 위한 논리적인 주소정보이다.
  * ROWID가 가리키는 테이블 블록을 버퍼캐시에서 먼저 찾은 후, 못 찾을 때만 디스크에서 블록을 읽는다. (버퍼캐시 적재 후 읽음)
  * 모든 데이터가 캐싱되어 있어도 테이블 레코드를 찾기 위해 DBA 해싱과 래치 획득 과정을 반복해야 한다.
  * 캐시버퍼 체인 래치와 버퍼 Lock에 대한 경합까지 발생한다.
* ROWID를 이용한 테이블 액세스는 생각보다 고비용 구조이다. 

* `TABLE ACCESS BY INDEX ROWID` 오퍼레이션을 볼 때마다 이러한 복잡한 처리과정을 떠올려야 한다.

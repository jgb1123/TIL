# SQL 처리과정과 I/O
## SQL 파싱과 최적화
### SQL?
* SQL은 Structured Query Language 의 줄임말이다.
* SQL은 깁노적으로 구조적(structured)이고, 집합적(set-based)이고, 선언적(declarative)인 질의 언어이다.
* 원하는 결과 집합을 구조적, 집합적으로 선언하지만 그 결과 집합을 만드는 과정은 절차적일 수 밖에 없다.
* 결국 프로시저가 필요한데, 그 프로시저를 만들어내는 DBMS 내부 엔진이 바로 SQL 옵티마이저이다.
* DBMS 내에서 프로시저를 작성하고 컴파일해 실행 가능한 상태로 만드는 모든 과정을 SQL 최적화라고 한다.


### SQL 최적화 과정
1) SQL 파싱
   * 사용자로부터 SQL을 전달받으면, 가장 먼저 SQL 파서가 파싱을 진행한다.
   * 파싱 트리 생성 : SQL문을 이루는 개별 구성 요소를 분석해 파싱 트리를 생성한다.
   * Syntax 체크 : 문법적 오류가 없는지 확인한다.
   * Semantic 체크 : 의미상 오류가 없는지 확인한다.

2) SQL 최적화
   * SQL최적화는 옵티마이저가 진행한다.
   * 옵티마이저가 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 실행 경로를 생성해 비교한 후 가장 효울적인 하나를 선택한다.
3) 로우 소스 생성
   * SQL 옵티마이저가 선택한 실행 경로를 실행가능한 코드나 프로시저 형태로 포맷팅한다.
   * 로우 소스 생성기(Row-Source Generator)가 그 역할을 맡는다.

### SQL 옵티마이저
* SQL옵티마이저는 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 액세스 경로를 선택해주는 DBMS의 핵심 엔진이다.
1) 사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 찾아낸다.
2) 데이터 딕셔너리에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상 비용을 산정한다.
3) 최저 비용을 나타내는 실행 계획을 선택한다.

### 실행계획과 비용
* DBMS에 SQL 실행경로 미리 보기 기능이 있는데, 실행 계획(Execution Plan)이다.
* 이를 통해 자신이 작성한 SQL이 테이블을 스캔하는지, 인덱스를 스캔하는지, 인덱스를 스캔한다면 어떤 인덱스인지를 확인할 수 있으며, 예상과 다른 방식으로 처리되면 실행경로를 변경할 수 있다.
* SQL 실행계획에 표시되는 Cost도 예상치이며, 실행경로를 선택하기 위해 옵티마이저가 여러 통계 정보를 활용해 계산해낸 값이다.

### 옵티마이저 힌트
* 옵티마이저가 보통 좋은 선택을 하지만, 그 선택이 최선은 아니다.
* 옵티마이저 힌트를 이용해 데이터 액세스 경로를 바꿀 수 있다.
* 중요한 시스템이라면, 옵티마이저의 판단에 맡기긴 어렵지만, 힌트를 쓸거면 빈틈없이 써야 한다.
```oraclesqlplus
/*+ INDEX(T1 TEST_PK) */
```
#### 주의사항
* `--+ INDEX(A TEST_PK)`방식은 가급적 쓰지 말아야 한다.
* 인자를 나열할 땐 `,`를 사용할 수 있지만 힌트와 힌트 사이에 사용하면 안된다.
* 테이블을 지정할 때 스키마 명까지 명시하면 안된다.
* FROM절 옆에 ALIAS를 지정했으면 힌트에도 반드시 ALIAS를 사용해야 한다.

## SQL 공유 및 재사용
### 소프트 파싱 vs 하드 파싱
* SQL 파싱, 최적화, 로우소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복해서 재사용할 수 있도록 캐싱해두는 메모리 공간을 **라이브러리 캐시**라고 한다.
  * 라이브러리 캐시는 SGA의 구성 요소이다.
    > SGA(System Global Area)
    >* 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간
* 사용자가 SQL문을 전달하면 DBMS는 SQL을 파싱한 후 해당 SQL이 라이브러리 캐시에 존재하는지부터 확인한다.
* SQL을 캐시에서 찾아 바로 실행단계로 넘어가는것을 **소프트파싱** 이라고 한다.
* 찾는데 실패 해 최적화 및 로우 소스 생성 단계까지 모두 거치는것을 **하드파싱** 이라고 한다.
  * 하드파싱은 CPU를 많이 소비하는 몇 안되는 작업 중 하나이다.
  * 쿼리를 수행할 때, 후보군이 될만한 많은 실행경로를 도출하고, 딕셔너리와 통계정보를 읽어 각각의 효율성을 판단하는 과정은 결코 가볍지 않다.

### 바인드 변수의 중요성
#### 이름이 없는 SQL 문제
* 사용자 정의 함수/프로시저, 트리거, 패키지 등은 생성할 때 부터 이름을 갖기 때문에, 컴파일한 상태로 딕셔너리에 영구적으로 보관된다. 
* SQL은 이름이 따로 없고, 전체 텍스트가 이름 역할을 한다.
#### 공유 가능 SQL
* 바인드 변수를 사용하지 않으면, DBMS에서 발생하는 부하는 대개 I/O가 원인인데, I/O가 거의 발생하지 않음에도 CPU사용률은 급격히 올라갈 수 있다. (SQL 하드파싱 문제)
* 따라서 바인드 변수를 사용해 파라미터 Driven 방식으로 SQL을 작성하면 이러한 하드파싱 문제를 방지할 수 있다.

## 데이터 저장 구조 및 I/O 메커니즘
* I/O 튜닝이 곧 SQL 튜닝이라 해도 과언이 아니다.
* 즉 SQL튜닝 원래를 제대로 이해하려면 I/O에 대한 이해가 필수적이다.

### SQL이 느린 이유
* I/O는 잠 이라고 설명할 수 있다.
* I/O를 처리하는 동안 프로세스는 잠을 자기 때문이다.
* 프로세스가 잠을 자는 이유는 여러가지가 있지만, I/O가 가장 대표적이고 많은 비중을 차지한다.
* interrupt 없이 일하는 프로세스도 디스크에서 데이터를 읽어야 할 땐 CPU를 OS에 반환하고 waiting 상태에서 I/O가 완료되기를 기다린다.
  * CPU를 반환한 채 대기 큐에서 잠을 자는 것이다.
* 열심히 일해야 할 프로세스가 잠을 자게 되므로, I/O가 많으면 성능이 느릴 수 밖에 없다.
* SQL이 느린 이유는 여기에 있으며, 즉 디스크 I/O 때문이다.

### 데이터베이스 저장 구조
* 데이터를 저장하려면 **테이블 스페이스**를 생성해야 한다.
  * 테이플 스페이스는 세그먼트를 담는 콘테이너로, 여러 개의 데이터파일로 구성된다.
* 테이플스페이스를 생성했으면, **세그먼트**를 생성한다.
  * 세그먼트는 테이블, 인덱스 처럼 데이터 저장공간이 필요한 오브젝트이다.
    * 따라서 테이블, 인덱스를 생성할 때 데이터를 어떤 테이블 스페이스에 저장할지를 지정한다.
  * 파티션 구조가 아니라면 테이블도 하나의 세그먼트, 인덱스도 하나의 세그먼트이다.
  * 파티션구조라면 각 파티션이 하나의 세그먼트가 된다.
  * LOB컬럼은 그 자체가 하나의 세그먼트를 구성하므로 자신이 속한 테이블과 다른 공간에 값을 저장한다. (작은 LOB는 설정에 따라 in-row 저장 가능)
* 세그먼트는 여러 **익스텐트**로 구성된다.
  * 익스텐트는 공간을 확장하는 단위이다.
  * 테이블이나 인덱스에 데이터를 입력하다 공간이 부족해지면 오브젝트가 속한 테이블 스페이스로부터 익스텐트를 추가로 할당받는다.
  * 익스텐트는 연속된 블록들의 집합이기도 하다.
* 익스텐트 단위로 공간을 확장하지만, 레코드를 실제로 저장하는 공간은 **데이터 블록**이다.
  * 한 블록은 하나의 테이블이 독점한다.
  * 즉, 한 블록에 저장된 레코드는 같은 테이블 레코드이다.
  * 추가로, 한 익스텐트도 하나의 테이블이 독점한다.
  * 즉, 한 익스텐트에 담긴 블록은 모두 같은 테이블 블록이다. (MS-SQL은 한 익스텐트를 여러 오브젝트가 사용할 수도 있음)
* 세그먼트 공간이 부족해지면 테이블 스페이스로부터 익스텐트를 추가로 할당받지만, 세그먼트에 할당된 모든 익스텐트가 같은 데이터파일에 위치하지 않을 수도 있다.
  * 서로 다른 데이터 파일에 위치할 가능성이 더 높다.
  * 하나의 테이블스페이스를 여러 데이터파일로 구 성하면 파일 경합을 줄이기 위해 DBMS가 가능한 여러 데이터로 분산해 저장하기 때문이다.

#### DBA(Data Block Address)
* 데이터 블록은 디스크 상에서 몇 번 데이터 파일의 몇 번째 블록인지를 나타내는 고유 주소값(DBA)을 갖는다.
* 데이터를 읽으려면 DBA부터 확인해야 한다.
* 인덱스를 이용해 테이블 레코드를 읽을 때에는 인덱스 ROWID를 이용한다.
* ROWID 는 DBA + 로우 번호(블록 내 순번)으로 구성되므로, 이를 통해 읽어야 할 테이블 레코드가 저장된 DBA를 알 수 있다.
* 테이블 스캔 시에는 테이블 세그먼트 헤더에 저장된 익스텐트 맵을 이용한다.
* 익스텐트 맵을 통해 각 익스텐트의 첫 번쨰 블록 DBA를 알 수 있다.
* 즉, 익스텐트는 연속된 블록의 집합이므로 테이블을 스캔할 때에는 첫 번쨰 블록 뒤에서 연속해서 저장된 블록을 읽으면 된다.

### 블록 단위 I/O
* 데이터베이스에서 데이터를 읽고 쓰는 단위는 블록이다.
* 데이터 I/O 단위가 블록이므로, 특정 레코드를 하나 읽고 싶어도 해당 블록을 통째로 읽는다.
* 오라클은 기본적으로 8KB 크기의 블록을 사용한다. (1Byte를 읽기 위해 8KB를 읽는다)

### 시퀀셜 액세스 vs 랜덤 액세스
#### 시퀀셜 액세스
* 시퀀셜 액세스는 논리적또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식이다.
* 인덱스 리프 블록은 앞뒤를 가리키는 주소값을 통해 논리적으로 연결되어 있다.
  * 이 주소값에 따라 앞 또는 뒤로 순차적으로 스캔하는 방식이 시퀀셜 액세스이다.
* 테이블 블록 간에는 논리적인 연결고리를 갖고있지 않다.
  * 세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더에 맵으로 관리한다.
  * 이 익스텐트 맵은 첫 번째 블록 주소 값을 갖는다.
  * 따라서 읽어야 할 익스텐트 목록을 익스텐트 맵에서 얻고, 각 익스텐트의 첫 번째 블록 뒤에 연속해서 저장된 블록을 순서대로 읽으면, 바로 Full Table Scan이다.

#### 랜덤 액세스
* 랜덤 액세스는 논리적, 물리적 순서를 따르지 않고 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식이다.

### 논리적 I/O vs 물리적 I/O
#### DB 버퍼캐시
* SGA 구성요소로 라이브러리 캐시가 있는데, 데이터를 캐싱하는 DB 버퍼캐시도 SGA의 중요한 구성요소중 하나이다.
* 라이브러리 캐시가 SQL과 실행계획, DB 저장형 함수/프로시저 등을 캐싱하는 코드캐시라고 한다면, DB버퍼캐시는 데이터 캐시라고 할 수 있다.
* 디스크에서 읽은 데이터 블록을 캐싱해 같은 블록에 대한 반복적인 I/O Call을 줄이는데 목적이 있다.
* 서버 프로세스와 데이터 파일 사이에 버퍼 캐시가 있으므로, 데이터 블록을 읽을 때에는 항상 버퍼캐시부터 탐색한다.
  * 버퍼캐시는 공유메모리 영역이므로, 같은 블록을 읽는 다른 프로세스도 득을 본다.


#### 논리적 I/O vs 물리적 I/O
* 논리적 블록 I/O는 SQL을 처리하는 과정에 발생한 총 블록 I/O를 말한다.
* 물리적 블록 I/O는 디스크에서 발생한 총 블록 I/O를 말한다.
  * 읽어야 할 블록을 버퍼캐시에서 찾지 못할 때만 디스크를 액세스 하므로, 논리적블록 I/O의 일부가 물리적 I/O이다.
* 메모리 I/O는 전기적신호이지만, 디스크 I/O는 액세스 암을 통해 물리적 작용이 일어나므로 메모리 I/O에 비해 상당히 느리다. (보통 10000배 느림)
* Direct Path Read방식으로 읽는 경우를 제외하면, 모든 블록은 DB 버퍼캐시를 경유해서 읽는다.
* 즉, 일반적으로 논리적 I/O횟수는 DB버퍼캐시에서 블록을 읽은 횟수와 일치한다.
* DB버퍼캐시에서 블록을 찾지 못해 디스크에서 읽은 블록 I/O가 물리적 I/O이다.


#### 버퍼캐시 히트율
* 버퍼캐시 효율을 측정하는데 가장 많이 사용해 온 지표는 버퍼캐시 히트율(BCHR)이다.
 ```
BCHR = (캐시에서 찾은 블록 수 / 총 읽은 블록 수 ) * 100
     = ((논리적 I/O - 물리적 I/O) / 논리적 I/O) * 100
     = (1 - (물리적 I/O) / (논리적 I/O)) * 100
 ```
* 애플리케이션 특성에 따라 다르지만, 온라인 트랜잭션을 주로 처리하는 애플리케이션이라면 시스템 레벨에서 평균 99% 히트율을 달성해야 한다.
  * 핵심 트랜잭션이 시스템 전체 부하의 대부분을 차지하므로, 열심히 튜닝하면 99%는 달성하기 어려운 수치가 아니다.
* 논리적 I/O는 일정하므로, 물리적 I/O 는 버퍼캐시 히트율에 의해 결정된다.
* 결국 SQL 성능을 높이기 위해 할 수 있는 일은 논리적 I/O를 줄이는 일이다.
* 따라서 SQL을 튜닝해서 읽는 총 블록 수를 줄이면 된다.
* 논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 SQL 튜닝이다.
* 버퍼캐시 히트율이 SQL 성능을 좌우하지만, 높다고해서 효율적인 SQL을 의미하진 않는다.
  * 같은 블록을 반복해서 읽는 비효율적인 일이었을 수 있다.

### Single Block I/O vs Multiblock I/O
* 한 번에 한 블록씩 요청해서 메모리에 적재하는 방식을 Single Block I/O라고 한다.
* 한번에 여러 블록을 요청해서 메모리에 적재하는 방식을 Bultiblock I/O라고 한다.
* 인덱스를 이용할 때에는 기본적으로 인덱스와 테이블 블록 모두 Single Block I/O방식을 사용한다.
  * 인덱스 루트 블록을 읽을 때
  * 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
  * 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
  * 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
* 많은 데이터 블록을 읽을 때는 Multiblock I/O 방식이 효율적이다.
* Multiblock I/O는 캐시에서 찾지 못한 특정 블록을 읽으려고 디스크 상에 그 블록과 인접함 블록들을 한꺼번에 읽어 캐시에 미리 적재하는 기능이다.
* DBMS의 블록사이즈가 얼마건 간에 OS단에서는 일반적으로 1MB 단위로 I/O를 수행한다. (OS마다 다르다)
  * 오라클 I/O단위가 8KB이므로, db_file_multiblock_read_count를 128로 설정하면 최대가 된다. (8KB * 128)


### Table Full Scan vs Index Range Scan
* Table Full Scan은 테이블에 속한 블록 전체를 읽어 사용자가 원하는 데이터를 찾는 방식이다.
  * Table Full Scan은 시퀀셜 액세스와 Multiblock I/O 방식으로 디스크 블록을 읽는다.
* Index Range Scan은 인덱스에서 일정량을 스캔하면서 얻은 ROWID로 테이블 레코드를 찾아가는 방식이다.
  * Index Range Scan은 랜덤 액세스와 Single Block I/O방식으로 디스크 블록을 읽는다.
* Table Full Scan은 스토리지 스캔 성능이 좋아지는 만큼 성능도 좋아진다.
* Index Range Scan은 스토리지 성능이 많이 좋아져도 성능이 조금만 좋아진다.
* Table Full Scan을 피해야 한다는 인식과 달리 인덱스가 SQL성능을 떨어뜨리는 경우도 많다.
  * 한번에 많은 데이터를 처리하는 집계용 SQL과 배치프로그램이 그렇고, 이 경우엔 오히려 Full Scan으로 유도하면 성능이 좋아진다.
  * 물론 큰 테이블에서 소량의 데이터를 검색할 때에는 반드시 인덱스를 이용해야 한다.
* 인덱스는 굉장히 중요하긴 하지만, 항상 옳은 것은 아니므로 모든 성능문제를 인덱스로 해결하려고 하면 안된다.

### 캐시 탐색 메커니즘
* Direct Path I/O를 제외한 모든 블록 I/O는 메모리 버퍼캐시를 경유한다.
  * 인덱스 루트 블록을 읽을 때
  * 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
  * 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
  * 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
  * 테이블 블록을 Full Scan 할 때
* 버퍼 캐시에서 블록을 찾을 때 해시 알고리즘으로 버퍼 헤더를 찾고, 거기서 얻은 포인터로 버퍼 블록을 액세스하는 방식을 사용한다.
  * 같은 입력값은 항상 동일한 해시 체인에 연결됨
  * 다른 입력값이 동일한 해시 체인에 연결될 수 있음
  * 해시 체인 내에서는 정렬이 보장되지 않음
* 버퍼캐시에 캐싱된 버퍼블록은 모두 공유자원이기 때문에, 동시에 두 개 이상 프로세스가 접근하려고 할 때 정합성에 문제가 생길 수 있다.
* 따라서 한 프로세스씩 순차적으로 접근하도록 구현해야 하며, 이를 위한 직렬화 메커니즘이 필요한데, 이를 지원하는 메커니즘이 래치이다.
> 캐시버퍼 체인 래치
> * 대량의 데이터를 읽을 때 모든 블록에 대해 해시 체인을 탐색한다.
> * DBA를 해시 함수에 입력하고 반환된 값으로 스캔해야 할 해시 체인을 찾는다.
> * 해시체인에는 키를 획득한 프로세스만이 체인으로 진입할 수 있다.
* 버퍼캐시에는 캐시버퍼 체인 래치, 캐시버퍼 LRU 체인 래치 등이 작동한다.
* 캐시I/O도 생각보다 빠르지 않을 수 있는데, 이 래치에 의한 경합이 생길 수 있기 때문이다.
* 캐시버퍼 체인 뿐 아니라 버퍼블록 자체에도 버퍼 Lock이라는 직렬화 메커니즘이 존재한다.
* 따라서 이러한 직렬화 메커니즘에 의한 캐시 경합을 줄이려면 SQL튜닝을 통해 논리적 I/O 자체를 줄여야 한다.

> 버퍼 Lock
> * 래치를 해제한 상태로 버퍼 블록 데이터를 읽고 쓰는 경우 같은 블록에 접근할 수 있다.
> * 같은 블록에 접근해 데이터를 읽고 쓴다면 데이터 정합성에 문제가 생길 수 있다.
> * 이를 방지하기 위해 오라클은 버퍼 Lock을 사용한다.
> * 캐시버퍼 체인 래치를 해제하기 전 버퍼 헤더에 Lock을 설정함으로써 버퍼블록 자체에 대한 직렬화 문제를 해결한다.

# DataBase
## 데이터베이스의 필요성
* 이전에는 데이터를 저장하는 방법으로 File에 데이터를 저장하거나, In-Memory 형태로 데이터를 임시 저장하는 방법을 사용했다.
* 이러한 방법들로도 데이터를 저장할 수 있으나, 어느정도 한계가 있고, 그렇기 때문에 데이터베이스를 사용한다.

### In-Memory의 문제점
* 데이터가 프로그램의 실행에 의존하게 되고, 예기치 못한 상황으로부터 데이터를 보호할 수 없다.
* 프로그램이 종료된 상태라면 데이터를 원하는 시간에 받아올 수 없고, 데이터의 수명이 프로그램의 수명에 의존하게 된다.
### File I/O의 문제점
* 엑셀 시트나 CSV같은 파일의 형태는 In-Memory에 비해 데이터를 저장하는 방식으로 더 적절해 보인다.
* 하지만 한계가 분명히 존재한다
  * 데이터가 필요할때마다 전체 파일을 매번 읽어야 한다. 파일의 크기가 커질수록 이 작업은 비효율적이다.
  * 파일이 손상되거나, 여러 개의 파일들을 동시에 다뤄야 하는 등 복잡하고 데이터량이 많아질수록 데이터를 불러들이는 작업이 점점 버거워진다.

### 데이터베이스 사용 이유
* 관계형 데이터베이스에서는 하나의 CSV파일이나 엑셀시트를 한개의 테이블로 저장할 수 있다.
* 한번에 여러 개의 테이블을 가질 수 있기 때문에 SQL을 활용해 데이터를 불러오기 수월해진다.
* 엑셀 시트와 CSV파일 등 처럼 특정 형태의 파일은 대용량 데이터를 저장하기 위한 목적이 아니며, 데이터베이스는 대용량 데이터 저장에 용이하다.






## SQL이란
* Structured Query Language의 약자로, 구조화된 쿼리 언어이다. (데이터 베이스용 프로그래밍 언어)
> Query
>* 직역으로 질의문이라는 뜻으로, 데이터베이스에 정보를 요청하는 것이다.
>* 웹 서버에서는 특정한 정보를 보여달라는 요청에 의한 처리로, 데이터 베이스로부터 특정 정보를 찾기위해 사용된다.
>* 예로, 검색을 할 때 입력하는 검색어가 쿼리이다.
>  * 검색을 할 때 기존에 존재하는 데이터를 검색어로 필터링한다.
>  * 쿼리는 저장되어 있는 데이터를 필터링 하기위한 것이다.

* SQL은 데이터베이스에 쿼리를 보내 원하는 데이터를 가져오거나 삽입할 수 있다.
* SQL은 주로 데이터가 구조화된 테이블을 사용하는 관계형 데이터베이스에서 사용한다.
* MySQL, Oracle, SQLite, PostgreSQL 등 다양한 데이터베이스에서 SQL을 사용할 수 있다.
* 데이터베이스에서 SQL은 데이터베이스 종류를 SQL이라는 언어단위로 분류할 정도로 중요하다.
* SQL을 사용하기 위해서는 데이터 구조가 고정되어 있어야 한다.


## 데이터베이스 관련 명령어
* 데이터베이스 생성
  ```sql
  CREATE DATABASE 데이터베이스명;
  ```

* 데이터베이스 접속
  ```sql
  USE 데이터베이스명;
  ```
  
* 데이터베이스 삭제
  ```sql
  DROP DATABASE 데이트베이스명;
  ```
  
* 테이블 생성
  
  | 필드명   | 필드타입              | 그 외의 속성                    |
  |-------|-------------------|----------------------------|
  | id    | 숫자                | Primary key이면서 자동 증가되도록 설정 |
  | name  | 문자열 (최대 255개의 문자) |                            |
  | email | 문자열 (최대 255개의 문자) |                            |
  
  ```sql
  CREATE TABEL ex(
    id int PRIMARY KEY AUTO_INCREMENT,
    name varchar(255),
    email varchar(255)
  );
  ```
* 테이블 정보 확인
  ```sql
  DESCRIBE user;
  ```

## SQL 명령어
### SELECT
* 데이터베이스에서 데이터를 선택하는데 사용된다.
  * 테이블에 있는 특정 열
    ```sql
    SELECT 특성1, 특성2, ...
    FROM 테이블명;
    ```
  * 테이블에 있는 모든 데이터
    ```sql
    SELECT *
    FROM 테이블명;
    ```

### INSERT INTO
* 테이블에 새 레코드를 삽입하는데 사용한다
  * 삽입할 열 이름과 값을 모두 지정한다.
    ```sql
    INSERT INTO 테이블명(특성1, 특성2, 특성3, ...)
    VALUES (값1, 값2, 값3, ...);
    ```
  * 모든 열에 값을 추가한다.
    ```sql
    INSERT INTO 테이블명
    VALUES (값1, 값2, 값3, ...);
    ```

### WHERE
* 필터 역할을 하는 쿼리문이다.
* 지정된 조건을 충족하는 레코드만 추출하는데 사용한다.
  * 특정 값과 동일한 데이터 찾기
    ```sql
    SELECT 특성1, 특성2
    FROM 테이블명
    WHERE 특성1 = "특정 값";
    ```
  * 특정 값을 제외한 값을 찾기
    ```sql
    SELECT 특성1, 특성2
    FROM 테이블명
    WHERE 특성2 <> "특정 값";
    ```
  * 특정 값보다 크거나 작은 데이터를 필터링 할때 비교연산자 사용
    ```sql
    SELECT 특성1, 특성2
    FROM 테이블명
    WHERE 특성2 > "특정 값";
    ```  
  * 특정 값과 비슷한 값들을 필터링 할때 LIKE사용 (예시는 a로 끝나는)
    ```sql
    SELECT 특성1, 특성2
    FROM 테이블명
    WHERE 특성2 LIKE "%a";
    ```
  * 리스트의 값들과 일치하는 데이터를 필터링할 때 IN사용
    ```sql
    SELECT 특성1, 특성2
    FROM 테이블명
    WHERE 특성2 IN ("특정 값1", "특정값2");
    ```
  * 값이 없는 경우인 NULL을 찾을때 IS사용
    ```sql
    SELECT *
    FROM 테이블명
    WHERE 특성1 IS NULL;
    ```
  * 값이 없는 경우를 제외할 때 IS NOT 사용
    ```sql
    SELECT *
    FROM 테이블명
    WHERE 특성1 IS NOT NULL;
    ```
### ORDER BY
* 돌려받는 데이터 결과를 어떤 기준으로 정렬하여 출력할지 결정한다.
* ORDER BY는 선택적으로 사용할 수 있다.
  * 기본 정렬은 오름차순이다.
    ```sql
    SELECT *
    FROM 테이블명
    ORDER BY 특성1;
    ```
  * 내림차순으로도 정렬할 수 있다.
    ```sql
    SELECT *
    FROM 테이블명
    ORDER BY 특성1 DESC;
    ``` 
### LIMIT
* 결과로 출력할 데이터의 갯수를 정할 수 있다.
* LIMIT은 선택적으로 사용할 수 있다.
* 쿼리문에서 사용할 때에는 가장 마지막에 추가한다.
  * 데이터 결과를 200개만 출력한다
    ```sql
    SELECT *
    FROM 테이블명
    LIMIT 200;
    ```

### DISTINCT
* 유니크한 값을 받고 싶을때 사용할 수 있다.
  * 특성1을 기준으로 유니크한 값들만 선택한다.
    ```sql
    SELECT DISTINCT 특성1
    FROM 테이블명;
    ```
  * 특성1, 특성2, 특성3의 유니크한 조합 값들을 선택한다.
    ```sql
    SELECT
      DISTINCT
        특성1
        ,특성2
        ,특성3
    FROM 테이블명;
    ```
    
### INNER JOIN
* INNER JOIN이나 JOIN으로 실행할 수 있다.
  * 둘 이상의 테이블을 서로 공통된 부분을 기준으로 연결한다.
    ```sql
    SELECT *
    FROM 테이블명
    JOIN 테이블2 ON 테이블1.특성A = 테이블2.특성B;
    ```
    
### OUTER JOIN
* OUTER JOIN은 다양한 선택지가 있다.
  * LEFT OUTER JOIN으로 LEFT INCLUSIVE를 실행한다.
    ```sql
    SELECT *
    FROM 테이블1
    LEFT OUTER JOIN 테이블2 ON 테이블1.특성A = 테이블2.특성B;
    ```
  * RIGHT OUTER JOIN으로 LEFT INCLUSIVE를 실행한다.
    ```sql
    SELECT *
    FROM 테이블1
    RIGHT OUTER JOIN 테이블2 ON 테이블1.특성A = 테이블2.특성B;
    ```    

## 쿼리문 실행 순서
* `SELECT`, `FROM`, `WHERE`, `GROUP BY`, `HAVING`, `ORDER BY`의 실행 순서는 다음과 같다.
1) `FROM` - FROM절에서 전체 테이블의 결과를 가져온다.
2) `WHERE` - 조건에 맞는 결과만 갖도록 데이터를 간추린다.
3) `GROUP BY` - WHERE 조건으로 간추린 데이터를, 선택한 칼럼으로 grouping 작업을 진행한다.
4) `HAIVNG` - GROUP BY 된 이후에 조건에 맞는 결과만 갖도록 데이터를 간추린다. (가능하면 WHERE절에서 처리하는게 성능에 좋음)
5) `SELECT` - 여러 조건에 의해 처리된 데이터에서 어떤 열을 출력해줄지 선택한다.
6) `ORDER BY` - 어떤 열을 출력할지 정해졌다면, 행의 순서를 어떻게 보여줄지 정렬한다.


## ACID
* 데이터베이스에서 트랙잭션이 발생할 떄, 그 안정성을 보장할 수 있는 성질이다.
> 트랜잭션
>* 여러 개의 작업을 하나로 묶은 실행 유닛으로, 각 트랜잭션은 하나의 특정 작업으로 시작을 해 묶여있는 모든 작업들을 다 완료해야 정상적으로 종료한다.
>* 하나의 트랜잭션에 속해있는 여러 작업 중에서 단 하나의 작업이라도 실패하면, 이 트랜잭션에 속한 모든 작업을 실패한것으로 판단한다.
>* 성공 또는 실패라는 두개의 결과만 존재하는 트랜잭션은 미완료된 작업 없이 모든 작업을 성공해야 한다.

* ACID는 Atomicity(원자성), Consistency(일관성), Isolation(격리성), Durability(지속성)을 의미한다.

###  Atomicity(원자성)
* 시스템에서 한 트랜잭션의 연산들이 모두 성공하거나, 전부 실패되는 성질을 말한다.
* 원자성은 작업이 모두 반영되거나 모두 반영되지 않음으로써 결과를 예측할 수 있어야 한다.
* 예시로 A계좌에서 출금이 이뤄지고 B계좌에 입금되지 않았다는 상황에서, 출금은 성공했지만 입금은 실패한 것이다. 이러면 출금하는 작업을 포함하여 모든 작업이 실패로 돌아가야 한다.

### Consistency(일관성)
* 하나의 트랜잭션 이전과 이후, 데이터베이스의 상태는 이전과 같이 유효해야 한다.
* 트랜잭션이 일어난 이후의 데이터베이스는 데이터베이스의 제약이나 규칙을 만족해야 한다.
* 예시로 '모든 고객은 반드시 이름을 가지고 있어야 한다'라는 제약이 있으면 이름없는 새로운 고객을 추가하는 쿼리나, 기존 고객의 이름을 삭제하는 쿼리는 일관성을 위반한다.

### Isolation(격리성)
* 모든 트랜잭션은 다른 트랜잭션으로부터 독립되어 있어야 한다.
* 실제로 동시에 여러 개의 트랜잭션들이 수행될 때, 각 트랜잭션은 고립되어 있어 연속으로 실행된 것과 동일한 결과를 나타낸다.
* 예시로 한 계좌로부터 계좌 B로 만원을, 계좌 C로 만원을 동시에 이체하는 경우 계좌 B에 먼저 송금한 뒤 계좌 C에 보내는 결과와 동일해야 한다.

### Durability(지속성)
* 하나의 트랜잭션이 성공적으로 수행되었다면, 해당 트랜잭션에 대한 로그가 남아야 하는 성질을 의미한다.
* 런타임 오류나 시스템 오류가 발생하더라도, 해당 기록은 영구적이어야 한다.
* 예시로 계좌이차를 성공적으로 실행한 뒤에, 해당 은행 데이터베이스에 오류가 발생해 종료되더라도 계좌이체 내역은 기록으로 남아있어야 한다.

## 관계형 데이터베이스, 비관계형 데이터 베이스
* 관계형 데이터베이스는 SQL을 기반으로 하고, 비관계형 데이터베이스는 NoSQL로 데이터를 다룬다.

### 관계형 데이터베이스
* 테이블의 구조와 데이터 타입 등을 사전에 정의하고, 테이블에 정의된 내용에 알맞는 형태의 데이터만 삽입할 수 있다.
* 행(row)과 열(column)로 구성된 테이블에 데이터를 저장하며, 각 열은 하나의 속성에 대한 정보를 저장하고, 행에는 각 열의 데이터 형식에 맞는 데이터가 저장된다.
* 특정한 형식을 지키기 때문에, 데이터를 정확히 입력했다면 데이터를 사용할 때 매우 수월하다.
* SQL을 활용해 원하는 정보를 쿼리할 수 있다.
* 테이블 간의 관계를 직관적으로 파악할 수 있다. (스키마가 뚜렷하게 보인다)
* 대표적인 관계형 데이터베이스는 MySQL, Oracle, SQLite, PostgreSQL, MariaDB 등이 있다.
### 비관계형 데이터베이스
* 비관계형 데이터베이스에 스키마가 없는 것은 아니다.
  * 관계형 데이터베이스는 데이터를 입력할 때 스키마에 맞게 입력해야 하는 반면, 비관계형 데이터베이스는 데이터를 읽어올 때 스키마에 따라 데이터를 읽어온다.(schema on read)
* Key-Value타입 데이터베이스
  * 속성을 Key-value의 쌍으로 나타내는 데이터를 배열의 형태로 저장한다.(Key는 속성, Value는 속성에 연결된 데이터 값)
  * 예로 Redis, Dynamo등이 대표적인 Key-Value 형식의 데이터베이스이다.
* 문서형 데이터베이스
  * 많은 문서형 데이터베이스에서 JSON과 유사한 형식의 데이터를 문서화하여 저장한다. 각각의 문서는 하나의 속성에 대한 데이터를 갖고 있고, 컬렉션이라고 하는 그룹으로 묶어서 관리한다.
  * 예로 MongoDB가 대표적인 문서 지향 데이터베이스이다.
* Wide-Column 데이터베이스
  * 데이터베이스의 열(column)에 대한 데이터를 집중적으로 관리하는 데이터베이스이다.
  * 각 열에 key-value형식으로 데이터가 저장되고, 컬럼패밀리라고 하는 열의 집합체 단위로 데이터를 처리할 수 있다.
  * 하나의 행에 많은 열을 포함할 수 있어 유연성이 높아 규모가 큰 데이터 분석에 주로 사용된다.
  * 예로 Cassandra, HBase가 대표적인 Wide-Column 데이터베이스이다.
* Graph 데이터베이스
  * 자료구조의 그래프와 비슷한 형식으로 데이터간의 관계를 구성하는 데이터베이스이다.
  * 노드(nodes)에 속성(entities)별로 데이터를 저장하고, 각 노드간 관계는 선(edge)로 표현한다.
  * 예로 Neo4J, InfiniteGraph가 대표적인 Graph 데이터베이스이다.

### 관계형 데이터베이스 vs 비관계형 데이터 베이스
* SQL과 NoSQL은 만들어진 방식, 저장하는 정보의 종류, 저장하는 방법 등에 차이가 있다.

* 데이터 저장
  * 관계형 데이터베이스는 SQL을 이용해서 데이터를 테이블에 저장한다. (미리 작성된 스키마를 기반으로 정해진 형식에 맞게 저장함)
  * NoSQL은 key-value, document, wide-column, graph등의 방식으로 데이터를 저장한다
* 스키마(Schemna)
  * SQL을 사용하려면 고정된 형식의 스키마가 필요하다. 
    * 처리하려는 데이터 속셩별로 열(column)에 대한 정보를 미리 정해두어야 한다. 
    * 스키마는 나중에 변경할 수 있지만, 이 경우 데이터베이스 전체를 수정하거나 오프라인으로 전환해야 한다.
  * NoSQL은 관계형 데이터베이스보다 동적으로 스키마의 형태를 관리할 수 있다.
    * 행을 추가할 때 즉시 새로운 열을 추가할 수 있다.
    * 개별 속성에 대해서 모든 열에 대한 데이터를 반드시 입력하지 않아도 된다.
* 쿼리(Querying)
  * 관계형 데이터베이스는 테이블 형식과 테이블간의 관계에 맞춰 데이터를 요청해야 한다.
    * 정보를 요청할 때 SQL과 같이 구조화된 쿼리 언어를 사용한다.
  * 비관계형 데이터베이스의 쿼리는 데이터 그룹 자체를 조회하는것에 초점을 두고 있다.
    * 구조화되지 않은 쿼리언어로도 데이터요청이 가능하다.
    * UnQL(UnStructured Query Language)이라고도 한다.
* 확장성(Scalability)
  * 일반적으로 SQL기반의 관계형 데이터베이스는 수직적으로 확장한다.
    * 높은 메모리, CPU를 사용하는 확장이며, 데이터베이스가 구축된 하드웨어의 성능을 많이 이용하기 때문에 비용이 많이든다.
    * 여러 서버에 걸쳐 데이터베이스의 관계를 정의할 수 있지만, 복잡하고 시간이 많이 소모된다.
  * NoSQL로 구성된 데이터베이스는 수평적으로 확장한다.
    * 보다 값싼 서버 증설, 또는 클라우드 서비스를 이용하는 확장이라고도 한다.
    * NoSQL 데이터베이스를 위한 서버를 추가적으로 구축하면 많은 트래픽을 보다 편리하게 처리할 수 있다.
    * 저렴한 범용 하드웨어나 클라우드 기반 인스턴스에 NoSQL 데이터베이스를 호스팅 할 수 있어 상대적으로 비용이 저렴하다.

### SQL기반 관계형 데이터베이스를 사용해야 하는 경우
1. 데이터베이스의 ACID 성질을 준수해야 하는 경우
   * 전자 상거래를 비롯한 모든 금융 서비스를 위한 소프트웨어 개발에서 반드시 ACID성질을 준수해야 한다.
2. 소프트웨어가 사용되는 데이터가 구조적이고 일관적인 경우
   * 프로젝트의 규모가 많은 서버를 필요로 하지 않고 일관된 데이터를 사용하는 경우, 관계형 데이터 베이스를 사용하는 경우가 많다.
   * 다양한 데이터 유형과 높은 트래픽을 지원하도록 설계된 NoSQL 데이터베이스를 사용해야만 하는 이유가 없기 때문이다.

### NoSQL기반의 비관계형 데이터베이스를 사용해야 하는 경우
1. 데이터의 구조가 거의(전혀) 없는 대용량의 데이터를 저장하는 경우
   * 대부분의 NoSQL 데이터베이스는 저장할 수 있는 데이터의 유형에 제한이 없다
   * 소프트웨어 개발에 정형화 되지 않은 많은 양의 데이터가 필요한 경우 NoSQL을 적용하는 것이 더 효율적이다.
2. 클라우드 컴퓨팅 및 저장공간을 최대한 활용하는 경우
   * 클라우드 기반으로 데이터베이스 저장소를 구축하면, 저렴한 비용의 솔루션을 제공받을 수 있다.
   * 소프트웨어에 데이터베이스의 확장성이 중요하다면, 별다른 번거로움 없이 확장할 수 있는 NoSQL 데이터베이스를 사용하는것이 좋다.
3. 빠르게 서비스를 구축하는 과정에서 데이터 구조를 자주 업데이트 하는 경우
   * 스키마를 미리 준비할 필요가 없기 때문에 빠르게 개발하는 과정에 매우 유리하다
   * 시장에 빠르게 포로토타입을 출시해야 하는 경우에 사용이 적절하다.
   * 소프트웨어 버전별로 많은 다운타임 없이 데이터구조를 자주 업데이트 해야 하는 경우 NoSQL기반의 비관계형 데이터베이스를 사용하는게 더 적합하다.


## 관계형 데이터베이스 설계
* 구조화된 데이터는 하나의 테이블로 표현할 수 있다.
* 이런 테이블을 사용하는 데이터베이스를 관계형 데이터베이스라고 한다.
* 테이블과 테이블 사이의 관계는 3가지로 분류할 수 있다.(1:1 관계, 1:N 관계, N:M 관계, 자기참조 관계)
### 1:1 관계
* 하나의 레코드가 다른 테이블의 레코드 한개와 연결된 경우이다.
* 1:1 관계는 자주 사용하지 않는다.
  * 1:1 관계로 나타낼 수 있는 관계라면, 그 테이블에 그냥 직접 저장하는게 나을 수 있기 때문이다.

### 1:N 관계
* 하나의 레코드가 서로 다른 여러개의 레코드와 연결된 경우이다.
* 예로 한 명의 유저가 여러 게시글을 작성할 수 있고, 한 게시글을 여러 유저가 작성할 수 없다.
* 이러한 1:N 관계는 관계형 데이터베이스에서 가장 많이 사용된다.

### N:M 관계
* 여러 개의 레코드가 다른 테이블의 여러개의 레코드와 관계가 있는 경우이다.
* 1:N 관계와 비슷하지만, 양방향에서 다수의 레코드를 가질 수 있다.
* 예로 인스타그램의 게시글과 해시태그가 있을 경우 게시글은 여러개의 해시태그가 있을 수 있고, 해쉬태그가 같은 여러가지 게시글이 있을 수 있다.
* 이럴경우 N:M 관계가 되며, 스키마를 디자인 할 때에는 Join 테이블을 만들어 관리한다.
  ![](./images/N_M.png)
  * Join 테이블을 이용할 떄, 조인 테이블을 위한 기본키는 반드시 있어야 한다.

### 자기참조 관계
* 때로는 테이블 내에서도 관계가 필요하다. (추천인이 누군지 파악)
* 예로 한명의 유저는 한명의 추천인을 가질 수 있으며, 여러명이 한명의 유저를 추천인으로 등록할 수 있다.
* 1:N관계와 유사하지만, 일반적인 1:N관계는 서로 다른 테이블의 관계를 나타내는 표현 방법이다.

  ![](./images/Self_Referencing.png)


## 정규화
* 일반적인 테이블을 관계형 데이터베이스에 어울리는 테이블로 만들어주는 레시피와 같은 것이다.
* 제 6 정규형인 6NF까지 있으나, 상업적으로는 보통 3NF 까지만 다루며, 3NF 까지만 되어도 정규화 되었다고 한다
### 1NF
* 제1 정규형의 조건은 Atomic columns이다.
* 제1 정규화는 테이블의 컬럼이 원자값(하나의 값)을 갖도록 테이블을 분해하는 것이다.

### 2NF
* 제2 정규형의 조건은 No partial dependencies이다.
* 제2 정규화는 제1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것이다.
* 완전 함수 종속이란 것은 기본키의 부분집합이 결정자가 되어선 안된다는것을 의미한다.

### 3NF
* 제3 정규형의 조건은 No transitive dependencies이다.
* 제3 정규화는 제2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것이다.
* 이행적 종속이란 예를들면 A -> B, B-> C가 성립되면 A->C가 성립되는것을 의미한다.
# Kubernetes
## Kubernetes?
* Spring Cloud로도 MSA를 구현할 수 있다.
* 하지만 Kubernetes는 오픈소스로 공개된 이후 가장 활발히 커뮤니티가 활성화되어있다.
* 때문에 많은 사람들이 채택하여 활용중이기 때문에 많은 트러블슈팅 사례와 적용 사례들이 있다.
* Kubernetes를 사용하면 다른 서비스들과의 연계도 편하기 때문에 Kubernetes로 MSA를 구현하는 추세임

## Pod
* Kubernetes에서 생성하고 관리할 수 있는 배포가능한 가장 작은 단위이다.
* 하나 이상의 컨테이너를 포함한다.
* 일반적으로 밀접하게 연결된 Application이 올라간 컨테이너들을 Pod로 묶어서 배포한다.
* Deployment 혹은 Job과같은 워크로드를 이용하여 생성한다.
* Pod 생성 시 휘발성 성질은 가진 IP를 자동으로 할당한다.

## Node
* 노드는 쿠버네티스에서 워커 머신을 말하며, 클러스터에 따라 가상 또는 물리 머신일 수 있다.
* Master Node, Worker Node 두 종류로 이루어져 있다.
* 각 노드는 컨트롤 플레인에 의해 관리되며 하나의 노드는 여러개의 파드를 가질 수 있고, 컨트롤 플레인은 클러스터 내 노드를 통해 파드에 대한 스케줄링을 자동으로 처리한다.
  * 컨트롤 플레인의 자동 스케줄링은 각 노드의 사용 가능한 리소스를 모두 고려한다.
* 노드는 컨테이너 런타임(Docker, containerd)을 실행하여 컨테이너화 된 애플리케이션을 호스팅한다.
* Kubelet은 노드에서 실행되는 에이전트로, 쿠버네티스 마스터 노드와 통신하여 노드의 상태 및 Pod상태를 보고하고 명령을 수행한다. 

### Master Node
* 클러스터를 제어하고 관리하는 컨트롤 플레인 역할을 한다.
* 주요 구성 요소로는 API 서버, 스케줄러, 컨트롤 매니저 등이 있다.
* 각 구성요소는 클러스터 상태를 관리하고 노드 간의 작업을 조정한다.
* 보통 마스터 노드는 단일 노드로 구성되며, 고가용성을 위해 여러 노드로 구성할 수도 있다.
* 즉, 마스터 노드는 클러스터 전반의 제어와 관리, 전체 시스템의 상태 모니터링, 작업 스케줄링 등을 담당한다.

#### API Server
* 쿠버네티스 컨트롤 플레인의 핵심은 API Server이다.
* 애플리케이션을 Kubernetes 클러스터에 배포하기 위해선 API Server와 통신해야 한다.
* API Server 클라이언트로는, Kubernetes Dashboard와 같은 UI, kubelet과 같은 CLI도구가 있다.
* API Server는 RESTful API를 통해 클러스터 리소스에 대한 액세스를 제공한다.
  * HTTP를 기반으로 하며 표준 HTTP메서드를 사용하여 리소스를 조작할 수 있다.

### WorkerNode
* 애플리케이션 컨테이너를 실행하고 관리하는 노드이다.
* 실제로 애플리케이션을 실행하고 컨테이너 관리자를 통해 컨테이너를 생성한다.
* 각 워커 노드는 Kubelet, Kube-proxy 등의 에이전트를 실행하여 마스터 노드와 통신하며, 클러스터에서 할당된 작업을 수행한다.
* 즉, 어플리케이션 실행, 리소스 할당 및 관리, 컨테이너 실행 및 모니터링 등을 담당한다.

## Cluster
* 쿠버네티스를 배포하면 클러스터를 얻는다.
* 클러스터는 쿠버네티스 내의 가장 큰 단위로, 여러 노드들의 집합체이다.
* 클러스터는 마스터노드와 워커노드들을 포함하여 전체 쿠버네티스 시스템을 구성한다.

## Service
* Cluster IP를 통해 유동적으로 생성되고 사라지는 Pod에 접근하기 위한 방법으로 사용된다.
* Service는 주로 L4 로드밸런싱을 수행하며, 여러 Pod를 묶어 적절한 Pod로 트래픽을 라우팅하는 로드 밸런싱 기능을 제공한다.
* ClusterIP / NodePort / LoadBalancer 타입으로 제공되는데, 기본 옵션은 클러스터 내부에서만 사용할 수 있는 Cluster IP이다.
    * LoadBalancer : 외부에 노출되어 외부의 트래픽을 적절한 Pod로 트래픽을 라우팅
    * NodePort : 포트포워딩 방식
    * ClusterIP : Cluster 내부에서 트래픽을 라우팅
    * ExternalName : 서비스에 select 대신 DNS name을 직접 명시하고자 할 때 사용
> L4 로드밸런싱
> 
> * L4 로드밸런싱은 주로 전송 계층에서 이루어진다.
> * TCP/UDP와 같은 전송 계층 프로토콜을 기반으로 한다.
> * Service는 IP주소와 포트를 사용하여 트래픽을 특정 Pod로 전달한다.

### 서비스 CIDR 및 IP 할당
* Service의 IP 주소는 클러스터의 Service CIDR에서 지정된다.
* CIDR 범위 내에서 유니크한 IP 주소를 할당받는다.

### Headless Service
* 기본적으로 ClusterIP를 할당받지만, Headless Service를 사용하면 각 Pod에 직접 접근할 수 있도록 DNS역시 바로 Pod IP로 해석된다.

#### Headless Service 예시
```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-headless-service
spec:
  clusterIP: None  # Cluster IP를 할당받지 않음
  selector:
    app: MyApp
  ports:
    - protocol: TCP
      port: 80
      targetPort: 9376
```
* 위 예시에서 `clusterIP: None`으로 Cluster IP를 할당받지 않도록 지정한다.
* 대신 해당 서비스의 DNS는 각 Pod에 대한 직접적인 레코드를 갖게 된다.
* Headless Service를 사용하면 클라이언트는 서비스의 DNS를 통해 각 Pod에 직접적으로 연결할 수 있다.
* 예를들어 `my-headless-service.default.svc.cluster.local`라는 DNS 주소는 MyApp 레이블을 갖는 모든 Pod에 대한 IP 주소 목록을 반환할 것이다.
* 이를통해 클라이언트는 직접적으로 Pod에 접근하거나 특정 Pod에 대한 라우팅을 수행할 수 있다.

#### 일반적인 Service와의 차이
* 일반적인 Service(Cluster IP를 가지는 서비스)는 DNS이름을 통해 서비스에 접근하면 서비스가 가지고 있는 여러 Pod 중 하나로 로드밸런싱을 통해 연결된다.
  * 서비스는 여러 Pod를 가지고 있고, 클라이언트가 DNS이름으로 서비스에 접근하면 Kubernetes가 로드밸런싱을 수행하여 하나의 Pod에 연결한다.
* Headless Service는 DNS이름을 통해 서비스에 접근하면, 서비스에 속한 각 Pod에 대한 IP 주소 목록을 반환한다.
  * 클라이언트는 이 목록을 통해 특정 Pod에 직접적으로 연결할 수 있다.
  * 로드밸런싱은 수행되지 않으며 클라이언트가 직접 선택한 Pod에 연결된다.

## Ingress
* Service는 L4레이어로 TCP에서 Pod들을 밸런싱하며, URL Path에 따른 서비스간 라우팅이 불가능하다.
* Ingress는 서비스간 Routing을 위해 API Gateway를 사용하는데, L7에서 URL기반 라우팅 기능을 수행한다.
    * 쿠버네티스 HTTP/HTTPS 기반의 L7 로드밸런싱 기능을 제공하는 컴포넌트이다.
* Service 앞에서 L7 로드밸런서 역할을 하고, URL에 따라 라우팅한다.
* Igress 리소스를 실제로 처리하고 구현하는 컴포넌트로 NGINX Ingress Controller, Traefik, HAProxy 등이 있다.

> L7 로드밸런싱
> 
> * L7 로드밸런싱은 애플리케이션 계층에서 이루어진다.
> * HTTP와 같은 애플리케이션 계층 프로토콜을 기반으로 한다.
> * Ingress는 특정 도메인이나 경로에 따라 서로 다른 서비스로 트래픽을 보낸다.

### TLS/SSL 인증서 관리
* Ingress를 통해 제공되는 HTTPS 트래픽을 암호화하기 위한 TLS/SSL 인증서를 관리한다.

### Path 기반 라우팅
* Ingress를 사용하여 특정 URL경로에 따라 서로 다른 서비스로 트래픽을 라우팅할 수 있다.

### Virtual Hosts
* 여러 도메인을 지원하고 각 도메인에 대해 다른 서비스로 트래픽을 라우팅할 수 있다.

### Backend 서비스 구성
* Ingress 리소스를 통해 라우팅되는 서비스는 Kubernetes 내의 Service로 설정되며 ClusterIP, NodePort 등이 사용된다.

### Rewrite Rules
* Ingress를 사용하여 URL경로를 재작성하거나 변경할 수 있는 rewirte 규칙을 제공한다.

### Custom Annotations
* Ingress 리소스에 사용자 지정 애너테이션을 추가하여 특별한 동작을 지시할 수 있다.


## ConfigMap, Secrets
* 컨테이너에 들어갈 애플리케이션의 설정 값을 외부에서 제어할 수 있도록 도와주는 오브젝트이다.
* Key : Value 값으로 선언한다.
* 일반적인 정보 값은 ConfigMap으로 생성하고, 민감한 기밀 정보 값은 Secrets로 생성한다.

## Monitoring
### Host(노드) 모니터링
* 노드의 리소스 사용량을 추적한다.
* 주요 지표로는 CPU 사용률, 메모리 사용량, 디스크 공간사용, 네트워크 사용량 등이 있다.
* 노드 수준의 성능과 가용성을 평가하는데 사용된다.

### 컨테이너 모니터링
* Docker 또는 Kubernetes와 같은 오케스트레이션 툴에서 동작하는 컨테이너의 리소스 사용량을 관찰한다.
* 주요 지표로는 컨테이너의 CPU, 메모리, 디스크, 네트워크 사용량 등이 있다.
* 컨테이너화된 애플리케이션의 성능을 추적하고 문제를 식별하는데 사용된다.
* cAdvisor와 같은 도구를 통해 각 노드의 모든 컨테이너의 성능 지표를 수집하고 Prometheus와 같은 시스템이나 서비스에서 이 정보를 사용할 수 있다.

### 애플리케이션 모니터링
* 컨테이너 내에서 실행되는 각 애플리케이션의 성능과 동작을 추적한다.
* 주요 지표로는 애플리케이션의 처리량, 응답시간, 에러율 등이 있다.
* 애플리케이션 레벨에서 성능 병목현상을 파악하고 사용자 경험을 개선하기 위해 사용된다.
* 이를 위한 다양한 솔루션(ELK, EFK 등)이 있다.

### Kubernetes 모니터링
* Kubernetes 클러스터 자체의 동작과 성능을 모니터링한다.
* 클러스터 노드 간의 통신, 배포된 애플리케이션의 형태, 이벤트 및 로그 등을 포함한다.
* Kubernetes 컨트롤 플레인 및 워커 노드에서 발생하는 문제를 식별하고 해결하는데 사용된다.

## ReplicaSet
* ReplicaSet은 특정 수의 Pod 복제본을 유지하는 역할을 한다.
* 주로 안정적인 서비스를 제공하기 위해 여러 Pod 인스턴스를 실행하고자 할 때 사용된다.

### Pod복제
* ReplicaSet은 정의된 수의 Pod 복제본을 유지한다.
* 실행중인 Pod의 수가 ReplicaSet에 정의된 수보다 적으면 새로운 Pod를 생성하여 해당 수를 유지하며, 반대로 많으면 초과된 Pod를 종료하여 원하는 상태로 유지한다.

### Selector
* ReplicaSet은 일치하는 Pod를 관리하기 위해 레이블 셀렉터를 사용한다.
* ReplicaSet을 생성할 때 특정 레이블 셀렉터를 지정하면 해당 셀렉터에 맞는 Pod를 ReplicaSet이 관리한다.

### 자동 복구
* ReplicaSet은 시스템 장애나, 또는 다른 이유로 Pod가 종료되면 자동으로 새로운 Pod를 생성하여 복구하며, 안정성과 가용성을 높인다.

### 업데이트 전략
* ReplicaSet은 롤링 업데이트와 같은 전략을 사용하여 새로운 Pod버전으로의 업그레이드를 관리한다.
* 이를 통해 서비스의 중단 없이 업데이트를 수행할 수 있다.

## Deployment
* Kuberenetes의 Deplyment는 컨테이너화된 애플리케이션을 관리하고 배포하는데 사용된다.
* Deployment에 정의된 Pod의 원하는 상태를 유지하기 위해 자동으로 ReplicaSet을 생성하여 Pod의 배포, 업데이트, 롤백 등을 관리한다.
* 만약 단순한 Pod의 복제만 필요하면 ReplicaSet을 사용하면 되지만, Deployment를 통해 더 높은 수준의 애플리케이션 배포와 업데이트를 할 수 있다.

### 높은 추상화 제공
* 일반적으로 애플리케이션을 배포하거나 업데이트할 때 여러 단계와 사항들을 고려해야 한다.
* Deployment는 이러한 복잡한 작업들을 사용자에게 숨겨 작업을 더 간단하게 만든다.
* 따라서 사용자는 선언적으로 목표 상태를 정의하면, Deployment가 그 상태로 만들도록 작업을 수행한다.

### 선언적 배포 구성
* Deployment는 선언적인 방식으로 애플리케이션 배포를 정의한다.
* 사용자는 목표 상태를 정의하고 Kubernetes가 실제 상태를 조정하여 원하는 상태로 만든다.

### ReplicaSet 관리
* Deployment는 내부적으로 ReplicaSet을 생성하고 관리한다.
* 이를 통해 Pod의 복제본을 안정적으로 유지하면서 업데이트할 수 있다.

### 환경변수 및 볼륨 사용
* Pod 템플릿을 통해 환경변수 및 볼륨 마운트와 같은 컨테이너 설정을 유연하게 지정할 수 있다.

## StatefulSet
* Kubernetes에서 상태가 있는 응용 프로그램을 관리하기 위한 리소스이다.
* 각 Pod에 고유한 식별자를 부여하고 앉어적인 네트워크 식별자를 유지하는 기능을 제공한다.

### 고유한 순서와 식별자 부여
* StatefulSet은 각 Pod에 고유한 순서와 이름을 부여한다.
* 일반적으로는 순차적으로 Pod를 생성하고, 생성된 Pod에는 고유한 이름이 부여된다.
* 상태가 있는 응용 프로그램에서 중요한 요소로, 데이터베이스 노드 또는 다른 상태가 있는 애플리케이션에서 사용된다.

### 안정적인 네트워크 식별자
* 각 StatefulSet Pod는 안정적인 도메인 이름을 가지며, 해당 도메인 이름은 Pod의 고유한 식별자를 기반으로 한다.
* DNS를 통해 안정적인 네트워크 식별자를 제공하므로 Pod가 재시작되어도 동일한 도메인 이름을 유지할 수 있다.

### 순차적 롤링 업데이트
* StatefulSet은 기본적으로 순차적인 방식으로 Pod를 업데이트 한다.
* 상태가 있는 애플리케이션에서 데이터의 일관성을 유지하기 위해 중요하다.

### VolumeClaimTemplate 사용
* 각 Pod에 대해 StatefulSet은 PVC(PersistentVolumeClaim)을 생성한다.
* 이는 각 Pod에서 사용되는 고정된 스토리지를 나타내며, VolumeClaimTemplate을 사용하여 각 Pod에 대해 고유한 스토리지를 할당할 수 있다.

## NameSpace
* 네임스페이스는 Kubernetes 클러스터 내의 가상의 클러스터로, 여러 사용자 간에 클러스터 리소스를 나누는 방법으로 사용되고 이름의 범위를 제공한다.
* 동일한 이름의 여러 Pod를 다른 네임스페이스에서 가질 수 있다.
* Kubernetes에서 Multi-tenancy를 구현하는 중요한 도구로, 클러스터의 유연성과 격리를 강화하는데 사용한다.

### 가상 클러스터
* 네임 스페이스는 Kubernetes 클러스터 내에서 가상 클러스터를 제공한다.
* 각 네임스페이스는 독립적인 가상 클러스터처럼 동작하며, 자원을 격리하고 이름의 범위로 제공한다.
* 여러 사용자가 동일한 클러스터에서 작업하더라도 서로 간섭하지 않고 자원을 분리하여 사용할 수 있다.

### 리소스 분리
* 여러 팀이나 프로젝트가 동일한 클러스터에서 자원을 공유하더라도 각자 독립적으로 리소를 할당하고 사용할 수 있다.
* 네임스페이스 내의 리소스가 격리되어있기 때문에, 한 네임 스페이스에서의 변경이 다른 네임스페이스에 미치는 영향을 줄일 수 있다.

### 이름의 범위(Name Scope)
* 각 네임스페이스는 자체적으로 리소스의 이름의 범위를 제공한다.
* 동일한 이름의 Pod, Service, 혹은 또 다른 Kubernetes 리소스를 다른 네임스페이스에 서용할 수 있다.
* 네임스페이스는 리소스의 이름 충돌을 방지하고 각각의 독립성을 보장한다.

### 쿼터 및 제어
* 네임스페이스는 리소스에 대한 쿼터를 설정하고 사용자 또는 팀에 대한 제어를 부여하는데 사용될 수 있다.
* 특정 네임스페이스에서 소비 가능한 자원의 양을 제한하거나 정책을 적용할 수 있다.

## Volume
* 볼륨은 Kubernetes에서 컨테이너 간에 데이터를 영속적으로 저장하는데 사용된다.
* 컨테이너의 파일시스템은 일반적으로 일시적이기 때문에, 데이터를 컨테이너 외부에 저장하고 유지하기 위해 볼륨을 사용한다.

### Volume 종류
#### emptyDir
* Pod의 라이프사이클 동안 존재하는 일시적인 볼륨이다.
* 여러 컨테이너가 동일한 Pod에서 데이터를 공유할 때 유용하다.
* 해당 Pod의 라이프사이클과 독립적으로 관리되어 Pod가 삭제되면 함께 삭제된다.

#### hostPath
* 호스트 머신의 파일 시스템 경로를 사용하여 데이터를 저장하는 볼륨이다.
* 호스트와 Pod간에 데이터를 공유할 때 사용된다.
* 호스트 머신의 파일 시스템을 사용하므로 해당 파일 시스템에 저장된 데이터는 유지된다.

#### Persistent Volume
* 클러스터에서 관리되는 지속적인 데이터를 저장하는 볼륨이다.
* Pod가 삭제되어도 데이터가 유지된다.
* Pod의 라이프사이클과 독립적으로 관리되어 Pod가 삭제되더라도 데이터는 보존된다.

### Volume 사용 방법
* Pod의 스펙에 볼륨을 정의하고 컨테이너 내에서 마운트하여 데이터를 사용할 수 있다.
* 동일한 Pod내에서 여러 컨테이너가 동일한 볼륨을 공유하여 데이터를 교환할 수 있다.
* StatefulSet을 통해 영구적인 데이터를 저장하기에 적합한 볼륨을 사용할 수 있다.

## Helm
* Helm은 Kubernetes 애플리케이션을 손쉽게 배포, 업데이트, 관리하기 위한 패키지 매니저이다.
* Chart라는 패키지 형식을 사용하며, 이를 통해 복잡한 애플리케이션을 간단한 명령어로 관리할 수 있다.

### Chart
* Kubernetes 애플리케이션을 설명하는 패키지이다.
* chart는 Kubernetes 리소스들을 효과적으로 관리할 수 있도록 사전에 정의된 템플릿을 포함하고 있다.
* chart는 애플리케이션의 배포, 업데이트, 삭제 등을 단순화한다.

### 동작 원리
* Helm은 클라이언트-서버 모델을 기반으로 한다.
> Helm 클라이언트
> 
> * Helm 클라이언트는 사용자가 명령을 실행하고 Helm차트를 조작하는 인터페이스를 제공한다.
> * 사용자는 Helm 클라이언트를 사용하여 새로운 차트를 설치하거나 기존 차트를 업그레이드하고, 릴리즈를 관리하며 차트를 검색하고 공유 가능한 저장소를 관리할 수 있다.
> 
> Tiller 서버
> 
> * Tiller는 Helm 클라이언트와 Kubernetes API간의 인터페이스로 작동하는 서버 컴포넌트다
> * 클라이언트의 명렁을 받아 Kubernetes 클라스터에서 차트를 설치하고 릴리즈를 관리하며, 업그레이드하는 작업을 수행한다.
> * 각 사용자는 자신의 Tiller 인스턴스를 갖게되며, 사용자의 Kubernetes 네임스페이스에 배포된다.

* 사용자가 Helm 클라이언트를 사용하여 차트를 설치하면 클라이언트는 Tiller 서버에 요청을 전송한다.
  * Tiller는 차트를 Kubernetes 클러스터에 설치하고 해당 차트에 정의된 리소스를 생성한다.
  * 클라이언트는 Tiller를 통해 설치 프로세스의 진행 상황을 추적하고 확인할 수 있다.
* 사용자가 Helm 클라이언트를 사용하여 기존 차트를 업그레이드하면 클라이언트는 Tiller에 업그레이드 요청을 전송한다.
  * Tiller는 업그레이드된 차트를 Kubernetes 클러스터에 배포하고 업그레이드된 리소스를 생성한다.
  * 클라이언트는 Tiller를 통해 업그레이드 프로세스의 진행 상황을 추적하고 확인할 수 있다.
* Helm은 릴리즈를 중앙에서 추적하고 관리한다.
  * 각 릴리즈는 Helm 클라이언트와 Tiller 서버 간에 유지된다.
* Helm은 차트를 공유할 수 있는 저장소를 제공하며 사용자는 Helm 클라이언트를 사용하여 저장소에서 차트를 검색하고 가져올 수 있다.

## kubeconfig
* 클러스터와의 상호작용을 설정하는 구성 파일이다.
* 다양한 클러스터 및 사용자 구성을 저장하며, 주로 kubectl과 같은 Kubernetes 클라이언트 도구가 이 파일을 참조하여 클러스터와 통신한다.
  * 기본적으로 kubectl은 홈 디렉토리의 .kube디렉토리에 있는 config파일을 사용하지만, --kubeconfig 플래그를 사용해 다른 위치에 있는 구성파일을 지정할 수 있다.

### 구성 요소
#### clusters
* 클라스터에 대한 정보를 정의한다.
* 각 클러스터는 name과 해당 클러스터에 대한 연결 정보를 제공한다.
  * API서버의 URL과 인증서 관련 설정 등

#### users
* 사용자에 대한 정보를 정의한다.
  * name과 사용자가 사용하는 인증서 및 키 등을 포함한다.

#### constexts
* 작업중인 클러스터, 사용자, 네임스페이스 등을 결합하여 컨텍스트를 정의한다.
* 각 컨텍스트는 name과 해당 컨텍스트에서 사용할 클러스터 및 사용자를 지정한다.

#### current-context
* 현재 활성화된 컨텍스트의 이름을 지정한다.
  * 현재 작업중인 Kubernetes 환경을 식별한다.

## RBAC(Role-Based Access Control)
* RBAC는 쿠버테니스 클러스터 내에서의 사용자 및 서비스 계정에 대한 권한을 정의하고 관리하는 메커니즘이다.
* RBAC를 사용하면 특정 작업이나 자원에 대한 액세스를 세밀하게 제어할 수 있다.

### Role
* Role은 특정 네임스페이스 내에서의 권한을 정의한다.
  * 예시로, 특정 네임스페이스에서 Pod를 생성하거나, Service를 삭제하는 권한을 가진 역할을 생성할 때 활용될 수 있다.

### ClusterRole
* 클러스터 전체에서 적용되는 권한을 정의한다.
* 네임스페이스에 제한되지 않으므로 클러스터 전체에서 리소스에 대한 액세스 권한을 설정할 수 있다.
  * 예시로, 모든 네임스페이스에서의 모든 Pod를 조회하거나, 클러스터 전체에서 ConfigMap을 수정하는 권한을 주고자 할 때 활용될 수 있다.

### RoleBinding
* 사용자나 그룹에 Role을 할당하는데 사용된다.
* 특정 네임스페이스에 있는 Role을 특정 사용자 또는 그룹에 바인딩할 수 있다.
  * 예시로, 특정 팀에게 특정 네임스페이스에서 Pod를 생성할 권한을 주고자 할 때 활용될 수 있다.

### ClusterRoleBinding
* 사용자나 그룹에 ClusterRole을 할당하는데 사용된다.
* 클러스터 전체에서의 권한을 설정할 때 사용한다.
  * 예시로, 특정 팀에게 클러스터 전체의 로그 조회 권한을 주고자 할 떄 활용될 수 있다.


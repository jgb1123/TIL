# MSA
## MSA?
* 마이크로서비스 아키텍처는 소프트웨어 아키텍처의 한 유형으로, 큰 애플리케이션을 작은 서비스로 분할하는 구조이다.
* 각 서비스들은 특정 기능 또는 업무를 담당하며 독립적으로 배포, 확장 및 유지보수할 수 있다.
* 이러한 서비스는 주로 경량 프로세스 또는 컨테이너로 실행되며, 서로 통신하여 전체 애플리케이션을 구성한다.

### 등장배경
* 기존 Monolithic Architecture의 경우 모든 구성요소가 한 프로젝트에 통합되어있는 구조이다.
* Monolithic은 유지보수가 편하고 구현이 간단하다는 장점이 있지만, 명확한 단점들이 존재한다.
  * 부분 장애가 전체 서비스의 장애로 확장될 수 있음
  * 전체 시스템 구조의 파악이 어려움
  * 서비스 변경이 서렵고 수정이 사이드 이펙트를 일으킬 가능성이 있음
  * 서비스 규모가 커질수록 빌드 및 테스트 배포 시간이 증가함
  * 서비스의 특정 부분만을 위한 스케일 아웃이 어려움
* 이러한 Monolithic Architecture의 한계를 극복하기 위해 MSA가 등장했다.

#### 비즈니스 측면
* 비즈니스 환경은 점점 빠르게 급변하며 경쟁이 치열해지고 있다.
* 비즈니스가 IT 기술에 의존하는 케이스가 많아졌다.
* 많은 기업들이 유연하고 민첩한 IT기술 없이 비즈니스의 빠른 변화와 성장을 달성하기 어려워지고 있다.

#### 기술적 측면
* Cloud의 발전
  * MSA는 전체적인 토폴로지가 복잡하기 때문에 전통적인 인프라 환경에서 운영하기 어렵다.
  * Cloud 환경은 탄력적이며 확장성 높게 운영이 가능하여 MSA발전에 큰 도움이 됐다.
* NoSQL의 안정화와 급부상
  * MSA 서비스들은 각각의 목적에 맞는 서로 다른 저장기술을 사용할 수 있다.
  * NoSQL이 발전되고 안정화되면서 선택할 수 있는 데이터베이스의 폭이 넓어졌다.
* Docker, Kubernetes
  * 이러한 기술들의 발전으로 거대한 MSA서비스를 쉽게 배포하고 실행할 수 있게 되었다.
* Netflix OSS
  * MSA를 적용하기 위해 넘어야 하는 여러 과제를 오픈소스 프로젝트를 통해 비교적 쉽게 해결할 수 있게 되었다.
* 이미 많은 기업들의 성공 사례적인 사례와 Best Practice를 제시하고 있다.

### MSA 장점
* 작은 서비스로 애플리케이션을 분할하므로 각 서비스는 특정 기능을 담당한다.
  * 코드 베이스를 작게 유지할 수 있고, 개별 서비스를 쉽게 개발, 유지보수 및 확장할 수 있다.
* 각 마이크로서비스는 독립적으로 배포될 수 있으며 다른 서비스와의 관계나 변경사항이 다른 서비스에 영향을 미치지 않는다.
  * 릴리즈 주기가 빨라지고 개발팀이 서로 간섭하지 않고 작업할 수 있다.
* 필요에 따라 특정 서비스를 별도로 확장할 수 있어 리소스를 효율적으로 활용할 수 있다.
  * 트래픽 부하가 서비스간에 불규칙하게 분산되는 상황에 유용하다.
* 각 마이크로서비스는 자체적으로 기술스택과 데이터베이스를 선택할 수 있다.
  * 새로운 기술의 도입과 기존 기술의 유지보수를 용이하게 한다.
* 서비스간의 결함 격리가 용이하며, 하나의 서비스의 장애가 전체 시스템에 영향을 미치지 않게 한다.
* 마이크로서비스는 팀과 업무별로 분배할 수 있어 조직의 구조나 개발 방법을 유연하게 조정할 수 있다.
* API를 통해 서비스간 통신을 지원하므로 외부 시스템과의 통합이 쉽고 다른 애플리케이션과 상호작용할 수 있다.

### MSA 단점
* 여러 개의 서비스로 애플리케이션을 분힐하므로 서비스간 통신, 서비스 디스커버리, 로드 밸런싱, 로깅 및 모니터링 등을 구현하는 복잡성이 증가한다.
  * 이로인해 초기 설정 및 관리가 어려울 수 있다.
* 서비스간의 상호 작용을 효과적으로 테스트하고 디버깅하기 어려울 수 있다.
  * 전체 시스템의 통합 테스트 역시 복잡해진다.
* 서비스간 통신은 네트워크 부하와 대역폭 사용량을 증가시킬 수 있다.
  * 느린 네트워크 연결로 인한 성능 저하가 발생할 수 있다.
* 서비스 간의 통신 및 데이터 보안은 중요한 문제가 될 수 있다.
  * 보안에 대한 추가적인 노력이 필요하다.
* 트랜잭션 관리가 힘들다.
* 각 서비스가 독립적으로 실행되므로 메모리, CPU, 저장 공간 등의 리소스를 더 많이 소비할 수 있다.
* **따라서 MSA의 도입 전 프로젝트의 목표, 요구사항, 인프라 및 팀의 능력을 고려하여 이러한 단점들을 극복할 방안을 충분히 고려해야 한다.**

## MSA 단점 보완
* MSA의 여러 단점들을 보완하기 위해 사용되는 여러가지 기술들이 있다.

### 서비스 디스커버리
* MSA환경에서 수많은 서비스들이 자동 스케일링, 확장 등 서비스 인스턴스가 수시로 생성되고 소멸되기를 반복하게 되고, 계속해서 변경되는 서비스를 식별해서 호출하기는 상당히 어려울 수 있다.
* 이렇게 많아진 서비스들을 유지 관리하기 위해 서비스 디스커버리 패턴을 적용할 수 있다.
* 서비스 디스커버리는 서비스 인스턴스를 식별하여 서비스를 등록하고 등록한 서비스의 검색을 수행한다.
* 서비스 디스커버리의 동작 방식에 따라 Client Side, Server Side 방식이 존재한다.

#### Client Side Discovery
* 생성된 서비스는 Service Registry에 등록하고, 서비스를 사용할 클라이언트가 Service Registry에서 서비스의 위치를 찾아 호출하는 방식이다.
* 대표적인 예시로 Netflix Eureka가 있다.
##### 장점
* 클라이언트가 사용 가능한 서비스 인스턴스에 대해 알고 있기 때문에, 각 서비스별 로드밸런싱을 구현할 수 있다.
* 상대적으로 구현이 간단하다.
##### 단점
* 클라이언트와 서비스 레지스트리 사이의 의존성이 생긴다.
* 서비스 클라이언트에서 사용하는 각 프로그래밍 언어 및 프레임워크에 대해서 클라이언트 측 service discovery 로직을 구현해야 한다.


#### Server Side Discovery
* 서비스를 사용할 클라이언트와 Service Registry 사이에 Proxy서버인 Load Balancer를 두는 방식이다.
* 클라이언트는 Load Balancer에 서비스를 요청하고 Load Balancer가 Service Registry에 호출할 서비스의 위치를 질의하는 방식이다.
* 대표적인 예시로 AWS의 ELB나 GCP의 로드밸런서가 대표적이다.

##### 장점
* discovery의 세부 사항이 클라이언트로부터 분리되어있다.
* 클라이언트는 단순히 로드 밸런서에 요청만 하기 때문에, 프로그래밍 언어 및 프레임워크에 대한 검색 로직을 구현할 필요가 없다.

##### 단점
* 로드밸런서가 배포환경에서 제공되어야 한다.
* 로드밸런서가 제공되어있지 않다면 설정 및 관리해야하는 또 다른 시스템 구성 요소가 되어버린다.

#### Kubernetes에서의 Service Discovery?
##### DNS 이용
* 서비스는 생성되면 `[서비스명].[네임스페이스명].svc.cluster.local` 이라는 DNS명으로 쿠버네티스 내부 DNS에 등록된다.
* 쿠버네티스 클러스터 내부에서는 이 DNS명으로 서비스에 접근이 가능하며, 이 때 DNS에서 리턴해주는 IP는 외부 IP가 아니라 Cluster IP이다.

##### External IP 지정
* 외부 IP를 명시적으로 지정하는 방식이 있다.
* 쿠버네티스 클러스터에서는 외부 IP를 별도로 관리하지 않기 때문에 이 IP는 외부에서 명시적으로 관리되어야 한다.

##### AWS, GCP가 제공하는 LB를 이용
* 퍼블릭 클라우드의 경우 이 방식보다는 클라우드 내의 로드 밸런서를 붙이는 방법을 사용한다.
* 서비스에 정적 IP를 지정하기 위해선 정적IP를 생성해야 한다.
* VPC메누의 External IP 메뉴애서 생성해도 되고, CLI를 이용해 생성할 수 있다.
* 이 IP는 서비스가 삭제되더라도 계속 유지되고 재사용이 가능하다.
* 타입을 LoadBalancer로 하고, loadBalancer IP부분에 생성한 정적 IP를 할당하면된다.

### API Gateway
* API Gateway는 API서버 앞단에서 모든 API서버들의 엔드포인트를 단일화하여 묶어주며, 클라이언트와 서비스 간의 통신을 관리하여 복잡성을 줄여주고 보안, 성능을 향상시키며 시스템 관리를 용이하게 해준다.
* API Gateway는 ESB(Enterprise Service Bus)에서부터 시작되었다.
  * ESB의 대부분의 컨셉을 많이 계승했으며, ESB의 실패와 단점을 보완해 만들어졌다.

#### 단일 진입점
* MSA환경에서는 여러 개의 독립적인 마이크로 서비스가 존재하며, 각각은 자체 API를 제공한다.
* API Gateway는 클라이언트에게 단일 진입점을 제공하여 클라이언트가 서비스 내부 구조를 알 필요 없이 통합된 인터페이스를 통해 모든 서비스에 접근할 수 있게 한다.

#### 라우팅 및 로드밸런싱
* API Gateway는 클라이언트 요청을 적절한 마이크로서비스로 라우팅하고 로드밸런싱을 수행하여 서비스간의 부하를 균형있게 분산시켜 성능을 최적화한다.
* 서비스의 가용성과 성능을 최적화할 수 있다.

#### 인증과 권한 부여
* API Gateway는 클라이언트 요청을 검증하고 인증 및 권한 부여를 수행한다.
* 보안을 강화하고 비인가된 요청을 차단하는데 도움을 준다.

#### API 관리
* API Gateway는 API 버전 관리, API 문서화, 서비스 디스커버리 및 API 게이트웨이 관리 도구를 제공하여 API 관리를 간편하게 한다.

#### 요청 및 응답 변환
* 서로 다른 마이크로서비스가 다양한 데이터 형식을 사용할 수 있다.
* 따라서 API Gateway는 클라이언트와 서비스 간의 데이터 형식 및 구조를 변환할 수 있다.
* 클라이언트 요청과 서비스 응답을 조정하고 일치시키는 데 도움을 준다.

#### 로깅과 모니터링
* API Gateway는 클라이언트 요청과 서비스 응답을 로깅하고 모니터링 하여 시스템의 상태와 성능을 추적하며 문제를 식별하고 해결하는 데 도움을 준다.
* 이를 통해 시스템의 트래픽과 동작을 신시간으로 감시하고 문제를 발견하기 쉬워진다.

#### 보안 강화
* 보안 계층을 제공하여 데이터 통신을 암호화하고 DDoS 공격 및 기타 보안 위협을 탐지하고 대응할 수 있다.
* SSL/TLS를 사용하여 데이터 보안을 강화하고 API 보안 정책을 시행한다.

### Config Management
* 마이크로서비스는 서로 다른 업무 기능을 수행하며 각각 독립적으로 배포, 확장 및 관리된다.
* MSA는 이러한 많은 작은 마이크로서비스로 구성되며 각 서비스는 독립적으로 환경 설정이 필요하다.
* Config Management는 각 마이크로서비스의 설정을 중앙화하여 관리할 수 있다.
* MSA의 핵심 요소 중 하나로 각 마이크로서비스가 제대로 동작하고 상호작용 할 수 있도록 환경설정을 효과적으로 관리하는데 필수적이다.

#### 환경 설정 관리
* 각 마이크로서비스의 환결 설정, 데이터베이스 연결 정보, 외부 서비스 엔드포인트 등과 같은 중요한 구성 값을 관리한다.
* 마이크로 서비스가 다른 환경에서 동일한 코드로 배포될 때 설정을 쉽게 변경하고 관리할 수 있다.
* 또한 실시간으로 환경 설정을 업데이트 하고 필요한 경우 동적으로 변경할 수 있는 기능도 제공한다. (Spring Cloud Config + Spring Cloud Bus)
* 마이크로 서비스가 설정을 조정하고 반영할 수 있어 서비스의 가용성과 성능을 최적화하는 데 도움이 된다.

#### 버전 관리 및 비교
* 중앙화된 구성 저장소는 각 마이크로서비스의 설정 버전을 관리하고, 이전 버전과의 비교가 가능하다.
* 설정 변경에 대한 오류를 식별하고 복구하기 위한 중요한 기능이다.

#### 보안 및 액세스 제어
* 중앙화된 구성 저장소는 보안을 강화하기 위한 액세스 제어를 제공한다.
* 민감한 정보와 비밀 설정을 안전하게 보호하고, 권한 부여 및 인증 메커니즘을 통해 접근을 제어할 수 있다.

#### 모니터링
* 설정 변경에 대한 모니터링과 경고 기능을 사용할 수 있다.
* 설정의 이상한 동작을 식별하고 이에 대한 경고를 생성하여 조치를 취할 수 있다.

#### 확장성
* 서비스가 확장될 때 구성도 쉽게 복제하고 적용할 수 있다.

#### 대표 예시
##### Spring Cloud Config
* 마이크로서비스를 위한 외부 구성 소스를 제공한다.
* 중앙화된 설정 서버로 구성된 설정 파일을 제공하고 마이크로서비스는 이 설정 서버에서 구성을 가져와 사용할 수 있다.
* 개발자 및 운영팀은 외부 구성 파일을 중앙화된 저장소에서 관리하고 변경 사항을 쉽게 추적하고 롤백할 수 있다.
* Spring Cloud Bus와 함게 사용하면 변경된 구성 값을 서버 재시작 없이 Reload 할 수 있으며 확장된 기능을 제공한다.


##### Kubernetes Configmap, Secrets
* Kubernetes 환경에서 환경 설정 데이터를 관리하는데 사용되며, YAML형식의 데이터를 저장하고 이를 Pod 내에서 환경 변수 또는 볼륨으로 주입할 수 있다.
* ConfigMap은 주로 클러스터 레벨의 설정을 관리하고, 애플리케이션 레벨에서는 단순한 설정을 관리할 수 있다.
* Spring Cloud Config를 사용하면 애플리케이션 단에서 더 많은 기능들을 이용할 순 있지만, 단순한 설정같은 경우 Configmap만으로도 충분하다.

### 모니터링, 로깅, 트레이싱
* MSA 환경에서는 수많은 서비스들이 분산되어 있기 때문에 각각의 서비스를 관리하기에는 굉장히 힘들다.
* 그렇기 때문에 모든 로그들을 한눈에 볼 수 있도록 구성해야 문제가 생겼을 때 빠른 대처가 가능하다.
* 또한 서비스의 확장성과 가용성을 확인하여 리소스를 효과적으로 관리할 수 있게 한다.

#### 모니터링
* 인프라 및 응용프로그램의 성능이나 효율성을 확인하는 작업으로, 각 서비스에서 수집한 Metric정보를 통해 리소스의 사용률, 트래픽 등을 수치로 표현하는 기능이다.
* 자체적으로 시각화하여 수치와 그래프로 보여주기도 하지만, 더 상세하고 다양한 기능들을 위해 시각화 도구와 연동하여 사용하기도 한다.
* Metric 정보를 수집하는 방법에는 Push 방식과 Pull 방식이 있다.


> Push-based System
> * 애플리케이션에서 필요한 데이터들을 직접 모니터링 시스템으로 보내주는 방식이다.
> * 수집 대상이 Auto-Scaling 등으로 가변적일 때 Push 방식이 유리하다.
> * Push방식에서는 모니터링 시스템에 수집데이터를 보내주면 되기 때문에 새로운 애플리케이션이 추가되더라도 수집데이터를 보내주기만 하면 된다.
> * 하지만 Metric을 중앙에서 정의하기 때문에 새로운 Metric을 수용하기 위해선 중앙서버에 계속적으로 변경사항을 반영해줘야 한다.

> Pull-based System
> * 모니터링 시스템에서 모니터링할 애플리케이션에 직접 접속하여 필요한 데이터를 가져가는 방식이다.
> * 애플리케이션에서 직접 데이터를 가져오기 때문에 각 애플리케이션에서 부담이 덜하지만, Pull 해야되는 목록을 관리해야 한다.

##### TICK Stack (Telegraf + InfluxDb + Chronograf + Kapacitor)
* influxData가 개발한 오픈소스 모니터링 및 이벤트 데이터 시계열 플랫폼이다.
* Telegraf : 데이터 수집을 위한 경량의 에이전트로, 다양한 데이터 소스에서 데이터를 수집하고 influxDB에 보낸다.
* InfluxDb : 시계열 데이터베이스로, 수집한 데이터를 저장하고 질의할 수 있다.
* Chronograf : 데이터 시각화 및 대시보스 작성을 위한 웹 기반 인터페이스다.
* Kapacitor : 이벤트 처리 및 경고 시스템을 구축하기 위한 데이터 스트림 처리 엔진이다.

##### Prometheus + Grafana
* Prometheus는 오픈소스 시계열 데이터베이스 및 모니터링 시스템으로, 서버 및 애플리케이션 성능 데이터를 수집하고 저장하는데 사용된다.
* 서버, 컨테이너, 애플리케이션과 같은 다양한 소스로부터 수집한 메트릭 데이터를 저장한다.
* Pull 방식으로 데이터를 수집하며 Exporter를 사용해 다양한 데이터 소스로부터 Metric을 수집한다.
* PromQL이라는 질의언어를 제공하며, 이를 사용해 데이터를 조회하고 경고 규칙등을 정의할 수 있다.
* Grafana는 데이터 시각화 및 대시보드 작성을 위한 오픈소스 플랫폼이다.
* Grafana 대시보드를 구성하여 데이터를 시각화하고, 복잡한 대시보드를 만들 수 있으며, 이를 통해 성능을 모니터링하고 문제를 식별할 수 있다.

##### DataDog
* 클라우드 기반의 모니터링 및 분석 플랫폼이다.
* 애플리케이션 및 인프라스트럭처 성능 데이터를 수집하고 시각화 및 분석을 제공해준다.
* 다양한 클라우드 서비스 및 기술 스택과 통합하여 사용할 수 있다.
* Datadog를 통해 대시보드, 경고, 분석 등을 설정하여 시스템 및 애플리케이션의 성능을 모니터링하고 문제를 식별할 수 있다.

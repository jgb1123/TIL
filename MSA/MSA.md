# MSA
## MSA?
* 마이크로서비스 아키텍처는 소프트웨어 아키텍처의 한 유형으로, 큰 애플리케이션을 작은 서비스로 분할하는 구조이다.
* 각 서비스들은 특정 기능 또는 업무를 담당하며 독립적으로 배포, 확장 및 유지보수할 수 있다.
* 이러한 서비스는 주로 경량 프로세스 또는 컨테이너로 실행되며, 서로 통신하여 전체 애플리케이션을 구성한다.

### 등장배경
* 기존 Monolithic Architecture의 경우 모든 구성요소가 한 프로젝트에 통합되어있는 구조이다.
* Monolithic은 유지보수가 편하고 구현이 간단하다는 장점이 있지만, 명확한 단점들이 존재한다.
  * 부분 장애가 전체 서비스의 장애로 황장될 수 있음
  * 전체 시스템 구조의 파악이 어려움
  * 서비스 변경이 서렵고 수정이 사이드 이펙트와 같은 영향을 파악이 힘듬
  * 서비스가 커지면 커질수록 빌드 시간 및 테스트 배포 시간이 많이 길어짐
  * 서비스의 특정 부분만을 위한 스케일 아웃이 어려움
* 이러한 Monolithic Architecture의 한계를 극복하기 위해 MSA가 등장했다.

### MSA 장점
* 작은 서비스로 애플리케이션을 분할하므로 각 서비스는 특정 기능을 담당한다.
  * 코드 베이스를 작게 유지할 수 있고, 개별 서비스를 쉽게 개발, 유지보수 및 확장할 수 있다.
* 각 마이크로서비스는 독립적으로 배포될 수 있으며 다른 서비스와의 관계나 변경사항이 다른 서비스에 영향을 미치지 않는다.
  * 릴리즈 주기가 빨라지고 개발팀이 서로 간섭하지 않고 작업할 수 있다.
* 필요에 따라 특정 서비스를 별도로 확장할 수 있어 리소스를 효율적으로 활용할 수 있다.
  * 트래픽 부하가 서비스간에 불규칙하게 분산되는 상황에 유용하다.
* 각 마이크로서비스는 자체적으로 기술스택과 데이터베이스를 선택할 수 있다.
  * 새로운 기술의 도입과 기존 기술의 유지보수를 용이하게 한다.
* 서비스간의 결함 격리가 용이하며, 하나의 서비스의 장애가 전체 시스템에 영향을 미치지 않게 한다.
* 마이크로서비스는 팀과 업무별로 분배할 수 있어 조직의 구조나 개발 방법을 유연하게 조정할 수 있다.
* API를 통해 서비스간 통신을 지원하므로 외부 시스템과의 통합이 쉽고 다른 애플리케이션과 상호작용할 수 있다.

### MSA 단점
* 여러 개의 서비스로 애플리케이션을 분힐하므로 서비스간 통신, 서비스 디스커버리, 로드 밸런싱, 로깅 및 모니터링 등을 구현하는 복잡성이 증가한다.
  * 이로인해 초기 설정 및 관리가 어려울 수 있다.
* 서비스간의 상호 작용을 효과적으로 테스트하고 디버깅하기 어려울 수 있다.
  * 전체 시스템의 통합 테스트 역시 복잡해진다.
* 서비스간 통신은 네트워크 부하와 대역폭 사용량을 증가시킬 수 있다.
  * 느린 네트워크 연결로 인한 성능 저하가 발생할 수 있다.
* 서비스 간의 통신 및 데이터 보안은 중요한 문제가 될 수 있다.
  * 보안에 대한 추가적인 노력이 필요하다.
* 트랜잭션 관리가 힘들다.
* 각 서비스가 독립적으로 실행되므로 메모리, CPU, 저장 공간 등의 리소스를 더 많이 소비할 수 있다.
* **따라서 MSA의 도입 전 프로젝트의 목표, 요구사항, 인프라 및 팀의 능력을 고려하여 이러한 단점들을 극복할 방안을 충분히 고려해야 한다.**

## MSA 단점 보완
* MSA의 여러 단점들을 보완하기 위해 사용되는 여러가지 기술들이 있다.

### 서비스 디스커버리
* MSA환경에서 수많은 서비스들이 자동 스케일링, 확장 등 서비스 인스턴스가 수시로 생성되고 소멸되기를 반복하게 되고, 계속해서 변경되는 서비스를 식별해서 호출하기는 상당히 어려울 수 있다.
* 이렇게 많아진 서비스들을 유지 관리하기 위해 서비스 디스커버리 패턴을 적용할 수 있다.
* 서비스 디스커버리는 서비스 인스턴스를 식별하여 서비스를 등록하고 등록한 서비스의 검색을 수행한다.
* 서비스 디스커버리의 동작 방식에 따라 Client Side, Server Side 방식이 존재한다.

#### Client Side Discovery
* 생성된 서비스는 Service Registry에 등록하고, 서비스를 사용할 클라이언트가 Service Registry에서 서비스의 위치를 찾아 호출하는 방식이다.
* 대표적인 예시로 Netflix Eureka가 있다.
##### 장점
* 클라이언트가 사용 가능한 서비스 인스턴스에 대해 알고 있기 때문에, 각 서비스별 로드밸런싱을 구현할 수 있다.
* 상대적으로 구현이 간단하다.
##### 단점
* 클라이언트와 서비스 레지스트리 사이의 의존성이 생긴다.
* 서비스 클라이언트에서 사용하는 각 프로그래밍 언어 및 프레임워크에 대해서 클라이언트 측 service discovery 로직을 구현해야 한다.


#### Server Side Discovery
* 서비스를 사용할 클라이언트와 Service Registry 사이에 Proxy서버인 Load Balancer를 두는 방식이다.
* 클라이언트는 Load Balancer에 서비스를 요청하고 Load Balancer가 Service Registry에 호출할 서비스의 위치를 질의하는 방식이다.
* 대표적인 예시로 AWS의 ELB나 GCP의 로드밸런서가 대표적이다.

##### 장점
* discovery의 세부 사항이 클라이언트로부터 분리되어있다.
* 클라이언트는 단순히 로드 밸런서에 요청만 하기 때문에, 프로그래밍 언어 및 프레임워크에 대한 검색 로직을 구현할 필요가 없다.

##### 단점
* 로드밸런서가 배포환경에서 제공되어야 한다.
* 로드밸런서가 제공되어있지 않다면 설정 및 관리해야하는 또 다른 시스템 구성 요소가 되어버린다.

#### Kubernetes에서의 Service Discovery?
##### DNS 이용
* 서비스는 생성되면 `[서비스명].[네임스페이스명].svc.cluster.local` 이라는 DNS명으로 쿠버네티스 내부 DNS에 등록된다.
* 쿠버네티스 클러스터 내부에서는 이 DNS명으로 서비스에 접근이 가능하며, 이 때 DNS에서 리턴해주는 IP는 외부 IP가 아니라 Cluster IP이다.

##### External IP 지정
* 외부 IP를 명시적으로 지정하는 방식이 있다.
* 쿠버네티스 클러스터에서는 외부 IP를 별도로 관리하지 않기 때문에 이 IP는 외부에서 명시적으로 관리되어야 한다.

##### AWS, GCP가 제공하는 LB를 이용
* 퍼블릭 클라우드의 경우 이 방식보다는 클라우드 내의 로드 밸런서를 붙이는 방법을 사용한다.
* 서비스에 정적 IP를 지정하기 위해선 정적IP를 생성해야 한다.
* VPC메누의 External IP 메뉴애서 생성해도 되고, CLI를 이용해 생성할 수 있다.
* 이 IP는 서비스가 삭제되더라도 계속 유지되고 재사용이 가능하다.
* 타입을 LoadBalancer로 하고, loadBalancer IP부분에 생성한 정적 IP를 할당하면된다.

### API Gateway
* API Gateway는 API서버 앞단에서 모든 API서버들의 엔드포인트를 단일화하여 묶어주며, 클라이언트와 서비스 간의 통신을 관리하여 복잡성을 줄여주고 보안, 성능을 향상시키며 시스템 관리를 용이하게 해준다.
* API Gateway는 ESB(Enterprise Service Bus)에서부터 시작되었다.
  * ESB의 대부분의 컨셉을 많이 승계했으며, ESB의 실패와 단점을 보완해 만들어졌다.

#### 단일 진입점
* MSA환경에서는 여러 개의 독립적인 마이크로 서비스가 존재하며, 각각은 자체 API를 제공한다.
* API Gateway는 클라이언트에게 단일 진입점을 제공하여 클라이언트가 서비스 내부 구조를 알 필요를 없게 한다.
* 클라이언트는 하나의 엔드포인트를 통해 모든 서비스에 액세스할 수 있다.

#### 라우팅 및 로드밸런싱
* API Gateway는 클라이언트 요청을 적절한 마이크로 서비스로 아누팅하고 로드밸런싱을 수행하여 다수의 서비스를 인스턴스 간 요청을 분배한다.
* 서비스의 가용성과 성능을 최적화하며 부하를 분산시킨다.

#### 인증과 권한 부여
* API Gateway는 클라이언트 요청을 검증하고 인증 및 권한 부여를 수행한다.
* 보안을 강화하고 비인가된 요청을 차단하는데 도움을 준다.


# 클린 코드
## 1. 깨끗한 코드
### 코드가 존재하리라
* 코드는 요구사항을 상세히 표현하는 수단이다.
* 어느 수준에 이르면 코드의 도움 없이 요구사항을 상세히 표현하기는 불가능하다.
* 추상화도 불가능하다.
* 고도로 추상화된 언어나 특정 응용 분야 언어로 기술하는 명세 역시 코드이므로 결코 코드는 사라지지 않는다.

### 나쁜 코드
* killer app 하나로 대박난 회사가 망한일이 있었다.
  * 그 원인은 나쁜 코드였다.
  * 출시에 바빠 코드를 대책없이 짜서 기능을 추가할수록 코드가 점점 엉망이 되었기 때문이다.
* 우리는 나쁜 코드들을 방치하고 나중에 수정하기로 마음먹고 넘어가지만, 그 나중은 결코 오지 않는다. (르블랑의 법칙 - 나중은 결코 오지 않는다.)

### 나쁜 코드로 치르는 대가
* 나쁜 코드가 쌓일 수록 팀의 생산성은 떨어지게 된다.
* 나쁜 코드는 코드를 고칠 때마다 또 다른 엉뚱한 곳에서 문제가 생긴다.
* 생산성을 증가시키기 위해 투입되는 신규 인력들은 시스템 설계 의도를 분명하게 알지 못해 더 많은 나쁜 코드들을 양산하게 된다.
#### 원대한 재설계의 꿈
* 나쁜 코드에 의해 생산성이 바닥이 되면 되면 재설계를 하는 경우가 생긴다.
* 그러나 이 경우 기존 시스템 기능을 모두 제공하는 새 시스템을 만들며 기존 시스템에 가해지는 변경사항까지 모두 반영해야 한다.
* 새 시스템이 기존 시스템을 따라 잡을 때 쯤이면 재설계팀은 팀을 떠나고, 새로운 팀원들이 새 시스템을 설계하고자 한다.
* 바로 현재 시스템이 너무 엉망이기 때문이다.
* 따라서 이러한 문제를 일으키지 않기 위해 처음부터 깨끗한 코드를 만들어야 한다.

#### 태도
* 나쁜 코드의 위험을 이해하지 못하는 관리자의 말을 그대로 따르는 행동은 전문가 답지 못하다.
* 나쁜 코드가 되는 이유는 요구사항과 일정, 관리자와 마케팅등의 잘못이라고 할 수 없고, 개발자가 전문가 답지 못했기 때문이다.
* 프로젝트 실패는 개발자에게도 큰 책임이 있고, 특히 나쁜 코드가 초래하는 실패에는 더더욱 책임이 크다.

#### 원초적 난제
* 개발자가 기한을 맞추려면 나쁜코드를 양산할 수 밖에 없는건 아니다.
* 오히려 나쁜코드를 양산하면 기한을 맞추지 못한다.
* 기한을 맞추는 유일한 방법은 언제나 코드를 깨끗하게 유지하는 습관이다.

#### 깨끗한 코드라는 예술?
* 깨끗한 코드가 무엇인지 모르면 깨끗한 코드를 만들려고 노력해봤자 소용 없다.
* 깨끗한 코드를 작성하려면 청결이라는 힘겹게 습득한 감각을 활용해 다양한 기법들을 적용하는 절제와 규율이 필요하며, 그 열쇠는 코드 감각이다.
* 코드 감각이 있으면 좋은 코드와 나쁜 코드를 구분할 수 있다.
* 코드 감각이 있으면 절제와 규율을 적용해 나쁜 코드를 좋은 코드로 바꾸는 전략도 파악할 수 있다.

#### 깨끗한 코드란?
* 나는 깨끗한 코드란 코드의 성능이 좋으면서도 코드의 가독성이 좋은 코드라고 생각한다. 
* 하지만 이 질문에 대한 답은 모든 개발자들이 생각하는게 다를 것이다.
* 다음은 각 분야의 유명한 개발자들의 깨끗한 코드에 대한 의견이다.
##### 비야네 스트롭스트룹
* C++의 창시자이자이며, C++ Programing Language의 저자이다.
> "나는 우아하고 효율적인 코드를 좋아한다. 논리가 간단해야 버그가 숨어들지 못한다. 성능을 최적으로 유지해야 사람들이 원칙없는 최적화로 코드를 망치려는 유혹에 빠지지 않는다. 깨끗한 코드는 한 가지를 제대로 한다."

##### 그래디 부치
* UML을 개발하였으며, object oriented design: with applications의 저자이다.
> "깨끗한 코드는 단순하고 직접적이다. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다. 깨끗한 코드는 설계자의 의도를 숨기지 않는다. 오히려 명쾌한 추상화와 단순한 제어문으로 가득하다."

##### 데이브 토마스
* OTI 창립자이자 이클립스 전략의 대부이다.
> "깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다. 깨끗한 코드에는 의미 있는 이름이 붙는다. 특정 목적을 달성하는 방법은 하나만 제공한다.의존성은 최소이며 각 의존성을 명확히 정의한다. API는 명확하며 최소로 줄였다. 사람이 읽기 좋은 코드를 작성한 것이 좋은 코드이다."


##### 마이클 페더스
* Working Effectively with Legacy Code의 저자이다.
> "깨끗한 코드의 특징은 많지만, 그 중에서도 모두를 아우르는 특징이 하나 있다. 깨끗한 코드는 언제나 누군가 주의 깊게 짰다는 느낌을 준다. 고치려고 살펴봐도 딱히 손 댈 곳이 없다."

##### 존 제프리스
* Extreme Programming Installed 와 Extreme Programming Adventure in C#의 저자이다.
> "모든 테스트를 통과한다. 중복이 없다. 시스템 내 모든 설계 아이디어를 표현한다. 클래스, 메서드, 함수 등을 최대한 줄인다."

##### 워드 커닝햄
* wiki 창시자
> "코드를 읽으면서 짐작했던 기능을 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. 코드가 그 문제를 풀기위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다."

### 보이스카우트 규칙
* 잘 짠 코드가 전부가 아니다. 시간이 지나도 언제나 깨끗하게 유지해야 한다.
* **캠프장은 처음 왔을때 보다 더 깨끗하게 해놓고 떠나라.**
* 한꺼번에 많은 시간과 노력을 투자해 코드를 정리할 필요가 없다.
* 변수 이름 하나 개선하고, 조금 긴 함수 하나 분할하고, 약간의 중복을 제거하고, 복잡한 if문 하나를 정리하면 충분하다.

## 2. 의미 있는 이름
### 의도를 분명히 밝혀라
* 의도가 분명한 이름은 코드를 읽는 사람에게 보다 많은 정보를 주기 때문에, 코드 이해와 변경이 쉬워진다.
* 의미없는 이름을 갖고 있는 함수에서 이름만 고쳐도 함수가 하는 일을 이해하기 더 쉬워진다.

### 그릇된 정보는 피해라
* 개발자는 코드에 그릇된 단서를 남겨선 안된다.
* 그릇된 의미는 코드를 읽는 사람에게 혼돈을 줄 수 있으며, 널리 쓰이는 의미가 있는 단어를 다른 의미로 사용하면 안된다.
  * 예시로 여러 계정을 그룹으로 묶을 때 실제 List 자료구조가 아니라면 accountList라는 이름을 사용하면 안된다.
* 서로 규칙 없이 흡사한 이름을 쓰지 않아야 한다.
  * 일관성 있고 규칙있게 사용한 이름은 의미를 이해하는데 정보를 전달 해 주지만 그런 규칙이 없으면 혼돈을 줄 수 있다.

### 의미 있게 구분하라
* 이름을 지을 땐 의미있는 정보를 기반으로 이름을 지어야 한다. (불용어를 추가하면 안된다.)
* 컴파일이나 인터프리터만 통과하려는 생각으로 코드를 구현하면 안된다.
* 예를 들면 연속적인 숫자를 덧붙인 이름으로 지으면 안된다. (a1, a2, a3)
* ProductInfo, ProductData라는 이름으로 지으면 안된다.
  * 이미 Product라는 이름으로 충분한 의미를 제공하고 있는데 굳이 중복해서 Info와 Data를 붙일 필요가 없다.
* NameString과 같은 이름도 지으면 안된다.
  * Name과 별다른 차이가 없다.

### 발음하기 쉬운 이름을 사용해라
* 프로그래밍은 사회 활동이다.
* 서로 의논하기 쉽게 발음하기 쉬운 이름을 사용해야 소통에 좋다.

### 검색하기 쉬운 이름을 사용해라
* 문자 하나를 사용하는 이름 또는 상수는 코드 내에서 검색하기 힘들다.
* 이런 경우 검색을 하면 여러가지 경우의 수와 연관해서 볼 수 있다.
  * 찾아서 고치기 힘들어진다.
* 한 문자를 사용할거면, 간단한 메서드에서 로컬 변수의 경우 정도에서만 사용하면 좋다.
* 또한 생소한 단어를 써도 검색하기 힘들다.

### 인코딩을 피해라
* 굳이 부담을 더하지 않아도 이름에 인코딩할 정보는 충분히 많다.
* 따라서 접두어를 통해 범위 정보까지 인코딩에 넣지 않아야 한다.
* 타입을 변수명에 명시하지 마라 (헝가리식 표기법)
* 이름을 다르게 하지 않아도 멤버 변수임을 확인할 수 있어야 한다.
  * m_등의 접두어를 붙이지 말자.
* 때로는 인코딩이 필요한 경우도 있다.
  * 인터페이스와 클래스의 경우 클래스에 Impl 접미어는 필요할 수 있다. (클래스의 이름이 정보를 인코딩하자)

### 자신의 기억력을 과시하지 마라
* 코드를 읽는 사람이 머리속으로 한번 더 생각해 변환해야 할만한 변수명을 쓰지 않아야한다.
* 한 글자의 이름들(i, j, k 등)은 루프에서만 써야한다.
  * 기억은 영원하지 않다.

### 클래스 이름, 메서드 이름
* 클래스 이름은 명사구로 쓰고 메서드의 이름은 동사구로 쓴다.
  * 클래스 : Customer, Account 등
  * 메서드 : postPayment, save 등

### 기발한 이름은 피하라
* 기발한 이름과 잘 사용되지 않은 단어를 쓰는 이름은 피해야 한다.

### 한 개념에 한 단어를 사용하라
* 똑같은 메서드를 클래스마다 fetch retrieve get 등으로 제각각 부르면 혼란스럽다.
* 일관성 있는 단어를 사용해야 한다.

### 말장난을 하지 마라
* 어떤 클래스에서는 add메서드가 두 값을 더하는 것이고, 다른 메서드에서는 기본 값에 더하기를 하는 것이라면 두 메서드는 반드시 다르게 명명해야 한다.
* 즉 한 단어를 두가지 목적으로 사용하지 않아야 한다.

### 해법 영역에서 가져온 이름을 사용하라
* 코드를 읽을 사람도 개발자이다.
* 그러므로 전산 용어, 알고리즘 이름, 패턴 이름, 수학 용어 이름등을 사용해도 좋다.
* 예로 Visitor pattern에 친숙한 개발자라면 AccountVisitor라는 이름은 금방 이해한다.

### 문제 영역에서 가져온 이름을 사용하라
* 적절한 개발자 용어가 없거나 문제 영역과 관련이 깊은 용어의 경우 문제 영역 용어를 사용하면 좋다.
* 코드를 보수하는 개발자가 전문가에게 의미를 물어봐서 파악할 수 있다.

### 의미있는 맥락을 추가하라
* 스스로 의미가 분명한 이름은 있지만, 그렇지 못한 이름도 있다.
* 예로 firstName, lastName, address, state, city, zipcode와 같은 맥락이 있다면 state가 무슨 의미인지 알 수 있지만, state만 있다면 무슨 의미인지 알기 힘들다.
* 따라서 addrFirstName, addrLastName, addrState라고 쓰는게 좀 더 명확하고 좋다.

### 불필요한 맥락을 없애라
* 넓은 맥락을 가진 이름은 사용하지 않는게 좋다.
* 또한 `Gas station Delux`라는 어플리케이션을 작성한다고 해서 클래스 이름 앞에 GSD를 붙이지 않아야 한다.
  * 자동 완성시에도 모든 클래스가 나타나는 등 효율적이지 못하다.
  * 접두어를 붙이는 것은 모듈의 재사용 관점에서도 좋지 못하다.
  * 재사용하려면 이름을 바꿔야 한다. (GSDAccountAddrees 대신 Address라고만 해도 충분하다.)

## 함수
### 작게 만들어라
* 함수를 만드는 첫 번째 규칙은 '작게'이고, 두 번째 규칙은 '더 작게'이다.
* if문, else문, while문 등에 들어가는 블록은 한 줄이어야 한다.
* 주로 거기서 함수를 호출하기 때문에 중첩 구조가 생길 만큼 함수가 커져서는 안된다.
* 함수에서 들여쓰기 수준은 1~2단을 넘어서면 안된다.

### 한 가지만 해라
* 함수는 한가지를 해야하며, 그 한가지를 잘해야 하고, 그 한가지만을 해야 한다.
* 즉 지정된 함수 이름 알에서 추상화 수준이 하나인 단계만 수행해야 한다.
* 함수를 만드는 큰 이유는 큰 개념을 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서 이다.
* 의미있는 이름으로 다른 함수를 추출할 수 있으면 그 함수는 여러 작업을 하는 것이다.
* 한 가지 작업만 하는 함수는 섹션으로 나눠지지 않는다.

### 함수 당 추상화 수준은 하나로
* 한 함수 내에 추상화 수준이 섞여있으면 코드를 읽는 사람이 이해하기 어려워진다.
* 코드는 위에서 아래로 이야기처럼 읽혀야 좋다.
  * 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.

### Switch 문
* Switch 문은 작게 만들기 어렵다.
* 함수가 크게 될수도 있고, Switch문을 포함한 함수를 한 가지 일로 추상화 하는게 어려울 수 있다.
* 본질적으로 switch 문은 N 가지를 처리한다.
```java
 public Money calculatePay(Employee e) throws InvalidEmployeeType{
        switch(e.type){
        case COMMISIONED:
            return calculateComissionedPay(e);
        case HOURLY:
            return calculateHourlyPay(e);
        case SALARIED:
            return calculateSalariedPay(e);
        default:
            throw new InvalidEmployeeType(e.type);
        }
}
```
* 위 예시는 직원 유형에 따라 다른 값을 반환하는 함수이다.
  * SRP를 잘 따른다.
  * 하지만 직원 유형이 추가되면 이 함수에도 추가해야 하며, 직원이 수정되면 이 함수도 수정해야 한다.
  * 즉 OCP를 위반한다.
```java
public Money calculatePay(Employee e){
      return e.calculatePay();
}
```
* 위와 같이 다형성을 이용하면 직원 유형이 추가되고 수정되어도 변경할 사항이 없어진다.
* 이런 구조를 사용하기 위해 DI나 직원 유형에 따라 직원을 생성해주는 클래스가 필요하다. 
  ```java
  public abstract class Employee{
	public Money calculatePay(); 
  }

  public interface EmployeeFactory(){
      public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType
  }

  public class EmployeeFactoryImpl implements EmployeeFactory{
      public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType{
          switch(e.type){
          case COMMISIONED: 
              return new CommisionedEmpolyee();
          case HOURLY: 
              return new HourlyEmployee();
          case SALARIED: 
              return new SalariedEmployee();
          default:
              throw new InvalidEmployeeType(e.type);
          }
      }
  } 
  ```
    * Switch문은 여전히 사용되지만 딱 한 번의 Switch문이다. (한 번 정도는 참아줄 수 있다.)

### 서술적인 이름을 사용하라
* 함수의 이름을 읽고나서 예측한 동작과 함수의 동작이 같다면 좋은 코드이다.
* 길고 서술적인 이름이 짧고 어려운 이름보다 좋다.
* 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.
* 함수 이름을 붙일 때, 여러 단어가 쉽게 읽히면서 그 여러 단어들로 함수 기능을 잘 표현할 수 있도록 해야 한다.
* 또한 이름을 붙일 때는 일관성이 있어야 한다. 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.
### 함수 인수
* 함수에서 이상적인 인수 개수는 0개이다.
* 인수가 늘어날 수록 함수를 읽는 사람은 인수까지 생각해 동작을 예측해야 한다.
* 따라서 인수의 개수는 적을수록 좋고, 3개 이상의 인수는 피하는게 좋다.
* 테스트 관점에서도 인수가 많을수록, 인수마다 유효한 값으로 모든 조합을 만들어 테스트 하기 힘들어진다.
#### 많이 쓰는 단항 형식
* 인수에 질문을 던지는 경우 `boolean fileExites("MyFile")`
* 인수를 뭔가로 변환해 결과를 반환하는 경우 `InputStream fileOpne("MyFile")`
#### 플래그 인수
* 함수에 플래그인수는 사용하지 않아야 한다.
* 함수가 여러개의 일을 처리한다고 대놓고 공표하는 것과 같다.
#### 이항 함수
* 인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다.
* 예로 `writeField(name)`보다 `writeField(outputStream, name)`이 더 이해하기 어렵다.
* 이항 함수를 만들어야 하는 불가피한 경우가 생길 수 있지만, 가능하다면 단항 함수로 바꿔야 한다.
* writeField 메서드를 outputStream 클래스 구성원으로 만들어 outputStream.writeField(name)으로 호출하게 만들어야 한다.
* 2개의 인수간의 자연적인 순서가 있는경우에는 이항 함수가 적절할 수 있다.
  * `Point p = new Point(x,y);`

#### 삼항 함수
* 인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다.
* 삼항 함수를 만들 때는 신중이 고려해야 한다.
* 일부 인수들을 묶어 하나의 클래스 변수로 만들 수 있는지를 확인하는게 좋다.

#### 인수 객체
* 인수가 2~3개가 필요하다면 일부를 독자적인 클래스 변수로 만들어서 사용할 수 있다.
* 추상화 한 개념을 표현한 것이다.

#### 인수 목록
* `String.format()`과 같은 함수들 처럼 인수 개수가 가변적인 함수도 필요하다.
* `STring.format()`의 인수도 List형 인수이기 때문에 이항함수라고 할 수 있다.

#### 동사와 키워드
* 함수의 의도 및 인수의 순서까지 제대로 표현하기 위해선 좋은 이름이 필요하다.
* 단항 함수라면 동사 / 명사 위주로 표한혀는게 좋다.
  * `writeField(name)`
* 함수의 키워드를 추가해 인수를 예측할 수 있도록 하는게 좋다.
  * `asswertExpectedEqualsActual(expected, actual);`
### 부수 효과를 일으키지 마라
* 함수에서는 딱 한가지만 수행해야 한다.
  * 한가지 일만 하기로 했는데 부수 효과를 일으키는 다른 일은 하면 안된다.
* 부수효과가 꼭 일어나야 된다면 이름에 어떠한 부수 효과를 일으키는지 명시해야 한다.
#### 출력 인수
* 일반적으로 출력 인수는 피해야 한다.
* 함수의 인수를 입력으로 이용하되 출력으로까지 이용하면 어색해진다.
* 인수를 변경해야 하는 일이 있다면 this를 이용해 함수가 속한 객체 상태를 변경하는 방식을 사용하면 된다.
### 명령과 조회를 분리하라
* 함수는 뭔가를 수행하거나, 뭔가를 답을 주거나 둘 중 하나만 해야 한다. (한 가지 일만 해야한다.)
* 두 가지를 모두 하게 되면 혼란을 줄 수 있으므로, 명령과 조회를 분리해 혼란을 주지 않도록 해야한다.
```java
// 나쁜 예시
if(set("username", "myname")){
    ...
}
// 좋은 예시
if(attributeExists("username")){
    setAttribute("username", "myname");
    ...
}
```
### 오류 코드보다 예외를 사용하라
* 오류 코드를 반환하는 방식은 여러 단계로 중첩되는 코드를 만들게 되고, 오류 코드를 바로 처리해야 한다는 문제가 발생한다.
* 오류 코드를 사용하는 것보다 예외를 사용하면 예외 처리로 뺄 수 있으므로 코드가 더 깔끔해진다.
#### Try/Catch 블록 뽑아내기
* Try/Catch 블록을 사용하면 오류 처리 관련 코드가 기존 코드에서 분리되기 때문에 코드가 깔끔해진다.
* Try/Catch 블록은 코드를 알아보기 힘들기 때문에, 별도 함수로 뽑아내고 try문 안에 실제 작업을 위한 메서드를 호출한다.

#### 오류 처리도 한 가지 작업이다.
* 오류 처리를 하는 함수는 오류 처리만 해야한다.

#### Error.java 의존성 자석
* 오류를 처리하는 곳마다 오류 코드를 사용하면 enum class를 쓰게 되는데, 이런 클래스는 의존성 자석이므로 새 오류 코드를 추가하거나 변경할 때 힘들다.
* **오류 코드 대신 예외를 사용**하는 것이 좋고, 새 예외는 Exception 클래스에서 파생된다.

### 반복하지 마라
* 중복은 소프트웨어에서 모든 악의 근원이다.
* 중복이 일어나면 코드의 길이 뿐만 아니라, 수정 시 중복된 코드의 수 만큼 수정을 해야하며, 오류가 발생할 확률도 높아진다.
* 따라서 늘 중복을 없애도록 노력해야 한다.

### 구조적 프로그래밍
* 다익스트라가 만든 프로그래밍 원칙을 따르면 모든 함수와 함수 내 모든 블록에 입구와 출구는 하나만 존재해야 한다.
  * 함수는 return문이 하나여야 하며, 루프 안에서 break나 continue를 사용해선 안되며, goto는 사용하면 안된다.
* 하지만 함수가 작다면 위 원칙은 큰 이익을 제공하지 못한다.
* 그러므로 함수를 작게 만든다면 return, break, continue를 사용해도 된다.
* 오히려 단일 입/출구 규칙보다 의도를 표현하기 쉬워질 수도 있다.

### 함수를 어떻게 짜죠?
* 처음엔 길고 복잡하면서 들여쓰기 단계나 중복된 루프도 많고, 인수목록도 길다.
* 이 코드들을 테스트하는 단위 테스트 케이스도 만들면서 코드를 리팩토링 하는 과정이 필요하다.
* 소프트웨어를 짜는 것은 글짓기와 비슷하며, 결코 한번에 짜지는게 아니다.


### 결론
* 프로그래밍은 언어 설계의 기술이다.
* 대가 개발자는 시스템을 구현할 프로그램이 아니라 **풀어갈 이야기**로 여긴다.
* 함수가 분명하면서 이해하기 쉬운 코드를 작성함으로써 이야기를 풀어가기 쉬워진다.
# 클린 코드
## 1. 깨끗한 코드
### 코드가 존재하리라
* 코드는 요구사항을 상세히 표현하는 수단이다.
* 어느 수준에 이르면 코드의 도움 없이 요구사항을 상세히 표현하기는 불가능하다.
* 추상화도 불가능하다.
* 고도로 추상화된 언어나 특정 응용 분야 언어로 기술하는 명세 역시 코드이므로 결코 코드는 사라지지 않는다.

### 나쁜 코드
* killer app 하나로 대박난 회사가 망한일이 있었다.
  * 그 원인은 나쁜 코드였다.
  * 출시에 바빠 코드를 대책없이 짜서 기능을 추가할수록 코드가 점점 엉망이 되었기 때문이다.
* 우리는 나쁜 코드들을 방치하고 나중에 수정하기로 마음먹고 넘어가지만, 그 나중은 결코 오지 않는다. (르블랑의 법칙 - 나중은 결코 오지 않는다.)

### 나쁜 코드로 치르는 대가
* 나쁜 코드가 쌓일 수록 팀의 생산성은 떨어지게 된다.
* 나쁜 코드는 코드를 고칠 때마다 또 다른 엉뚱한 곳에서 문제가 생긴다.
* 생산성을 증가시키기 위해 투입되는 신규 인력들은 시스템 설계 의도를 분명하게 알지 못해 더 많은 나쁜 코드들을 양산하게 된다.
#### 원대한 재설계의 꿈
* 나쁜 코드에 의해 생산성이 바닥이 되면 되면 재설계를 하는 경우가 생긴다.
* 그러나 이 경우 기존 시스템 기능을 모두 제공하는 새 시스템을 만들며 기존 시스템에 가해지는 변경사항까지 모두 반영해야 한다.
* 새 시스템이 기존 시스템을 따라 잡을 때 쯤이면 재설계팀은 팀을 떠나고, 새로운 팀원들이 새 시스템을 설계하고자 한다.
* 바로 현재 시스템이 너무 엉망이기 때문이다.
* 따라서 이러한 문제를 일으키지 않기 위해 처음부터 깨끗한 코드를 만들어야 한다.

#### 태도
* 나쁜 코드의 위험을 이해하지 못하는 관리자의 말을 그대로 따르는 행동은 전문가 답지 못하다.
* 나쁜 코드가 되는 이유는 요구사항과 일정, 관리자와 마케팅등의 잘못이라고 할 수 없고, 프로그래머가 전문가 답지 못했기 때문이다.
* 프로젝트 실패는 프로그래머에게도 큰 책임이 있고, 특히 나쁜 코드가 초래하는 실패에는 더더욱 책임이 크다.

#### 원초적 난제
* 프로그래머가 기한을 맞추려면 나쁜코드를 양산할 수 밖에 없는건 아니다.
* 오히려 나쁜코드를 양산하면 기한을 맞추지 못한다.
* 기한을 맞추는 유일한 방법은 언제나 코드를 깨끗하게 유지하는 습관이다.

#### 깨끗한 코드라는 예술?
* 깨끗한 코드가 무엇인지 모르면 깨끗한 코드를 만들려고 노력해봤자 소용 없다.
* 깨끗한 코드를 작성하려면 청결이라는 힘겹게 습득한 감각을 활용해 다양한 기법들을 적용하는 절제와 규율이 필요하며, 그 열쇠는 코드 감각이다.
* 코드 감각이 있으면 좋은 코드와 나쁜 코드를 구분할 수 있다.
* 코드 감각이 있으면 절제와 규율을 적용해 나쁜 코드를 좋은 코드로 바꾸는 전략도 파악할 수 있다.

#### 깨끗한 코드란?
* 나는 깨끗한 코드란 코드의 성능이 좋으면서도 코드의 가독성이 좋은 코드라고 생각한다. 
* 하지만 이 질문에 대한 답은 모든 프로그래머들이 생각하는게 다를 것이다.
* 다음은 각 분야의 유명한 프로그래머들의 깨끗한 코드에 대한 의견이다.
##### 비야네 스트롭스트룹
* C++의 창시자이자이며, C++ Programing Language의 저자이다.
> "나는 우아하고 효율적인 코드를 좋아한다. 논리가 간단해야 버그가 숨어들지 못한다. 성능을 최적으로 유지해야 사람들이 원칙없는 최적화로 코드를 망치려는 유혹에 빠지지 않는다. 깨끗한 코드는 한 가지를 제대로 한다."

##### 그래디 부치
* UML을 개발하였으며, object oriented design: with applications의 저자이다.
> "깨끗한 코드는 단순하고 직접적이다. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다. 깨끗한 코드는 설계자의 의도를 숨기지 않는다. 오히려 명쾌한 추상화와 단순한 제어문으로 가득하다."

##### 데이브 토마스
* OTI 창립자이자 이클립스 전략의 대부이다.
> "깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다. 깨끗한 코드에는 의미 있는 이름이 붙는다. 특정 목적을 달성하는 방법은 하나만 제공한다.의존성은 최소이며 각 의존성을 명확히 정의한다. API는 명확하며 최소로 줄였다. 사람이 읽기 좋은 코드를 작성한 것이 좋은 코드이다."


##### 마이클 페더스
* Working Effectively with Legacy Code의 저자이다.
> "깨끗한 코드의 특징은 많지만, 그 중에서도 모두를 아우르는 특징이 하나 있다. 깨끗한 코드는 언제나 누군가 주의 깊게 짰다는 느낌을 준다. 고치려고 살펴봐도 딱히 손 댈 곳이 없다."

##### 존 제프리스
* Extreme Programming Installed 와 Extreme Programming Adventure in C#의 저자이다.
> "모든 테스트를 통과한다. 중복이 없다. 시스템 내 모든 설계 아이디어를 표현한다. 클래스, 메서드, 함수 등을 최대한 줄인다."

##### 워드 커닝햄
* wiki 창시자
> "코드를 읽으면서 짐작했던 기능을 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. 코드가 그 문제를 풀기위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다."

### 보이스카우트 규칙
* 잘 짠 코드가 전부가 아니다. 시간이 지나도 언제나 깨끗하게 유지해야 한다.
* **캠프장은 처음 왔을때 보다 더 깨끗하게 해놓고 떠나라.**
* 한꺼번에 많은 시간과 노력을 투자해 코드를 정리할 필요가 없다.
* 변수 이름 하나 개선하고, 조금 긴 함수 하나 분할하고, 약간의 중복을 제거하고, 복잡한 if문 하나를 정리하면 충분하다.

## 2. 의미 있는 이름
### 의도를 분명히 밝혀라
* 의도가 분명한 이름은 코드를 읽는 사람에게 보다 많은 정보를 주기 때문에, 코드 이해와 변경이 쉬워진다.
* 의미없는 이름을 갖고 있는 함수에서 이름만 고쳐도 함수가 하는 일을 이해하기 더 쉬워진다.

### 그릇된 정보는 피해라
* 프로그래머는 코드에 그릇된 단서를 남겨선 안된다.
* 그릇된 의미는 코드를 읽는 사람에게 혼돈을 줄 수 있으며, 널리 쓰이는 의미가 있는 단어를 다른 의미로 사용하면 안된다.
  * 예시로 여러 계정을 그룹으로 묶을 때 실제 List 자료구조가 아니라면 accountList라는 이름을 사용하면 안된다.
* 서로 규칙 없이 흡사한 이름을 쓰지 않아야 한다.
  * 일관성 있고 규칙있게 사용한 이름은 의미를 이해하는데 정보를 전달 해 주지만 그런 규칙이 없으면 혼돈을 줄 수 있다.

### 의미 있게 구분하라
* 이름을 지을 땐 의미있는 정보를 기반으로 이름을 지어야 한다. (불용어를 추가하면 안된다.)
* 컴파일이나 인터프리터만 통과하려는 생각으로 코드를 구현하면 안된다.
* 예를 들면 연속적인 숫자를 덧붙인 이름으로 지으면 안된다. (a1, a2, a3)
* ProductInfo, ProductData라는 이름으로 지으면 안된다.
  * 이미 Product라는 이름으로 충분한 의미를 제공하고 있는데 굳이 중복해서 Info와 Data를 붙일 필요가 없다.
* NameString과 같은 이름도 지으면 안된다.
  * Name과 별다른 차이가 없다.

### 발음하기 쉬운 이름을 사용해라
* 프로그래밍은 사회 활동이다.
* 서로 의논하기 쉽게 발음하기 쉬운 이름을 사용해야 소통에 좋다.

### 검색하기 쉬운 이름을 사용해라
* 문자 하나를 사용하는 이름 또는 상수는 코드 내에서 검색하기 힘들다.
* 이런 경우 검색을 하면 여러가지 경우의 수와 연관해서 볼 수 있다.
  * 찾아서 고치기 힘들어진다.
* 한 문자를 사용할거면, 간단한 메서드에서 로컬 변수의 경우 정도에서만 사용하면 좋다.
* 또한 생소한 단어를 써도 검색하기 힘들다.

### 인코딩을 피해라
* 굳이 부담을 더하지 않아도 이름에 인코딩할 정보는 충분히 많다.
* 따라서 접두어를 통해 범위 정보까지 인코딩에 넣지 않아야 한다.
* 타입을 변수명에 명시하지 마라 (헝가리식 표기법)
* 이름을 다르게 하지 않아도 멤버 변수임을 확인할 수 있어야 한다.
  * m_등의 접두어를 붙이지 말자.
* 때로는 인코딩이 필요한 경우도 있다.
  * 인터페이스와 클래스의 경우 클래스에 Impl 접미어는 필요할 수 있다. (클래스의 이름이 정보를 인코딩하자)

### 자신의 기억력을 과시하지 마라
* 코드를 읽는 사람이 머리속으로 한번 더 생각해 변환해야 할만한 변수명을 쓰지 않아야한다.
* 한 글자의 이름들(i, j, k 등)은 루프에서만 써야한다.
  * 기억은 영원하지 않다.

### 클래스 이름, 메서드 이름
* 클래스 이름은 명사구로 쓰고 메서드의 이름은 동사구로 쓴다.
  * 클래스 : Customer, Account 등
  * 메서드 : postPayment, save 등

### 기발한 이름은 피하라
* 기발한 이름과 잘 사용되지 않은 단어를 쓰는 이름은 피해야 한다.

### 한 개념에 한 단어를 사용하라
* 똑같은 메서드를 클래스마다 fetch retrieve get 등으로 제각각 부르면 혼란스럽다.
* 일관성 있는 단어를 사용해야 한다.

### 말장난을 하지 마라
* 어떤 클래스에서는 add메서드가 두 값을 더하는 것이고, 다른 메서드에서는 기본 값에 더하기를 하는 것이라면 두 메서드는 반드시 다르게 명명해야 한다.
* 즉 한 단어를 두가지 목적으로 사용하지 않아야 한다.

### 해법 영역에서 가져온 이름을 사용하라
* 코드를 읽을 사람도 프로그래머이다.
* 그러므로 전산 용어, 알고리즘 이름, 패턴 이름, 수학 용어 이름등을 사용해도 좋다.
* 예로 Visitor pattern에 친숙한 프로그래머라면 AccountVisitor라는 이름은 금방 이해한다.

### 문제 영역에서 가져온 이름을 사용하라
* 적절한 프로그래머 용어가 없거나 문제 영역과 관련이 깊은 용어의 경우 문제 영역 용어를 사용하면 좋다.
* 코드를 보수하는 프로그래머가 전문가에게 의미를 물어봐서 파악할 수 있다.

### 의미있는 맥락을 추가하라
* 스스로 의미가 분명한 이름은 있지만, 그렇지 못한 이름도 있다.
* 예로 firstName, lastName, address, state, city, zipcode와 같은 맥락이 있다면 state가 무슨 의미인지 알 수 있지만, state만 있다면 무슨 의미인지 알기 힘들다.
* 따라서 addrFirstName, addrLastName, addrState라고 쓰는게 좀 더 명확하고 좋다.

### 불필요한 맥락을 없애라
* 넓은 맥락을 가진 이름은 사용하지 않는게 좋다.
* 또한 `Gas station Delux`라는 어플리케이션을 작성한다고 해서 클래스 이름 앞에 GSD를 붙이지 않아야 한다.
  * 자동 완성시에도 모든 클래스가 나타나는 등 효율적이지 못하다.
  * 접두어를 붙이는 것은 모듈의 재사용 관점에서도 좋지 못하다.
  * 재사용하려면 이름을 바꿔야 한다. (GSDAccountAddrees 대신 Address라고만 해도 충분하다.)

## 3. 함수
### 작게 만들어라
* 함수를 만드는 첫 번째 규칙은 '작게'이고, 두 번째 규칙은 '더 작게'이다.
* if문, else문, while문 등에 들어가는 블록은 한 줄이어야 한다.
* 주로 거기서 함수를 호출하기 때문에 중첩 구조가 생길 만큼 함수가 커져서는 안된다.
* 함수에서 들여쓰기 수준은 1~2단을 넘어서면 안된다.

### 한 가지만 해라
* 함수는 한가지를 해야하며, 그 한가지를 잘해야 하고, 그 한가지만을 해야 한다.
* 즉 지정된 함수 이름 알에서 추상화 수준이 하나인 단계만 수행해야 한다.
* 함수를 만드는 큰 이유는 큰 개념을 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서 이다.
* 의미있는 이름으로 다른 함수를 추출할 수 있으면 그 함수는 여러 작업을 하는 것이다.
* 한 가지 작업만 하는 함수는 섹션으로 나눠지지 않는다.

### 함수 당 추상화 수준은 하나로
* 한 함수 내에 추상화 수준이 섞여있으면 코드를 읽는 사람이 이해하기 어려워진다.
* 코드는 위에서 아래로 이야기처럼 읽혀야 좋다.
  * 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.

### Switch 문
* Switch 문은 작게 만들기 어렵다.
* 함수가 크게 될수도 있고, Switch문을 포함한 함수를 한 가지 일로 추상화 하는게 어려울 수 있다.
* 본질적으로 switch 문은 N 가지를 처리한다.
```java
 public Money calculatePay(Employee e) throws InvalidEmployeeType{
        switch(e.type){
        case COMMISIONED:
            return calculateComissionedPay(e);
        case HOURLY:
            return calculateHourlyPay(e);
        case SALARIED:
            return calculateSalariedPay(e);
        default:
            throw new InvalidEmployeeType(e.type);
        }
}
```
* 위 예시는 직원 유형에 따라 다른 값을 반환하는 함수이다.
  * SRP를 잘 따른다.
  * 하지만 직원 유형이 추가되면 이 함수에도 추가해야 하며, 직원이 수정되면 이 함수도 수정해야 한다.
  * 즉 OCP를 위반한다.
```java
public Money calculatePay(Employee e){
      return e.calculatePay();
}
```
* 위와 같이 다형성을 이용하면 직원 유형이 추가되고 수정되어도 변경할 사항이 없어진다.
* 이런 구조를 사용하기 위해 DI나 직원 유형에 따라 직원을 생성해주는 클래스가 필요하다. 
  ```java
  public abstract class Employee{
	public Money calculatePay(); 
  }

  public interface EmployeeFactory(){
      public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType
  }

  public class EmployeeFactoryImpl implements EmployeeFactory{
      public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType{
          switch(e.type){
          case COMMISIONED: 
              return new CommisionedEmpolyee();
          case HOURLY: 
              return new HourlyEmployee();
          case SALARIED: 
              return new SalariedEmployee();
          default:
              throw new InvalidEmployeeType(e.type);
          }
      }
  } 
  ```
    * Switch문은 여전히 사용되지만 딱 한 번의 Switch문이다. (한 번 정도는 참아줄 수 있다.)

### 서술적인 이름을 사용하라
* 함수의 이름을 읽고나서 예측한 동작과 함수의 동작이 같다면 좋은 코드이다.
* 길고 서술적인 이름이 짧고 어려운 이름보다 좋다.
* 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.
* 함수 이름을 붙일 때, 여러 단어가 쉽게 읽히면서 그 여러 단어들로 함수 기능을 잘 표현할 수 있도록 해야 한다.
* 또한 이름을 붙일 때는 일관성이 있어야 한다. 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.
### 함수 인수
* 함수에서 이상적인 인수 개수는 0개이다.
* 인수가 늘어날 수록 함수를 읽는 사람은 인수까지 생각해 동작을 예측해야 한다.
* 따라서 인수의 개수는 적을수록 좋고, 3개 이상의 인수는 피하는게 좋다.
* 테스트 관점에서도 인수가 많을수록, 인수마다 유효한 값으로 모든 조합을 만들어 테스트 하기 힘들어진다.
#### 많이 쓰는 단항 형식
* 인수에 질문을 던지는 경우 `boolean fileExites("MyFile")`
* 인수를 뭔가로 변환해 결과를 반환하는 경우 `InputStream fileOpne("MyFile")`
#### 플래그 인수
* 함수에 플래그인수는 사용하지 않아야 한다.
* 함수가 여러개의 일을 처리한다고 대놓고 공표하는 것과 같다.
#### 이항 함수
* 인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다.
* 예로 `writeField(name)`보다 `writeField(outputStream, name)`이 더 이해하기 어렵다.
* 이항 함수를 만들어야 하는 불가피한 경우가 생길 수 있지만, 가능하다면 단항 함수로 바꿔야 한다.
* writeField 메서드를 outputStream 클래스 구성원으로 만들어 outputStream.writeField(name)으로 호출하게 만들어야 한다.
* 2개의 인수간의 자연적인 순서가 있는경우에는 이항 함수가 적절할 수 있다.
  * `Point p = new Point(x,y);`

#### 삼항 함수
* 인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다.
* 삼항 함수를 만들 때는 신중이 고려해야 한다.
* 일부 인수들을 묶어 하나의 클래스 변수로 만들 수 있는지를 확인하는게 좋다.

#### 인수 객체
* 인수가 2~3개가 필요하다면 일부를 독자적인 클래스 변수로 만들어서 사용할 수 있다.
* 추상화 한 개념을 표현한 것이다.

#### 인수 목록
* `String.format()`과 같은 함수들 처럼 인수 개수가 가변적인 함수도 필요하다.
* `STring.format()`의 인수도 List형 인수이기 때문에 이항함수라고 할 수 있다.

#### 동사와 키워드
* 함수의 의도 및 인수의 순서까지 제대로 표현하기 위해선 좋은 이름이 필요하다.
* 단항 함수라면 동사 / 명사 위주로 표한혀는게 좋다.
  * `writeField(name)`
* 함수의 키워드를 추가해 인수를 예측할 수 있도록 하는게 좋다.
  * `asswertExpectedEqualsActual(expected, actual);`
### 부수 효과를 일으키지 마라
* 함수에서는 딱 한가지만 수행해야 한다.
  * 한가지 일만 하기로 했는데 부수 효과를 일으키는 다른 일은 하면 안된다.
* 부수효과가 꼭 일어나야 된다면 이름에 어떠한 부수 효과를 일으키는지 명시해야 한다.
#### 출력 인수
* 일반적으로 출력 인수는 피해야 한다.
* 함수의 인수를 입력으로 이용하되 출력으로까지 이용하면 어색해진다.
* 인수를 변경해야 하는 일이 있다면 this를 이용해 함수가 속한 객체 상태를 변경하는 방식을 사용하면 된다.
### 명령과 조회를 분리하라
* 함수는 뭔가를 수행하거나, 뭔가를 답을 주거나 둘 중 하나만 해야 한다. (한 가지 일만 해야한다.)
* 두 가지를 모두 하게 되면 혼란을 줄 수 있으므로, 명령과 조회를 분리해 혼란을 주지 않도록 해야한다.
```java
// 나쁜 예시
if(set("username", "myname")){
    ...
}
// 좋은 예시
if(attributeExists("username")){
    setAttribute("username", "myname");
    ...
}
```
### 오류 코드보다 예외를 사용하라
* 오류 코드를 반환하는 방식은 여러 단계로 중첩되는 코드를 만들게 되고, 오류 코드를 바로 처리해야 한다는 문제가 발생한다.
* 오류 코드를 사용하는 것보다 예외를 사용하면 예외 처리로 뺄 수 있으므로 코드가 더 깔끔해진다.
#### Try/Catch 블록 뽑아내기
* Try/Catch 블록을 사용하면 오류 처리 관련 코드가 기존 코드에서 분리되기 때문에 코드가 깔끔해진다.
* Try/Catch 블록은 코드를 알아보기 힘들기 때문에, 별도 함수로 뽑아내고 try문 안에 실제 작업을 위한 메서드를 호출한다.

#### 오류 처리도 한 가지 작업이다.
* 오류 처리를 하는 함수는 오류 처리만 해야한다.

#### Error.java 의존성 자석
* 오류를 처리하는 곳마다 오류 코드를 사용하면 enum class를 쓰게 되는데, 이런 클래스는 의존성 자석이므로 새 오류 코드를 추가하거나 변경할 때 힘들다.
* **오류 코드 대신 예외를 사용**하는 것이 좋고, 새 예외는 Exception 클래스에서 파생된다.

### 반복하지 마라
* 중복은 소프트웨어에서 모든 악의 근원이다.
* 중복이 일어나면 코드의 길이 뿐만 아니라, 수정 시 중복된 코드의 수 만큼 수정을 해야하며, 오류가 발생할 확률도 높아진다.
* 따라서 늘 중복을 없애도록 노력해야 한다.

### 구조적 프로그래밍
* 다익스트라가 만든 프로그래밍 원칙을 따르면 모든 함수와 함수 내 모든 블록에 입구와 출구는 하나만 존재해야 한다.
  * 함수는 return문이 하나여야 하며, 루프 안에서 break나 continue를 사용해선 안되며, goto는 사용하면 안된다.
* 하지만 함수가 작다면 위 원칙은 큰 이익을 제공하지 못한다.
* 그러므로 함수를 작게 만든다면 return, break, continue를 사용해도 된다.
* 오히려 단일 입/출구 규칙보다 의도를 표현하기 쉬워질 수도 있다.

### 함수를 어떻게 짜죠?
* 처음엔 길고 복잡하면서 들여쓰기 단계나 중복된 루프도 많고, 인수목록도 길다.
* 이 코드들을 테스트하는 단위 테스트 케이스도 만들면서 코드를 리팩토링 하는 과정이 필요하다.
* 소프트웨어를 짜는 것은 글짓기와 비슷하며, 결코 한번에 짜지는게 아니다.


### 결론
* 프로그래밍은 언어 설계의 기술이다.
* 대가 프로그래머는 시스템을 구현할 프로그램이 아니라 **풀어갈 이야기**로 여긴다.
* 함수가 분명하면서 이해하기 쉬운 코드를 작성함으로써 이야기를 풀어가기 쉬워진다.

## 4. 주석
### 주석은 나쁜 코드를 보완하지 못한다
* 코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문이다.
* 이런 상황에서는 **주석을 다는게 아니라 코드를 정리**해야 한다.
* 표현력이 풍부하고 깔끔하며 주석이 거의 없는 코드가, 복잡하고 어수선하며 주석이 많이 달린 코드보다 훨씬 좋다.

### 코드의 의도를 표현하라
* 코드만으로 의도를 설명하기 어려운 경우가 존재한다.
* 많은 프로그래머들은 의도를 설명할때 코드를 사용하는 것은 좋은 수단이 아니라고 생각한다.
* 아래 두 예시를 보면 아래 코드가 더 이해하기 쉽다는 것을 알 수 있다.
```java
if ((employee.flags & HOURLY_FLAG) && (employee.age > 65))
```

```java
if(employee.isEligibleForFullBenefits())
```
* 코드로 대다수 의도를 표현할 수 있고, 많은 경우 주석으로 달려는 설명을 함수로 만들어 표현해도 충분하다.

### 좋은 주석
* 어떤 주석은 필요하거나 유익하다.
  * 그래도 **정말로 좋은 주석은 주석을 달지 않을 방법을 찾아내는 것이라는 걸 명심**해야 한다.
#### 법적인 주석
* 회사가 정립한 구현 표준에 맞춰 법적인 이유로 특정 주석을 넣으라고 명시한다.
* 예로, 각 소스파일 첫 머리에 주석으로 들어가는 저작권 정보와 소유권 정보는 필요하면서 타당하다.

#### 정보를 제공하는 주석
* 때로는 기본적인 정보를 주석으로 제공하면 편리하다.
```java
// 테스트 중인 Responder 인스턴스를 반환
protected abstract Responder responderInstance();
``` 
* 위 예시는 유용한 정보를 제공해 준다.
* 하지만 responderBeingTested라는 함수 명으로 바꾸면 주석이 필요 없어진다.

```java
// kk:mm:ss EEE, MMM dd, yyyy 형식
Pattern timeMatcher = Pattern.compile("\\d*:\\d*:\\d* \\w*, \\w* \\d*, \\d*")
```
* 위 예시는 정규표현식이 시각과 날짜를 뜻한다고 설명한다.
* 이 경우도 시각과 날짜를 변환하는 클래스를 만들어 코드를 옮겨주면 더 깔끔하며 주석도 필요 없어진다.

#### 의도를 설명하는 주석
* 때로는 주석이 구현을 이해하게 도와주는 선을 넘어 결정에 깔린 의도까지 설명한다. 
* 아래 두 예시는 이러한 의도를 표현해준다.
```java
public int compareTo(Object o){
    if(o instanceof WikiPagePath){
        ...
        return compressedName.compareTo(compressedArgumentName);
    }
    return 1; // 옳은 유형이므로 정렬순위가 더 높다
}
```
```java
public void testConcurrentAddWidgets() throws Exception}{
    ...
    // 스레드를 대량 생성하는 방법으로 어떻게든 경쟁 조건을 만들려 시도한다.    
    for (int i = 0; i< 25000; i++){
        WidgetBuilderThread widgetBuilderThread = 
            new WidgetBuilderThread(widgetBuilder, text, parent, failFlag);
        Thread thread = new Thread(widgetBuilderThread);
        thread.start();
    }
    asswertEquals(false, failFlag.get());
}
```

#### 의미를 명료하게 밝히는 주석
* 때로는 모호한 인수나 반환값이 그 의미를 읽기 좋게 표현하면 이해하기 쉬워진다.
* 인수나 반환값 자체를 명확하게 만들면 더 좋지만, 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속하면 의미를 명로하게 밝히는 주석이 유용하다.
* 하지만 그릇된 주석을 달아놓을 위험은 상항히 높고, 주석이 올바른지 검증하기 쉽지 않다.
* 따라서 이러한 주석을 달 때는 더 나은 방법이 없는지 고민하고 정확히 달아야 한다.

#### 결과를 경고하는 주석
* 때로는 다른 프로그래머에게 결과를 경고할 목적으로 주석을 사용한다.
```java
// 여유 시간이 충분하지 않다면 실행하지 마십시오.
public void _testWithReallyBigFile(){
    ...
}
```
* 위 예시는 특정 테스트케이스를 꺼야 하는 이유이다.
* 요즘은 `@Ignore("실행이 너무 오래걸린다.")`와 같이 애너테이션을 이용한다.
  * JUnit4가 나오기 전엔 메서드 이름 앞에 `_`를 붙이는 방법이 관례였다.
* 아래는 더 좋은 예시이다.
```java
public static SimpleDataFormat makeStandardHttpDateFormat(){
    // SimpleDataFormat은 스레드에 안전하지 못하다.
    // 따라서 각 인스턴스를 독립적으로 생성해야 한다.
    SimpleDataFormat df = new SimpleDataFormat("EEE, dd MMM  yyyy HH:mm:ss z");
    df.setTimeZone(TimeZone.getTimeZone("GMT"));
    return df;
}
```

#### TODO 주석
* 때로는 앞으로 할 일을 `//TODO` 주석으로 남겨두면 편하다.
* 더 이상 필요 없는 기능을 삭제하라는 알림, 누군가에게 문제를 봐달라는 요청, 더 좋은 이름을 떠올려 달라는 부탁, 앞으로 발생할 이벤트에 맞춰 코드를 고치라는 주의 등에 유용하다.
  * 하지만 나쁜 코드를 남겨놓는 핑계가 되어서는 안된다.
* 대부분의 IDE에서는 TODO 주석을 전부 찾아 보여주는 기능을 제공하므로 주석을 잊어버릴 염려도 없다.
* 그러나 TODO가 남발된 코드는 바람직하지 않으므로, 주기적으로 TODO 주석을 점검해 주석을 없애야 한다.

#### 중요성을 강조하는 주석
* 자칫 **대수롭지 않다고 여겨질 뭔가의 중요성을 강조**하기 위해 주석을 사용한다.

#### 공개 API에서 Javadocs
* 설명이 잘 된 공개 API는 유용하고 만족스럽다.
* 표준 자바 라이브러리에서 사용한 Javadocs가 좋은 예다.
* 공개 API를 구현한다면 반드시 훌륭한 Javadocs를 작성한다.
* 하지만 여느 주석과 마찬가지로, Javadocs 역시 독자를 오도하거나, 잘못 위치하거나, 그릇된 정보를 전달할 가능성이 존재한다는 것을 명심해야 한다.

### 나쁜 주석
* 대다수의 주석이 이 범주에 속한다.
* 일반적으로 대다수 주석은 허술한 코드를 지탱하거나, 엉성한 코드를 변명하거나, 미숙한 결정을 합리화 하는 등의 이유로 사용된다.

#### 주절거리는 주석
* 특별한 이유 없이 의무감으로, 혹은 프로세스에서 하라고 하니까 마지못해 주석을 단다면 시간낭비이다.
* 주석을 달기로 결정했으면 충분히 시간을 들여 최고의 주석을 달도록 노력해야 한다.
* 주절거리는 식으로 주석을 단다면, 다른 코드를 찾아볼 수 밖에 없어진다.
* 이해가 안되어 다른 모듈까지 찾아봐야 하는 주석은 독자와 제대로 소통하지 못하는 주석이며, 바이트만 낭비할 뿐이다.

#### 같은 이야기를 중복하는 주석
* 헤더에 달린 주석이 같은 코드 내용을 그대로 중복하여 설명하는 경우가 있다.
* 자칫하면 코드보다 주석을 읽는 시간이 더 오래 걸린다.
* 쓸모없고 중복된 주석이 매우 많아지면 코드만 지저분하고 정신없게 만든다.

#### 오해할 여지가 있는 주석
* 때로는 의도는 좋았으나 프로그래머가 딱 맞을 정도록 엄밀하게 주석을 달지 못하기도 한다.
* 코드보다 읽기도 어려운 주석에 담긴 잘못된 정보로 인해 어느 프로그래머가 경솔하게 해당 함수를 호출하게 될 수도 있다.

#### 의무적으로 다는 주석
* 모든 함수에 javadocs를 달거나, 모든 변수에 주석을 달아야 한다는 등의 규칙은 굉장히 어리석다.
* 이런 주석은 코드를 복잡하게 만들며, 거짓말을 퍼뜨리고, 혼동과 무질서를 초래한다.

#### 이력을 기록하는 주석
* 때로는 사람들이 모듈을 편집할 때마다 모듈 첫머리에 주석을 추가한다.
* 그러면 모듈 첫머리 주석은 모듈의 가한 변경을 모두 기록하는 로그가 된다.
* 예전에는 소스코드 관리 시스템이 없었기 때문에 이러한 관리방법이 관례였지만, 이제는 혼란만 가중할 뿐이다.

#### 있으나 마나 한 주석
* 때로는 있으나 마나 한 주석을 접한다.
* 바로 너무 당연한 사실을 언급하며 새로운 정보를 제공하지 못하는 주석이다.
* 이러한 주석을 많이 쓰면, 프로그래머가 주석을 무시하는 습관에 빠지게 된다.

#### 무서운 잡음
* 때로는 Javadocs도 잡음이다.
* 어떠한 유명한 오픈 소스 라이브러리에도 목적없는 Javadocs가 많은 경우가 있다.
* 문서를 제공해야 한다는 잘못된 욕심으로 생겨난 잡음이다.

#### 함수나 변수로 표현할 수 있다면 주석을 달지 마라
* 주석을 없애고 함수나 변수로 표현할 수 있다면, 주석을 없애는게 좋다.

#### 위치를 표시하는 주석
* 때때로 프로그래머는 소스파일에서 특정 위치를 표시하려고 주석을 사용한다.
* 극히 드문 경우 그러한 주석들이 유용한 경우도 있지만, 일반적으로는 가독성만 낮추기 때문에 제거해야 한다.
* 너무 자주 사용하지 않는다면 이와 같은 주석은 눈에 띄며 주의를 환기시킬 뿐이다.

#### 닫는 괄호에 다는 주석
* 때로는 프로그래머들이 닫는 괄호에 특수한 주석을 달아놓는다.
* 중첩이 심하고 장황한 함수라면 의미가 있을지도 모르지만, 작고 캡슐화된 함수에는 잡음일 뿐이다.
* 닫는 괄호에 주석을 달아야겠다는 생각이 들게 된다면 해당 함수를 줄이려고 노력해보자.

#### 공로를 돌리거나 저자를 표시하는 주석
* 소스코드 관리 시스템은 누가 언제 무엇을 추가했는지 잘 기억한다.
* 저자 이름으로 코드를 오염시킬 필요는 없다.
* 이런 주석이 있다면 누구한테 물어봐야 할지 아니까 유용하다고 생각할 수도 있지만, 현실적으로 오랫동안 코드에 방치되어 쓸모없는 정보로 변하기 쉽다.

#### 주석으로 처리한 코드
* 주석으로 처리한 코드는 굉장히 밉살스러운 관행이다.
* 주석으로 처리된 코드는 다른 사람들이 지우기를 주저한다.
* 이유가 있어 남겨 놓은 거라고 중요하니까 지우면 안된다고 생각한다.
* 하지만 이러한 주석들로 인해 쓸모없는 코드가 점차 쌓여가게 된다.
* **소스코드 관리 시스템의 등장으로 이러한 주석은 전혀 쓸모 없어진 주석**이다.

#### HTML 주석
* 소스코드에서 HTML 주석은 IDE에서 조차 읽기 어렵다.
* 만약 Javadocs와 같은 도구로 주석을 뽑아 웹페이지에 올릴 작정이라면, 이러한 책임은 프로그래머가 아니라 도구가 져야 한다.

#### 전역 정보
* 주석을 달아야 한다면 근처에 있는 코드만 기술해야 한다.
* 코드 일부에 주석을 달면서 시스템의 전반적인 정보를 기술하면 안된다.

#### 너무 많은 정보
* 흥미로운 역사나 관련없는 정보를 장황하게 늘어놓으면 안된다.
* 독자에게 불필요하며 불가사의한 정보일 뿐이다.

#### 모호한 관계
* 주석과 주석이 설명하는 코드는 둘 사이 관계가 명백해야 한다.
* 공들여 주석을 달았으면, 독자가 주석과 코드를 보고 무슨 소리인지 알 수 있을 것이다.

#### 함수 헤더
* 짧은 함수는 긴 설명이 필요 없다.
* 짧고 한 가지만 수행하며 이름을 잘 붙인 함수가 주석으로 헤더를 추가한 함수보다 훨씬 좋다.

#### 비공개 코드에서 Javadocs
* 위 좋은 코드에서 언급한 것처럼 공개 API에서는 Javadocs가 유용하다
* 하지만 공개하지 않을 코드라면 Javadocs는 쓸모가 없고, 시스템 내부에 속한 클래스와 함수에 Javadocs를 생성할 필요가 없다.
* 코드만 보기 싫어지고 산만해질 뿐이다.

## 5. 형식 맞추기
### 형식을 맞추는 목적
* 코드 형식은 너무나도 중요해서 무시하기 힘들다.
* 너무 중요하므로, 융통성 없이 맹목적으로 따르면 안되고, 코드 형식은 의사소통의 일환이다.
* 의사소통은 전문 개발자의 의무적인 부분이다.

### 적절한 행 길이를 유지하라
* 자바에서 파일의 크기는 클래스 크기와 밀접하다.
* 클래스는 클래스를 논하는 장에서 따로 언급될 예정이고, 지금은 파일의 크기만 고려한다.
* 500줄이 넘지 않고 대부분 200줄 정도인 파일로도 커다란 시스템을 충분히 구축할 수 있다.
* 일반적으로 큰 파일보다 작은 파일이 이해하기 쉬우므로, 꼭 지키진 않더라도 바람직한 규칙 정도로 생각하면 좋다.

#### 신문 기사처럼 작성하라
* 신문은 다양한 기사로 이뤄지고, 대다수 기사는 아주 짧다.
* 어떤 기사는 조금 길지라도 한 면을 채우는 기사는 거의 없다.
* 신문이 사실, 날짜 이름 등을 무작위로 뒤섞은 긴 기사 하나만 싣는다면 아무도 읽지 않을 것이다.
* 소스 파일도 신문 기사와 마찬가지로, 이름은 간단하면서도 설명이 가능하게 짓는다.
* 소스 파일 첫 부분은 고차원 개념과 알고리즘을 설명하고, 아래로 내려갈수록 의도를 세세하게 묘사한다.
* 마지막에는 가장 저차원 함수와 세부 내역이 나온다.

#### 개념은 빈 행으로 분리하라
* 일련의 행 묶음은 완결된 생각 하나를 표현하고, 생각 사이에는 빈 행을 넣어 분리해야 마땅하다.

#### 세로 밀집도
* 줄바꿈이 개념을 분리한다면 세로 밀집도는 연관성을 의미한다.
* 서로 밀접한 코드 행은 세로로 가까이 놓여야 한다는 뜻이다.

#### 수직 거리
* 시스템이 무엇을 하는지 이해하고 싶은데, 이 조각 저 조각이 어디에 있는지 찾고 기억하느라 시간과 노력을 많이 소모하곤 한다.
* 서로 밀접한 개념은 세로로 가까이 둬야 한다.
  * 서로 다른 파일에 속한다면 위 규칙은 통하지 않지만, 타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 한다.
  * 이와같은 이유가 바로 protected 변수를 피해야 하는 이유이다.
* 같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성을 표현한다. (연관성은 한 개념을 이해하는 데 다른 개념이 중요한 정도)
* 연관성이 깊은 두 개념이 멀리 떨어져 있으면 코드를 읽는 사람이 소스 파일과 클래스를 여기저기 찾아보게 된다.

##### 변수 선언
* 변수는 사용하는 위치에 최대한 가까이 선언한다.
  * 만들게 되는 함수는 짧으므로 지역 변수는 각 함수 맨 처음에 선언한다.
* 루프를 제어하는 변수는 흔히 루프 문 내부에 선언한다.
  * 다소 긴 함수에서 블록 상단이나 루프 직전에 변수를 선언하는 사례도 있긴 하다.

##### 인스턴스 변수
* 인스턴스 변수는 클래스 맨 처음에 선언한다.
* 변수 간에 세로로 거리를 두지 않으며, 잘 설계한 클래스는 클래스의 많은 메서드가 인스턴스 변수를 사용하기 때문이다.
* 자바에서는 보통 클래스 맨 처음에 인스턴스 변수를 선언한다.

##### 종속 함수
* 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다.
* 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다.
* 이러한 규칙을 일관적으로 적용하면 독자들은 방금 호출한 함수가 잠시 후에 정의되리라는 사실을 예측할 수 있게 된다.

##### 개념적 유사성
* 개념적인 친화도가 높은 코드는 서로 끌어당기며, 이 친화도가 높을수록 코드를 가까이 배치한다.
* 이 친화도가 높은 요인은 여러가지가 있다.
  * 한 함수가 다른 함수를 호출 해 생기는 직접적인 종속성
  * 변수와 그 변수를 사용하는 함수
  * 비슷한 동작을 수행하는 일군의 함수

#### 세로 순서
* 일반적으로 함수 호출 종속성은 아래 방향으로 유지한다.
* 즉, 호출되는 함수를 호출하는 함수보다 나중에 배치한다.
* 그러면 소스 코드 모듈이 고차원에서 저차원으로 자연스럽게 넘어간다.
* 가장 중요한 개념을 먼저 표현하고, 이 때 세세한 사항을 최대한 배제하고 이 세세한 사항은 가장 마지막에 표현한다.
* 그러면 독자가 소스 파일에서 첫 함수 몇 개만 읽어도 개념을 파악하기 쉬워진다.


### 가로 형식 맞추기
* 짧은 행이 바람직하다.
* 100자~120자에 달해도 나쁘지 않지만, 그 이상은 솔직히 말해서 주의부족이다.
  * 예전에는 오른쪽으로 스크롤할 필요가 없게 코드를 짰지만, 요즘은 모니터가 크다.
  * 글자 크기까지 많이 줄여서 200자까지도 한 화면에 들어오기도 한다.
  * 하지만 이렇게 길게 사용하는 것은 권장되는 방법은 아니다.

#### 가로 공백과 밀집도
* 가로로는 공백을 사용해 밀접한 개념과 느슨한 개념을 표현한다.

```java
private void measureLine(String line){
    lineCount++;
    int lineSize = line.length();
    totalChars += lineSize;
    lineWidthHistogram.addLine(lineSize, lineCount);
    recordWidestLine(lineSize)
}
```

* 위 예시를 보면 연산자를 강조하기 위해 앞뒤에 공백을 뒀고, 할당문은 왼쪽 요소와 오른쪽 요소가 분명하게 나뉜다.
* 반면 함수 이름과 이어지는 괄호 사이에는 공백을 넣지 않았다. (함수와 인수는 서로 밀접하기 때문)
* 또한 함수를 호출하는 코드에서 괄호 안 인수는 공백으로 분리했다. (쉼표를 강조해 인수가 별개라는 부분을 보여주기 위함)
* 위 예시 외에도 덧셈과 뺄셈은 곱셈보다 우선순위가 낮기 때문에 곱셈 앞뒤에는 공백이 없고 덧셈과 뺄셈 앞뒤에는 공백을 두는 방법도 있다.

#### 가로 정렬
* 선언부의 변수 이름이나 할당문의 오른쪽 피연산자를 나란히 정렬하기도 하는데, 좋은 방법은 아니다.
* 코드가 엉뚱한 부분을 강조해 진짜 의도가 가려지기 때문이다.
  * 변수 유형은 무시하고 변수 이름부터 읽게 됨.
  * 할당 연산자는 보이지 않고 오른쪽 정렬된 피연산자에 눈이 감.
* 만약 정렬이 필요할 정도로 목록이 길면 문제는 목록 길이이고, 정렬 문제는 아니다.

#### 들여쓰기
* 소스 파일에는 윤곽도(outline)와 계층이 비슷하다.
* 파일 전체에 적용되는 정보가 있고 블록 내 블록에 재귀적으로 적용되는 정보가 있으며, 계층에서 각 수준은 이름을 선언하는 범위이자 선언문과 실행문을 해석하는 범위다.
* 범위(scope)로 이뤄진 계층을 표현하기 위해 들여쓰기를 이용한다.
* 들여쓰기한 파일은 구조가 한눈에 들어오며, 들여쓰기를 하지 않은 코드는 열심히 분석하지 않는 한 해석이 거의 불가능하다.

##### 들여쓰기 무시하기
* 때로는 간단한 if문, 짧은 while문, 짧은 함수에서 들여쓰기 규칙을 무시하고 싶어진다.
* 이런 상황에서도 들여쓰기로 범위를 제대로 표현한 코드가 좋다.

#### 가짜 범위
* 때로는 빈 while문이나 for문을 접한다.
* 이런 구조를 피하지 못할 때는 빈 블록을 올바로 들여쓰고 괄호로 감싼다.
```java
while (dis.read(buf, 0, readBufferSize) != -1)
;
```
* 이러한 구조에서 위 예시와 같이 세미콜론은 새 행에다가 제대로 들여써서 눈에 띄게 만들어 주는게 좋다.

### 팀 규칙
* 프로그래머라면 각자 선호하는 규칙이 있지만, 팀에 속한다면 자신이 선호해야 할 규칙은 바로 팀 규칙이다.
* 팀은 한 가지 규칙에 합의해야 하고, 모든 팀원은 그 규칙을 따라야 한다.
* 개개인이 따로따로 맘대로 짜대는 코드는 피해야 한다.

## 6. 객체와 자료 구조
### 자료 추상화
```java
public class Point {
    public double x;
    public double y;
}
```
```java
public interface Point {
    double getX();
    double getY();
    void setCartesian(double x, double y);
    double getR();
    double getTheta();
    void setPolar(double r, double theta);
}
```
* 위 두가지 예시 중 첫 번째 예시는 구현을 외부로 노출하고, 두 번째 예시는 구현을 완전히 숨긴다.
* 두 번째 예시는 직교좌표계를 사용하는지 극좌표계를 사용하는지 알 길이 없지만, 그럼에도 불구하고 자료 구조를 명백하게 표현한다.
* 또한 두 번째 예시는 좌표를 읽을 때 각 값을 개별적으로 읽어야 하고, 좌표를 설정할 때는 두 값을 한번에 설정해야 한다. (클래스 메서드가 접근 정책을 강제)
* 변수 사이에 함수라는 계층을 넣어도 구현이 저절로 감춰지지는 않고, 구현을 감추려면 추상화가 필요하다.
  * 조회/설정 함수(getter, setter 등)를 이용해 변수를 다룬다고 클래스가 되지 않는다.
  * 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진짜 클래스이다.
* 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 것이 좋다.
* 아무 생각 없이 조회/설정 함수를 추가하는 방법이 가장 나쁘다.

### 자료/객체 비대칭
* **객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.**
* **자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.**
* 자료 구조를 사용하는 절차적인 코드의 특징
  * 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다.
  * 새로운 자료 구조를 추가하기 어렵다. (모든 함수룰 고쳐야 함)
* 객체 지향 코드의 특징
  * 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.
  * 새로운 함수를 추가하기 어렵다. (모든 클래스를 고쳐야 함)
* 객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉽고, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다.


### 디미터 법칙
* 디미터 법칙은 잘 알려진 휴리스틱으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다.
* 객체는 자료를 숨기고 함수를 공개한다. (객체는 조회 함수로 내부 구조를 공개하면 안된다는 의미)
* 예시로, 클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다.
  * 클래스 C
  * f가 생성한 객체
  * f 인수로 넘어온 객체
  * C 인스턴스 변수에 저장된 객체

#### 기차 충돌

``` java
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath(); 
```
* 위와 같은 코드는 디미터 법칙을 어기는 것 처럼 보인다.
  * `getOptions()` 함수가 반환하는 객체의 `getScratchDir()` 함수를 호출한 후 `getScratchDir()` 함수가 반환하는 객체의 `getAbsolutePath()` 함수를 호출함
* 이와 같은 코드는 여러 객차가 한 줄로 이어진 기차처럼 보이기 때문에 기차 충돌이라고 부른다.
* 따라서 아래 코드와 같이 나누는 편이 좋다.
```java
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```
* 하지만 위 코드는 `ctxt`, `opts`, `scratchDir`이 객체인지 자료구조인지에 따라 디미터 법칙을 위반할 수도 있다.
  * 객체라면 내부 구조를 숨겨야 하므로 디미터 법칙 위반
* 따라서 아래 코드와 같이 구현 하면 디미터 법칙을 거론할 필요가 없어진다.
```java
final String outputDir = ctxt.options.scratchDir.absolutePath; 
```

#### 잡종 구조
* 자료구조는 무조건 함수없이 공개 변수만 포함하고 객체는 비공개 변수와 공개 함수를 표현한다면 간단해지지만, 단순한 자료 구조에도 조회 함수와 설정 함수를 정의하라 요구하는 프레임워크와 표준(bean)이 존재한다.
* 이러한 혼란으로 때때로 절반은 객체, 절반은 자료구조인 잡종 구조가 나온다.
* 잡종 구조는 중요한 기능을 수행하는 함수도 있고, 공개 변수나 공개 조회/설정 함수도 있다.
* 따라서 다른 함수가 절차적인 프로그래밍의 자료구조 접근 방식처럼 비공개 변수를 사용하고 싶어질 수 있다.
* 이러한 잡종 구조는 새로운 함수는 물론이고 새로운 자료 구조도 추가하기 어렵다. (양쪽의 단점만 모아놓은 구조)
* 그러므로 이러한 잡종 구조는 되도록 피하는게 좋다.

#### 구조체 감추기
* 객체는 뭔가를 하라고 말해야 하며, 속을 드러내라고 말하면 안된다.
```java
String outFile = outputDir + "/" + className.replace('.', '/') + ".class";
FileOutputStream fout = new FileOutputStream(outFile);
BufferedOutputStream bos = new BufferedOutputStream(fout);
```
* 위 예시는 임시 디렉토리의 절대 경로를 얻으려는 이유가 임시 파일을 생성하기 위한 목적이라는 사실이 들어난다.
* 아래와 같이 바꾸면, `ctxt`는 내부 구조를 드러내지 않으며 모듈에서 해당 함수는 자신이 몰라야 하는 여러 객체를 탐색할 필요가 없어진다.
```java
BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName); 
```

### 자료 전달 객체
* 자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스이다.
* 이런 자료 구조체를 자료 전달 객체(DTO, Data Transfer Object) 라고 한다.
* DTO는 굉장히 유용한 구조체이고, 특히 데이터베이스와 통신하거나 소켓에서 받은 메시지의 구문을 분석할 때 유용하다.
* 더 일반적인 형태는 bean 구조인데, 비공개 변수를 조회/설정 함수로 조작한다.
  * 따라서 별 다른 이익을 제공하지 않는다.

#### 활성 레코드
* 활성 레코드는 DTO의 특수한 형태이다. 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료 구조지만, 대게 save나 find와 같은 탐색 함수도 제공한다.
* 활성 레코드는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과이다.
* 활성 레코드에 비즈니스 규칙 메서드를 추가해 이런 자료 구조를 객체로 취급하는 개발자가 흔하지만, 바람직하지 않은 방법이다.
  * 자료 구조도 아니고 객체도 아닌 잡종 구조가 나오게 된다.
* 이러한 문제의 해결책은, 활성 레코드는 자료 구조로 취급하고 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체는 따로 생성하면 된다.

### 결론
* 객체는 동작을 공개하고 자료를 숨긴다.
  * 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉽고, 기존 객체에 새 동작을 추가하기는 어렵다.
* 자료 구조는 별다른 동작 없이 자료를 노출한다.
  * 기존 자료 구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다.
* 따라서 시스템을 구현할 때 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하고, 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다.

## 7. 오류 처리
### 오류 코드보다 예외를 사용하라
* 얼마 전까지만 해도 예외를 지원하지 않는 프로그래밍 언어가 더 많았다.
* 예외를 지원하지 않는 언어는 오류를 처리하고 보고하는 방법이 제한적이었다. (오류 플래그를 설정하거나 호출자에게 오류코드를 반환)
* 하지만 이와 같은 방법을 사용하면 호출자 코드가 복잡해진다. (호출 즉시 오류를 확인해야 함)
* 따라서 오류가 발생하면 예외를 던지는 편이 더 좋다. (논리가 오류 처리 코드와 섞이지 않음)
* 예외를 사용하면 코드가 확실히 깔끔해지고, 뒤섞여있던 개념들을 분리할 수 있어 각 개념을 독립적으로 살펴보고 이해할 수 있다.

### Try-Catch-Finally 문부터 작성하라
* 예외에서 프로그램 안에다 범위를 정이한다는 것은 매우 흥미로운 내용이다.
* 어떤 면에서 try 블록은 트랜잭션과 비슷하다.
  * try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일고나성 있게 유지해야 한다.
* 따라서 예와가 발생할 코드를 짤 때는 try-catch-finally 문으로 시작하는 편이 좋다.
* 그러면 try 블록에서 무슨 일이 생기든지 호출자가 기대하는 상태를 정의하기 쉬워진다.

### 미확인(unchecked) 예외를 사용하라
* 긴 기간동안 자바 프로그래머들은 확인된(checked) 예외의 장단점을 놓고 논쟁을 벌여왔다.
* 초창기에는 확인된 예외를 멋진 아이디어라 생각했고, 실제로도 확인된 예외는 몇가지 장점도 제공한다.
* 하지만 지금은 안정적인 소프트웨어를 제작하는 요소로 확인된 예외가 반드시 필요하지는 않다.
  * C#, C++, 파이썬 루비 등 확인된 예외를 지원하지 않지만, 그럼에도 불구하고 안정적인 소프트웨어를 구현하기에 무리가 없다.
* 따라서 확인된 오류가 치르는 비용에 상응하는 이익을 제공하는지 따져봐야 한다.
* 확인된 오류가 치르는 비용은 OCP를 위반한다는 점이다.
  * 메서드에서 확인된 예외를 던졌는데 catch 블록이 세 단계 위에 있다면 그 사이 메서드 모두가 선언부에 해당 예외를 정의해야 한다.
  * 하위단계에서 코드를 변경하면 상위 단계 메서드 선언부를 전부 고쳐야 한다.
* 만약 최하위 함수를 변경해 새로운 오류를 던지게 되면, catch 블록에서 새로운 예외를 처리하거나, 선언부에 throw 절을 추가해야 한다.
* 연쇄적인 수정이 일어나고, throws 경로에 위치하는 모든 함수가 최하위 함수에서 던지는 예외를 알아야 하므로 캡슐화도 깨진다.
* 때로는 확인된 예외도 유용하지만, 일반적인 애플리케이션은 의존성이라는 비용이 이익보다 크다.

### 예외에 의미를 제공하라
* 예외를 던질 때는 전후 상황을 충분히 덧붙이면 오류가 발생한 원인과 위치를 찾기가 쉬워진다.
* 자바는 모든 예외에 호출 스택을 제공하지만, 실패한 코드의 의도를 파악하려면 호출 스택만으로 부족하다.
* 따라서 오류 메시지에 정보를 담아 예외와 함께 던지며, 실패한 연산 이름과 실패 유형도 언급한다.
* 만약 애플리케이션이 로깅 기능을 사용한다면 catch 블록에서 오류를 기록하도록 충분한 정보를 넘겨준다.

### 호출자를 고려해 예외 클래스를 정의하라
* 오류를 분류하는 방법은 수없이 많지만, 오류가 발생한 위치로도 분류가 가능하다.
* 애플리케이션에서 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야 한다.
```java
public class LocalPort {
    private ACMEPort innerPort;
    
    public LocalPort(int portNumber) {
        innerPort = new ACMEPort(portNumber);
    }
    
    public void open() {
        try{
            innerPort.open();
        } catch (DeviceResponseException e) {
            throw new PortDeviceFailure(e);
        } catch (ATM1212UnlockedException e) {
            trhow new PortDeviceFailure(e);
        } catch (GMXError e) {
            throw new PortDeviceFailure(e);
        }
    }
    ...
} 
```
* 외부 API를 사용할 때는 감싸기 기법이 최선이다.
* 외부 API를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어들고, 나중에 다른 라이브러리로 갈아타도 비용이 적게 든다.
* 또한 외부 API를 호출하는 대신 테스트 코드를 넣어주는 방법으로 프로그램을 테스트하기도 쉬워진다.
* 또 특정 업체가 API를 설계한 방식에 발목이 잡히지 않는다. 프로그램이 사용하기 편리한 API를 정의하기만 하면 된다.

### 정상 흐름을 정의하라
* 앞 절에서 충고한 대로 코드를 설계하면 비즈니스 논리와 오류 처리가 잘 분리된 코드가 나오며, 코드 대부분이 깨끗하고 간결한 알고리즘으로 보이기 시작한다.
* 하지만 그러다 보면 오류 감지가 프로그램 언저리로 밀려나게 된다.
* 외부 API를 감싸 독자적인 예외를 던지고 코드 위에 처리기를 정의해 중단된 계산을 처리하게 되는데, 대개는 멋진 처리 방식이지만 때로는 적합하지 않은 때도 있다.
* 클래스를 만들거나 특수 사례를 처리하는 방식이 필요할 때가 있는데, 이를 특수 사례 패턴(Special Case Pattern)이라고 한다.
* 클래스나 객체가 예외적인 상황을 캡슐화해서 처리하므로 코드가 예외적인 상황을 처리할 필요가 없어진다. 

### null을 반환하지 마라
* 한 줄 건너 하나씩 null을 확인하는 코드로 가득한 애플리케이션은 수도없이 많다.
* null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라, 호출자에게 문제를 떠넘긴다.
* 누구 하나라도 null 확인을 빼먹는다면 애플리케이션이 통제 불능에 빠질수도 있다.
* 따라서 메서드에서 null을 반환하고 싶다면, 그 대신 예외를 던지거나 특수 사례 객체를 반환해야 한다.
* 만약 사용하려는 외부 API가 null을 반환한다면 감싸기 메서드를 구현해 예외를 던지거나 특수 사례 객체를 반환하는 방식을 고려해야 한다.
* 리스트의 경우, null 보다는 빈 리스트를 반환하는 방법도 있다.

### null을 전달하지 마라
* 메서드에서 null을 반환하는 방식도 나쁘지만 메서드로 null을 전달하는 방식은 더 나쁘다.
* 정상적인 인수로 null을 기대하는 API가 아니라면 메서드로 null을 전달하는 코드는 최대한 피해야 한다.
* 대다수의 프로그래밍 언어는 호출자가 실수로 넘기는 null을 적절히 처리하는 방법이 없다.
* 따라서 애초에 null을 넘기지 못하도록 금지하는 방법이 합리적이다.

### 결론
* 깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다.
* 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있으며, 독립적인 추론이 가능해지며 코드 유지보수성도 크게 높아진다.

## 8. 경계
### 외부 코드 사용하기
* 패키지 제공자나 프레임워크 제공자는 적용성을 최대한 넓히려고 한다.
* 하지만 사용자는 자신의 요구에 집중하는 인터페이스를 원한다.
* 한가지 예로, Java에서 Map은 굉장히 다양한 인터페이스로 수많은 기능을 제공한다.
* Map이 제공하는 기능성과 유연성은 확실히 유용하지만, 그만큼 위험도 크다. 
  * Map을 만들어 여기저기 넘기는 상황에서, Map 사용자라면 누구나 Map내용을 지울 수 있다.
  * 설계 시 Map에 특정 객체 유형만 저장하기로 결정한 상황에서, 마음만 먹으면 사용자는 어떤 객체 유형도 추가할 수 있다.
* 따라서 그냥 Map을 제공하지 말고, 캡슐화를 해서 필요한 기능만 만들어 제공해주면 좋다.
* Map을 사용할 때마다 캡슐화하라는 얘기는 아니고, Map과 같은 경계 인터페이스를 여기저기 넘기지 않아야 된다는 뜻이다.

### 경계 살피고 익히기
* 외부 코드를 사용하면 적은 시간에 더 많은 기능을 출시하기 쉬워진다.
* 외부 패키지 테스트는 우리 책임이 아니지만, 우리를 위해서 테스트 하는 편이 바람직하다.
* 타사 라이브러리를 가져왔을때 사용법이 분명치 않다면, 시간을 투자하여 문서를 읽으며 사용 방법을 익혀야 한다.
* 외부 코드를 익히기는 어렵고 외부 코드를 통합하기도 어려우며, 두 가지를 동시에 하기는 두배나 어렵다.
* 우르쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 방법이 있는데, 학습 테스트라고 한다.
* 학습 테스트는 프로그램에서 사용하려는 방식대로 외부 API를 호출하고, 통제된 환경에서 API를 제대로 이해하는지 확인할 수 있다.

### 학습 테스트는 공짜 이상이다
* 학습 테스트는 공짜 이상이고, 투자하는 노력보다 얻는 성과가 더 크다.
* 패키지 새 버전이 나온다면 학습 데스트를 돌려서 차이가 있는지 확인한다.
* 패키지 새 버전이 나올 때마다 새로운 위험이 생긴다. (새 버전이 우리 코드와 호환된다는 보장은 없음)
* 학습 테스트를 이용한 학습이 필요하든 그렇지 않든, 실제 코드와 동일한 방식으로 인터페이스를 사용하는 테스트 케이스가 필요하다.
* 이러한 경계 테스트가 있으면 패키지의 새 버전으로 이전하기 쉬워진다.

### 아직 존재하지 않는 코드 사용하기
* 때로는 우리 지식이 경계를 너머 미치지 못하는 코드 영역도 있다.
* API 설계조차 되지 않은 상황에서 개발을 해야할 수도 있다.
* 자체적으로 인터페이스를 정의하고, 어댑터 패턴으로 API 사용을 캡슐화해 API가 바뀔때 수정할 코드를 한 곳으로 모으는 방법이 있다.
* 이와 같은 설계는 테스트도 편하다. 
  * API 인터페이스가 나온 다음 경계 테스트 케이스를 생성해 API를 올바로 사용하는지 테스트 할 수도 있다. 

### 깨끗한 경계
* 통제하지 못하는 코드를 사용할 때는 향후 변경 비용이 지나치게 커지지 않도록 각별히 주의해야 한다.
* 경계에 위치하는 코드는 깔끔히 분리해야 하며, 기대치를 정의하는 테스트 케이스도 작성해야 한다.
* 또한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 좋다.
* 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리해야 한다.
* 새로운 클래스로 경계를 감싸거나, 어댑터 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환해야 한다.
* 코드 가독성이 높아지며, 경계 인터페이스를 사용하는 일관성도 높아지고, 외부 패키지가 변했을 때 변경할 코드도 줄어들게 된다.

## 9. 단위 테스트
### TDD 법칙 세 가지
* 첫째 법칙 : 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
* 둘째 법칙 : 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
* 셋째 법칙 : 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
* 위 세 가지 규칙을 따르면 테스트 코드와 실제 코드가 함께 나올뿐더러 테스트 코드가 실제 코드보다 불과 몇 초 전에 나온다.
* 이렇게 일하면 실제 코드를 전부 테스트하는 테스트케이스가 나오지만, 실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 한다.

### 깨끗한 테스트 코드 유지하기
* 테스트 코드가 복잡할수록 실제 코드를 짜는 시간보다 테스트 케이스를 추가하는 시간이 더 걸리며,  실제 코드를 변경하여 기존 테스트 케이스가 실패하기 시작하면 실패하는 테스트 케이스를 점점 통과시키기 어려워진다.
* 테스트코드는 실제 코드 못지 않게 중요하기 때문에, 실제 코드 못지 않게 깨끗하게 짜야 한다.

#### 테스트는 유연성, 유지보수성, 재사용성을 제공한다.
* 테스트 코드를 깨끗하게 유지하지 않으면 결국 잃어버리게 되고, 테스트 케이스가 없으면 실제 코드를 유연하게 만드는 버팀목도 사라진다.
* 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 단위 테스트이다.
* 실제 코드를 점검하는 자동화된 단위 테스트 슈트는 설계와 아키텍처를 깨끗하게 보존하는 열쇠다.
* 테스트 코드가 지저분하면 코드를 변경하는 능력이 떨어지고 코드 구조를 개선하는 능력도 떨어진다. 
* 테스트 코드가 지저분할수록 실제 코드도 지저분해지며, 테스트 코드도 잃어버리고 실제 코드도 망가지게 된다.

### 깨끗한 테스트 코드
* 깨끗한 테스트코드를 만들려면 가독성이 필요하다.
* 가독성은 실제 코드에서 보다 테스트 코드에서 더 중요하다.
* 테스트 코드에서 가독성을 높이기 위해서 명료성, 단순성, 풍부한 표현력이 필요하다.
* 자질구레한 사항이 너무 많으면 테스트 코드의 표현력이 떨어진다.
* 테스트 코드에서는 잡다하고 세세한 코드를 거의 다 없애고, 진짜 필요한 자료 유형과 함수만 사용해야 한다.

### 테스트 당 assert 하나
* JUnit으로 테스트 코드를 짤 때에는 함수마다 assert 문을 하나만 사용해야 한다.
* assert 문이 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠르다.
* assert문 하나로 안된다면 테스트를 두 개로 분리해 각자가 assert를 수행하면 된다.

#### 테스트 당 개념 하나
* 테스트 함수마다 한 개념만 테스트 해야한다.
* 이것저것 잡다한 개념을 연속으로 테스트하는 긴 함수는 피해야 한다.
* 새 개념을 한 함수로 몰아넣으면 독자가 각 절이 거기에 존재하는 이유와 각 절이 테스트하는 개념을 모두 이해해야 한다.
* 가장 좋은 규칙은 **개념 당 assert문 수를 최소로 줄이고, 테스트 함수 하나는 개념 하나만 테스트해야 한다.**

### F.I.R.S.T
* 깨끗한 테스트는 다섯 가지 규칙을 따르며, 각 규칙에서 첫 글자를 따오면 FIRST가 된다.

#### Fast
* 테스트는 빨라야 한다.
* 테스트가 느리면 자주 돌릴 엄두를 못 낸다.
* 자주 돌리지 않으면 초반에 문제를 찾아내 고치지 못하고, 코드를 마음껏 정리하지도 못한다.

#### Independent
* 테스트는 서로 의존하면 안된다.
* 한 테스트가 다음 테스트가 실행 될 환경을 준비해서는 안된다.
* 각 테스트는 독립적으로, 어떤 순서로 실행해도 괜찮아야 한다.
* 테스트가 서로에게 의존하면 하나가 실패할 때 나머지도 잇달아 실패하므로, 원인을 진단하기 어려워진다.

#### Repeatable
* 테스트는 어떤 환경에서도 반복 가능해야 한다.
* 테스트가 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다.
* 또한 환경이 지원되지 않기에 테스트를 수행하지 못하는 상황이 올 수도 있다.

#### Self-Validating
* 테스트는 bool 값으로 결과를 내야 한다.
* 성공 아니면 실패이고, 통과 여부를 알려고 로그 파일을 읽게 만들어서는 안 된다.
* 통과 여부를 보려고 텍스트 파일 두 개를 수작업으로 비교하게 만들어서도 안 된다.
* 테스트가 스스로 성공과 실패를 가늠하지 않는다면 판단은 주관적이 되며, 지루한 수작업 평가가 필요하게 된다.

#### Timely
* 테스트는 적시에 작성해야 한다.
* 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다.
* 실제 코드를 구현한 다음에 테스트 코드를 만들면 실제 코드가 테스트하기 어렵다는 사실을 발견할지도 모른다.

### 결론
* 깨끗한 테스트 코드라는 주제는 책 한권을 할애해도 모자랄 주제이다.
* 테스트 코드는 실제 코드 만큼이나 프로젝트 건강에 중요하다. (실제 코드보다 더 중요할수도 있음)
* 테스트코드는 실제 코드의 유연성, 유지보수성, 재사용성을 보존하고 강화한다.
* 테스트 코드가 방치되어 망가지면 실제 코드도 망가지므로, 테스트 코드를 깨끗하게 유지해야 한다.

## 10. 클래스
### 클래스 체계
* 클래스를 정의하는 표준 자바 관례에 따르면, 가장 먼저 변수 목록이 나온다.
* static, public 상수가 있다면 맨 처음에 나오고, 그 다음으로 private 변수가 나오며, 이어서 비공개 인스턴스 변수가 나온다.
* 변수 목록 다음에는 공개 함수가 나오며, 비공개 함수는 자신을 호출하는 공개 함수 직후에 넣는다.
* 즉 추상화 단계가 추상적으로 내려가게 되고, 프로그램은 신문 기사처럼 읽힌다.

#### 캡슐화
* 변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫지만 반드시 숨겨야 한다는 법칙도 없다.
* 우리에게 테스트는 아주 중요하며, 같은 패키지 안에서 테스트 코드가 함수를 호출하거나 변수를 사용해야 한다면 그 함수나 변수를 protected로 선언하거나 패키지 전체로 공개한다.
* 그렇지만 그 전에 비공개 상태를 유지할 온갖 방법을 강구해야 하며, 캡슐화를 풀어주는 결정은 언제나 최후의 수단이다.

### 클래스는 작아야 한다
* 클래스를 만들 때 첫 번째 규칙은 크기다.
* 클래스를 설계할 때도 함수와 마찬가지로 '작게'가 기본 규칙이다.
* 함수는 물리적인 행 수로 크기를 측정했지만, 클래스는 클래스가 맡은 책임을 센다.

#### 단일 책임 원칙
* 단일 책임 원칙(SRP, Single Responsibility Principle)은 클래스나 모듈을 변경할 이유가 단 하나뿐이어야 한다는 원칙이다.
* SRP는 객체 지향 설계에서 더욱 중요한 개념이면서 이해하고 지키기 수월한 개념이지만 클래스 설계자들이 가장 무시하는 규칙 중 하나다.
  * 깨끗하고 체계적인 소프트웨어보다 돌아가는 소프트웨어에 초점을 맞추기 때문이다.
* 큰 클래스 몇개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다.
* 작은 클래스는 각자 맡은 책임이 하나이며, 변경할 이유가 하나이고, 다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행해야 한다.
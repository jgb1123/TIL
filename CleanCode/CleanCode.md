# 클린 코드
## 1. 깨끗한 코드
### 코드가 존재하리라
* 코드는 요구사항을 상세히 표현하는 수단이다.
* 어느 수준에 이르면 코드의 도움 없이 요구사항을 상세히 표현하기는 불가능하다.
* 추상화도 불가능하다.
* 고도로 추상화된 언어나 특정 응용 분야 언어로 기술하는 명세 역시 코드이므로 결코 코드는 사라지지 않는다.

### 나쁜 코드
* killer app 하나로 대박난 회사가 망한일이 있었다.
  * 그 원인은 나쁜 코드였다.
  * 출시에 바빠 코드를 대책없이 짜서 기능을 추가할수록 코드가 점점 엉망이 되었기 때문이다.
* 우리는 나쁜 코드들을 방치하고 나중에 수정하기로 마음먹고 넘어가지만, 그 나중은 결코 오지 않는다. (르블랑의 법칙 - 나중은 결코 오지 않는다.)

### 나쁜 코드로 치르는 대가
* 나쁜 코드가 쌓일 수록 팀의 생산성은 떨어지게 된다.
* 나쁜 코드는 코드를 고칠 때마다 또 다른 엉뚱한 곳에서 문제가 생긴다.
* 생산성을 증가시키기 위해 투입되는 신규 인력들은 시스템 설계 의도를 분명하게 알지 못해 더 많은 나쁜 코드들을 양산하게 된다.
#### 원대한 재설계의 꿈
* 나쁜 코드에 의해 생산성이 바닥이 되면 되면 재설계를 하는 경우가 생긴다.
* 그러나 이 경우 기존 시스템 기능을 모두 제공하는 새 시스템을 만들며 기존 시스템에 가해지는 변경사항까지 모두 반영해야 한다.
* 새 시스템이 기존 시스템을 따라 잡을 때 쯤이면 재설계팀은 팀을 떠나고, 새로운 팀원들이 새 시스템을 설계하고자 한다.
* 바로 현재 시스템이 너무 엉망이기 때문이다.
* 따라서 이러한 문제를 일으키지 않기 위해 처음부터 깨끗한 코드를 만들어야 한다.

#### 태도
* 나쁜 코드의 위험을 이해하지 못하는 관리자의 말을 그대로 따르는 행동은 전문가 답지 못하다.
* 나쁜 코드가 되는 이유는 요구사항과 일정, 관리자와 마케팅등의 잘못이라고 할 수 없고, 프로그래머가 전문가 답지 못했기 때문이다.
* 프로젝트 실패는 프로그래머에게도 큰 책임이 있고, 특히 나쁜 코드가 초래하는 실패에는 더더욱 책임이 크다.

#### 원초적 난제
* 프로그래머가 기한을 맞추려면 나쁜코드를 양산할 수 밖에 없는건 아니다.
* 오히려 나쁜코드를 양산하면 기한을 맞추지 못한다.
* 기한을 맞추는 유일한 방법은 언제나 코드를 깨끗하게 유지하는 습관이다.

#### 깨끗한 코드라는 예술?
* 깨끗한 코드가 무엇인지 모르면 깨끗한 코드를 만들려고 노력해봤자 소용 없다.
* 깨끗한 코드를 작성하려면 청결이라는 힘겹게 습득한 감각을 활용해 다양한 기법들을 적용하는 절제와 규율이 필요하며, 그 열쇠는 코드 감각이다.
* 코드 감각이 있으면 좋은 코드와 나쁜 코드를 구분할 수 있다.
* 코드 감각이 있으면 절제와 규율을 적용해 나쁜 코드를 좋은 코드로 바꾸는 전략도 파악할 수 있다.

#### 깨끗한 코드란?
* 나는 깨끗한 코드란 코드의 성능이 좋으면서도 코드의 가독성이 좋은 코드라고 생각한다. 
* 하지만 이 질문에 대한 답은 모든 프로그래머들이 생각하는게 다를 것이다.
* 다음은 각 분야의 유명한 프로그래머들의 깨끗한 코드에 대한 의견이다.
##### 비야네 스트롭스트룹
* C++의 창시자이자이며, C++ Programing Language의 저자이다.
> "나는 우아하고 효율적인 코드를 좋아한다. 논리가 간단해야 버그가 숨어들지 못한다. 성능을 최적으로 유지해야 사람들이 원칙없는 최적화로 코드를 망치려는 유혹에 빠지지 않는다. 깨끗한 코드는 한 가지를 제대로 한다."

##### 그래디 부치
* UML을 개발하였으며, object oriented design: with applications의 저자이다.
> "깨끗한 코드는 단순하고 직접적이다. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다. 깨끗한 코드는 설계자의 의도를 숨기지 않는다. 오히려 명쾌한 추상화와 단순한 제어문으로 가득하다."

##### 데이브 토마스
* OTI 창립자이자 이클립스 전략의 대부이다.
> "깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다. 깨끗한 코드에는 의미 있는 이름이 붙는다. 특정 목적을 달성하는 방법은 하나만 제공한다.의존성은 최소이며 각 의존성을 명확히 정의한다. API는 명확하며 최소로 줄였다. 사람이 읽기 좋은 코드를 작성한 것이 좋은 코드이다."


##### 마이클 페더스
* Working Effectively with Legacy Code의 저자이다.
> "깨끗한 코드의 특징은 많지만, 그 중에서도 모두를 아우르는 특징이 하나 있다. 깨끗한 코드는 언제나 누군가 주의 깊게 짰다는 느낌을 준다. 고치려고 살펴봐도 딱히 손 댈 곳이 없다."

##### 존 제프리스
* Extreme Programming Installed 와 Extreme Programming Adventure in C#의 저자이다.
> "모든 테스트를 통과한다. 중복이 없다. 시스템 내 모든 설계 아이디어를 표현한다. 클래스, 메서드, 함수 등을 최대한 줄인다."

##### 워드 커닝햄
* wiki 창시자
> "코드를 읽으면서 짐작했던 기능을 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. 코드가 그 문제를 풀기위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다."

### 보이스카우트 규칙
* 잘 짠 코드가 전부가 아니다. 시간이 지나도 언제나 깨끗하게 유지해야 한다.
* **캠프장은 처음 왔을때 보다 더 깨끗하게 해놓고 떠나라.**
* 한꺼번에 많은 시간과 노력을 투자해 코드를 정리할 필요가 없다.
* 변수 이름 하나 개선하고, 조금 긴 함수 하나 분할하고, 약간의 중복을 제거하고, 복잡한 if문 하나를 정리하면 충분하다.

## 2. 의미 있는 이름
### 의도를 분명히 밝혀라
* 의도가 분명한 이름은 코드를 읽는 사람에게 보다 많은 정보를 주기 때문에, 코드 이해와 변경이 쉬워진다.
* 의미없는 이름을 갖고 있는 함수에서 이름만 고쳐도 함수가 하는 일을 이해하기 더 쉬워진다.

### 그릇된 정보는 피해라
* 프로그래머는 코드에 그릇된 단서를 남겨선 안된다.
* 그릇된 의미는 코드를 읽는 사람에게 혼돈을 줄 수 있으며, 널리 쓰이는 의미가 있는 단어를 다른 의미로 사용하면 안된다.
  * 예시로 여러 계정을 그룹으로 묶을 때 실제 List 자료구조가 아니라면 accountList라는 이름을 사용하면 안된다.
* 서로 규칙 없이 흡사한 이름을 쓰지 않아야 한다.
  * 일관성 있고 규칙있게 사용한 이름은 의미를 이해하는데 정보를 전달 해 주지만 그런 규칙이 없으면 혼돈을 줄 수 있다.

### 의미 있게 구분하라
* 이름을 지을 땐 의미있는 정보를 기반으로 이름을 지어야 한다. (불용어를 추가하면 안된다.)
* 컴파일이나 인터프리터만 통과하려는 생각으로 코드를 구현하면 안된다.
* 예를 들면 연속적인 숫자를 덧붙인 이름으로 지으면 안된다. (a1, a2, a3)
* ProductInfo, ProductData라는 이름으로 지으면 안된다.
  * 이미 Product라는 이름으로 충분한 의미를 제공하고 있는데 굳이 중복해서 Info와 Data를 붙일 필요가 없다.
* NameString과 같은 이름도 지으면 안된다.
  * Name과 별다른 차이가 없다.

### 발음하기 쉬운 이름을 사용해라
* 프로그래밍은 사회 활동이다.
* 서로 의논하기 쉽게 발음하기 쉬운 이름을 사용해야 소통에 좋다.

### 검색하기 쉬운 이름을 사용해라
* 문자 하나를 사용하는 이름 또는 상수는 코드 내에서 검색하기 힘들다.
* 이런 경우 검색을 하면 여러가지 경우의 수와 연관해서 볼 수 있다.
  * 찾아서 고치기 힘들어진다.
* 한 문자를 사용할거면, 간단한 메서드에서 로컬 변수의 경우 정도에서만 사용하면 좋다.
* 또한 생소한 단어를 써도 검색하기 힘들다.

### 인코딩을 피해라
* 굳이 부담을 더하지 않아도 이름에 인코딩할 정보는 충분히 많다.
* 따라서 접두어를 통해 범위 정보까지 인코딩에 넣지 않아야 한다.
* 타입을 변수명에 명시하지 마라 (헝가리식 표기법)
* 이름을 다르게 하지 않아도 멤버 변수임을 확인할 수 있어야 한다.
  * m_등의 접두어를 붙이지 말자.
* 때로는 인코딩이 필요한 경우도 있다.
  * 인터페이스와 클래스의 경우 클래스에 Impl 접미어는 필요할 수 있다. (클래스의 이름이 정보를 인코딩하자)

### 자신의 기억력을 과시하지 마라
* 코드를 읽는 사람이 머리속으로 한번 더 생각해 변환해야 할만한 변수명을 쓰지 않아야한다.
* 한 글자의 이름들(i, j, k 등)은 루프에서만 써야한다.
  * 기억은 영원하지 않다.

### 클래스 이름, 메서드 이름
* 클래스 이름은 명사구로 쓰고 메서드의 이름은 동사구로 쓴다.
  * 클래스 : Customer, Account 등
  * 메서드 : postPayment, save 등

### 기발한 이름은 피하라
* 기발한 이름과 잘 사용되지 않은 단어를 쓰는 이름은 피해야 한다.

### 한 개념에 한 단어를 사용하라
* 똑같은 메서드를 클래스마다 fetch retrieve get 등으로 제각각 부르면 혼란스럽다.
* 일관성 있는 단어를 사용해야 한다.

### 말장난을 하지 마라
* 어떤 클래스에서는 add메서드가 두 값을 더하는 것이고, 다른 메서드에서는 기본 값에 더하기를 하는 것이라면 두 메서드는 반드시 다르게 명명해야 한다.
* 즉 한 단어를 두가지 목적으로 사용하지 않아야 한다.

### 해법 영역에서 가져온 이름을 사용하라
* 코드를 읽을 사람도 프로그래머이다.
* 그러므로 전산 용어, 알고리즘 이름, 패턴 이름, 수학 용어 이름등을 사용해도 좋다.
* 예로 Visitor pattern에 친숙한 프로그래머라면 AccountVisitor라는 이름은 금방 이해한다.

### 문제 영역에서 가져온 이름을 사용하라
* 적절한 프로그래머 용어가 없거나 문제 영역과 관련이 깊은 용어의 경우 문제 영역 용어를 사용하면 좋다.
* 코드를 보수하는 프로그래머가 전문가에게 의미를 물어봐서 파악할 수 있다.

### 의미있는 맥락을 추가하라
* 스스로 의미가 분명한 이름은 있지만, 그렇지 못한 이름도 있다.
* 예로 firstName, lastName, address, state, city, zipcode와 같은 맥락이 있다면 state가 무슨 의미인지 알 수 있지만, state만 있다면 무슨 의미인지 알기 힘들다.
* 따라서 addrFirstName, addrLastName, addrState라고 쓰는게 좀 더 명확하고 좋다.

### 불필요한 맥락을 없애라
* 넓은 맥락을 가진 이름은 사용하지 않는게 좋다.
* 또한 `Gas station Delux`라는 어플리케이션을 작성한다고 해서 클래스 이름 앞에 GSD를 붙이지 않아야 한다.
  * 자동 완성시에도 모든 클래스가 나타나는 등 효율적이지 못하다.
  * 접두어를 붙이는 것은 모듈의 재사용 관점에서도 좋지 못하다.
  * 재사용하려면 이름을 바꿔야 한다. (GSDAccountAddrees 대신 Address라고만 해도 충분하다.)

## 3. 함수
### 작게 만들어라
* 함수를 만드는 첫 번째 규칙은 '작게'이고, 두 번째 규칙은 '더 작게'이다.
* if문, else문, while문 등에 들어가는 블록은 한 줄이어야 한다.
* 주로 거기서 함수를 호출하기 때문에 중첩 구조가 생길 만큼 함수가 커져서는 안된다.
* 함수에서 들여쓰기 수준은 1~2단을 넘어서면 안된다.

### 한 가지만 해라
* 함수는 한가지를 해야하며, 그 한가지를 잘해야 하고, 그 한가지만을 해야 한다.
* 즉 지정된 함수 이름 알에서 추상화 수준이 하나인 단계만 수행해야 한다.
* 함수를 만드는 큰 이유는 큰 개념을 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서 이다.
* 의미있는 이름으로 다른 함수를 추출할 수 있으면 그 함수는 여러 작업을 하는 것이다.
* 한 가지 작업만 하는 함수는 섹션으로 나눠지지 않는다.

### 함수 당 추상화 수준은 하나로
* 한 함수 내에 추상화 수준이 섞여있으면 코드를 읽는 사람이 이해하기 어려워진다.
* 코드는 위에서 아래로 이야기처럼 읽혀야 좋다.
  * 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.

### Switch 문
* Switch 문은 작게 만들기 어렵다.
* 함수가 크게 될수도 있고, Switch문을 포함한 함수를 한 가지 일로 추상화 하는게 어려울 수 있다.
* 본질적으로 switch 문은 N 가지를 처리한다.
```java
 public Money calculatePay(Employee e) throws InvalidEmployeeType{
        switch(e.type){
        case COMMISIONED:
            return calculateComissionedPay(e);
        case HOURLY:
            return calculateHourlyPay(e);
        case SALARIED:
            return calculateSalariedPay(e);
        default:
            throw new InvalidEmployeeType(e.type);
        }
}
```
* 위 예시는 직원 유형에 따라 다른 값을 반환하는 함수이다.
  * SRP를 잘 따른다.
  * 하지만 직원 유형이 추가되면 이 함수에도 추가해야 하며, 직원이 수정되면 이 함수도 수정해야 한다.
  * 즉 OCP를 위반한다.
```java
public Money calculatePay(Employee e){
      return e.calculatePay();
}
```
* 위와 같이 다형성을 이용하면 직원 유형이 추가되고 수정되어도 변경할 사항이 없어진다.
* 이런 구조를 사용하기 위해 DI나 직원 유형에 따라 직원을 생성해주는 클래스가 필요하다. 
  ```java
  public abstract class Employee{
	public Money calculatePay(); 
  }

  public interface EmployeeFactory(){
      public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType
  }

  public class EmployeeFactoryImpl implements EmployeeFactory{
      public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType{
          switch(e.type){
          case COMMISIONED: 
              return new CommisionedEmpolyee();
          case HOURLY: 
              return new HourlyEmployee();
          case SALARIED: 
              return new SalariedEmployee();
          default:
              throw new InvalidEmployeeType(e.type);
          }
      }
  } 
  ```
    * Switch문은 여전히 사용되지만 딱 한 번의 Switch문이다. (한 번 정도는 참아줄 수 있다.)

### 서술적인 이름을 사용하라
* 함수의 이름을 읽고나서 예측한 동작과 함수의 동작이 같다면 좋은 코드이다.
* 길고 서술적인 이름이 짧고 어려운 이름보다 좋다.
* 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.
* 함수 이름을 붙일 때, 여러 단어가 쉽게 읽히면서 그 여러 단어들로 함수 기능을 잘 표현할 수 있도록 해야 한다.
* 또한 이름을 붙일 때는 일관성이 있어야 한다. 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.
### 함수 인수
* 함수에서 이상적인 인수 개수는 0개이다.
* 인수가 늘어날 수록 함수를 읽는 사람은 인수까지 생각해 동작을 예측해야 한다.
* 따라서 인수의 개수는 적을수록 좋고, 3개 이상의 인수는 피하는게 좋다.
* 테스트 관점에서도 인수가 많을수록, 인수마다 유효한 값으로 모든 조합을 만들어 테스트 하기 힘들어진다.
#### 많이 쓰는 단항 형식
* 인수에 질문을 던지는 경우 `boolean fileExites("MyFile")`
* 인수를 뭔가로 변환해 결과를 반환하는 경우 `InputStream fileOpne("MyFile")`
#### 플래그 인수
* 함수에 플래그인수는 사용하지 않아야 한다.
* 함수가 여러개의 일을 처리한다고 대놓고 공표하는 것과 같다.
#### 이항 함수
* 인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다.
* 예로 `writeField(name)`보다 `writeField(outputStream, name)`이 더 이해하기 어렵다.
* 이항 함수를 만들어야 하는 불가피한 경우가 생길 수 있지만, 가능하다면 단항 함수로 바꿔야 한다.
* writeField 메서드를 outputStream 클래스 구성원으로 만들어 outputStream.writeField(name)으로 호출하게 만들어야 한다.
* 2개의 인수간의 자연적인 순서가 있는경우에는 이항 함수가 적절할 수 있다.
  * `Point p = new Point(x,y);`

#### 삼항 함수
* 인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다.
* 삼항 함수를 만들 때는 신중이 고려해야 한다.
* 일부 인수들을 묶어 하나의 클래스 변수로 만들 수 있는지를 확인하는게 좋다.

#### 인수 객체
* 인수가 2~3개가 필요하다면 일부를 독자적인 클래스 변수로 만들어서 사용할 수 있다.
* 추상화 한 개념을 표현한 것이다.

#### 인수 목록
* `String.format()`과 같은 함수들 처럼 인수 개수가 가변적인 함수도 필요하다.
* `STring.format()`의 인수도 List형 인수이기 때문에 이항함수라고 할 수 있다.

#### 동사와 키워드
* 함수의 의도 및 인수의 순서까지 제대로 표현하기 위해선 좋은 이름이 필요하다.
* 단항 함수라면 동사 / 명사 위주로 표한혀는게 좋다.
  * `writeField(name)`
* 함수의 키워드를 추가해 인수를 예측할 수 있도록 하는게 좋다.
  * `asswertExpectedEqualsActual(expected, actual);`
### 부수 효과를 일으키지 마라
* 함수에서는 딱 한가지만 수행해야 한다.
  * 한가지 일만 하기로 했는데 부수 효과를 일으키는 다른 일은 하면 안된다.
* 부수효과가 꼭 일어나야 된다면 이름에 어떠한 부수 효과를 일으키는지 명시해야 한다.
#### 출력 인수
* 일반적으로 출력 인수는 피해야 한다.
* 함수의 인수를 입력으로 이용하되 출력으로까지 이용하면 어색해진다.
* 인수를 변경해야 하는 일이 있다면 this를 이용해 함수가 속한 객체 상태를 변경하는 방식을 사용하면 된다.
### 명령과 조회를 분리하라
* 함수는 뭔가를 수행하거나, 뭔가를 답을 주거나 둘 중 하나만 해야 한다. (한 가지 일만 해야한다.)
* 두 가지를 모두 하게 되면 혼란을 줄 수 있으므로, 명령과 조회를 분리해 혼란을 주지 않도록 해야한다.
```java
// 나쁜 예시
if(set("username", "myname")){
    ...
}
// 좋은 예시
if(attributeExists("username")){
    setAttribute("username", "myname");
    ...
}
```
### 오류 코드보다 예외를 사용하라
* 오류 코드를 반환하는 방식은 여러 단계로 중첩되는 코드를 만들게 되고, 오류 코드를 바로 처리해야 한다는 문제가 발생한다.
* 오류 코드를 사용하는 것보다 예외를 사용하면 예외 처리로 뺄 수 있으므로 코드가 더 깔끔해진다.
#### Try/Catch 블록 뽑아내기
* Try/Catch 블록을 사용하면 오류 처리 관련 코드가 기존 코드에서 분리되기 때문에 코드가 깔끔해진다.
* Try/Catch 블록은 코드를 알아보기 힘들기 때문에, 별도 함수로 뽑아내고 try문 안에 실제 작업을 위한 메서드를 호출한다.

#### 오류 처리도 한 가지 작업이다.
* 오류 처리를 하는 함수는 오류 처리만 해야한다.

#### Error.java 의존성 자석
* 오류를 처리하는 곳마다 오류 코드를 사용하면 enum class를 쓰게 되는데, 이런 클래스는 의존성 자석이므로 새 오류 코드를 추가하거나 변경할 때 힘들다.
* **오류 코드 대신 예외를 사용**하는 것이 좋고, 새 예외는 Exception 클래스에서 파생된다.

### 반복하지 마라
* 중복은 소프트웨어에서 모든 악의 근원이다.
* 중복이 일어나면 코드의 길이 뿐만 아니라, 수정 시 중복된 코드의 수 만큼 수정을 해야하며, 오류가 발생할 확률도 높아진다.
* 따라서 늘 중복을 없애도록 노력해야 한다.

### 구조적 프로그래밍
* 다익스트라가 만든 프로그래밍 원칙을 따르면 모든 함수와 함수 내 모든 블록에 입구와 출구는 하나만 존재해야 한다.
  * 함수는 return문이 하나여야 하며, 루프 안에서 break나 continue를 사용해선 안되며, goto는 사용하면 안된다.
* 하지만 함수가 작다면 위 원칙은 큰 이익을 제공하지 못한다.
* 그러므로 함수를 작게 만든다면 return, break, continue를 사용해도 된다.
* 오히려 단일 입/출구 규칙보다 의도를 표현하기 쉬워질 수도 있다.

### 함수를 어떻게 짜죠?
* 처음엔 길고 복잡하면서 들여쓰기 단계나 중복된 루프도 많고, 인수목록도 길다.
* 이 코드들을 테스트하는 단위 테스트 케이스도 만들면서 코드를 리팩토링 하는 과정이 필요하다.
* 소프트웨어를 짜는 것은 글짓기와 비슷하며, 결코 한번에 짜지는게 아니다.


### 결론
* 프로그래밍은 언어 설계의 기술이다.
* 대가 프로그래머는 시스템을 구현할 프로그램이 아니라 **풀어갈 이야기**로 여긴다.
* 함수가 분명하면서 이해하기 쉬운 코드를 작성함으로써 이야기를 풀어가기 쉬워진다.

## 4. 주석
### 주석은 나쁜 코드를 보완하지 못한다
* 코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문이다.
* 이런 상황에서는 **주석을 다는게 아니라 코드를 정리**해야 한다.
* 표현력이 풍부하고 깔끔하며 주석이 거의 없는 코드가, 복잡하고 어수선하며 주석이 많이 달린 코드보다 훨씬 좋다.

### 코드의 의도를 표현하라
* 코드만으로 의도를 설명하기 어려운 경우가 존재한다.
* 많은 프로그래머들은 의도를 설명할때 코드를 사용하는 것은 좋은 수단이 아니라고 생각한다.
* 아래 두 예시를 보면 아래 코드가 더 이해하기 쉽다는 것을 알 수 있다.
```java
if ((employee.flags & HOURLY_FLAG) && (employee.age > 65))
```

```java
if(employee.isEligibleForFullBenefits())
```
* 코드로 대다수 의도를 표현할 수 있고, 많은 경우 주석으로 달려는 설명을 함수로 만들어 표현해도 충분하다.

### 좋은 주석
* 어떤 주석은 필요하거나 유익하다.
  * 그래도 **정말로 좋은 주석은 주석을 달지 않을 방법을 찾아내는 것이라는 걸 명심**해야 한다.
#### 법적인 주석
* 회사가 정립한 구현 표준에 맞춰 법적인 이유로 특정 주석을 넣으라고 명시한다.
* 예로, 각 소스파일 첫 머리에 주석으로 들어가는 저작권 정보와 소유권 정보는 필요하면서 타당하다.

#### 정보를 제공하는 주석
* 때로는 기본적인 정보를 주석으로 제공하면 편리하다.
```java
// 테스트 중인 Responder 인스턴스를 반환
protected abstract Responder responderInstance();
``` 
* 위 예시는 유용한 정보를 제공해 준다.
* 하지만 responderBeingTested라는 함수 명으로 바꾸면 주석이 필요 없어진다.

```java
// kk:mm:ss EEE, MMM dd, yyyy 형식
Pattern timeMatcher = Pattern.compile("\\d*:\\d*:\\d* \\w*, \\w* \\d*, \\d*")
```
* 위 예시는 정규표현식이 시각과 날짜를 뜻한다고 설명한다.
* 이 경우도 시각과 날짜를 변환하는 클래스를 만들어 코드를 옮겨주면 더 깔끔하며 주석도 필요 없어진다.

#### 의도를 설명하는 주석
* 때로는 주석이 구현을 이해하게 도와주는 선을 넘어 결정에 깔린 의도까지 설명한다. 
* 아래 두 예시는 이러한 의도를 표현해준다.
```java
public int compareTo(Object o){
    if(o instanceof WikiPagePath){
        ...
        return compressedName.compareTo(compressedArgumentName);
    }
    return 1; // 옳은 유형이므로 정렬순위가 더 높다
}
```
```java
public void testConcurrentAddWidgets() throws Exception}{
    ...
    // 스레드를 대량 생성하는 방법으로 어떻게든 경쟁 조건을 만들려 시도한다.    
    for (int i = 0; i< 25000; i++){
        WidgetBuilderThread widgetBuilderThread = 
            new WidgetBuilderThread(widgetBuilder, text, parent, failFlag);
        Thread thread = new Thread(widgetBuilderThread);
        thread.start();
    }
    asswertEquals(false, failFlag.get());
}
```

#### 의미를 명료하게 밝히는 주석
* 때로는 모호한 인수나 반환값이 그 의미를 읽기 좋게 표현하면 이해하기 쉬워진다.
* 인수나 반환값 자체를 명확하게 만들면 더 좋지만, 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속하면 의미를 명로하게 밝히는 주석이 유용하다.
* 하지만 그릇된 주석을 달아놓을 위험은 상항히 높고, 주석이 올바른지 검증하기 쉽지 않다.
* 따라서 이러한 주석을 달 때는 더 나은 방법이 없는지 고민하고 정확히 달아야 한다.

#### 결과를 경고하는 주석
* 때로는 다른 프로그래머에게 결과를 경고할 목적으로 주석을 사용한다.
```java
// 여유 시간이 충분하지 않다면 실행하지 마십시오.
public void _testWithReallyBigFile(){
    ...
}
```
* 위 예시는 특정 테스트케이스를 꺼야 하는 이유이다.
* 요즘은 `@Ignore("실행이 너무 오래걸린다.")`와 같이 애너테이션을 이용한다.
  * JUnit4가 나오기 전엔 메서드 이름 앞에 `_`를 붙이는 방법이 관례였다.
* 아래는 더 좋은 예시이다.
```java
public static SimpleDataFormat makeStandardHttpDateFormat(){
    // SimpleDataFormat은 스레드에 안전하지 못하다.
    // 따라서 각 인스턴스를 독립적으로 생성해야 한다.
    SimpleDataFormat df = new SimpleDataFormat("EEE, dd MMM  yyyy HH:mm:ss z");
    df.setTimeZone(TimeZone.getTimeZone("GMT"));
    return df;
}
```

#### TODO 주석
* 때로는 앞으로 할 일을 `//TODO` 주석으로 남겨두면 편하다.
* 더 이상 필요 없는 기능을 삭제하라는 알림, 누군가에게 문제를 봐달라는 요청, 더 좋은 이름을 떠올려 달라는 부탁, 앞으로 발생할 이벤트에 맞춰 코드를 고치라는 주의 등에 유용하다.
  * 하지만 나쁜 코드를 남겨놓는 핑계가 되어서는 안된다.
* 대부분의 IDE에서는 TODO 주석을 전부 찾아 보여주는 기능을 제공하므로 주석을 잊어버릴 염려도 없다.
* 그러나 TODO가 남발된 코드는 바람직하지 않으므로, 주기적으로 TODO 주석을 점검해 주석을 없애야 한다.

#### 중요성을 강조하는 주석
* 자칫 **대수롭지 않다고 여겨질 뭔가의 중요성을 강조**하기 위해 주석을 사용한다.

#### 공개 API에서 Javadocs
* 설명이 잘 된 공개 API는 유용하고 만족스럽다.
* 표준 자바 라이브러리에서 사용한 Javadocs가 좋은 예다.
* 공개 API를 구현한다면 반드시 훌륭한 Javadocs를 작성한다.
* 하지만 여느 주석과 마찬가지로, Javadocs 역시 독자를 오도하거나, 잘못 위치하거나, 그릇된 정보를 전달할 가능성이 존재한다는 것을 명심해야 한다.

### 나쁜 주석
* 대다수의 주석이 이 범주에 속한다.
* 일반적으로 대다수 주석은 허술한 코드를 지탱하거나, 엉성한 코드를 변명하거나, 미숙한 결정을 합리화 하는 등의 이유로 사용된다.

#### 주절거리는 주석
* 특별한 이유 없이 의무감으로, 혹은 프로세스에서 하라고 하니까 마지못해 주석을 단다면 시간낭비이다.
* 주석을 달기로 결정했으면 충분히 시간을 들여 최고의 주석을 달도록 노력해야 한다.
* 주절거리는 식으로 주석을 단다면, 다른 코드를 찾아볼 수 밖에 없어진다.
* 이해가 안되어 다른 모듈까지 찾아봐야 하는 주석은 독자와 제대로 소통하지 못하는 주석이며, 바이트만 낭비할 뿐이다.

#### 같은 이야기를 중복하는 주석
* 헤더에 달린 주석이 같은 코드 내용을 그대로 중복하여 설명하는 경우가 있다.
* 자칫하면 코드보다 주석을 읽는 시간이 더 오래 걸린다.
* 쓸모없고 중복된 주석이 매우 많아지면 코드만 지저분하고 정신없게 만든다.

#### 오해할 여지가 있는 주석
* 때로는 의도는 좋았으나 프로그래머가 딱 맞을 정도록 엄밀하게 주석을 달지 못하기도 한다.
* 코드보다 읽기도 어려운 주석에 담긴 잘못된 정보로 인해 어느 프로그래머가 경솔하게 해당 함수를 호출하게 될 수도 있다.

#### 의무적으로 다는 주석
* 모든 함수에 javadocs를 달거나, 모든 변수에 주석을 달아야 한다는 등의 규칙은 굉장히 어리석다.
* 이런 주석은 코드를 복잡하게 만들며, 거짓말을 퍼뜨리고, 혼동과 무질서를 초래한다.

#### 이력을 기록하는 주석
* 때로는 사람들이 모듈을 편집할 때마다 모듈 첫머리에 주석을 추가한다.
* 그러면 모듈 첫머리 주석은 모듈의 가한 변경을 모두 기록하는 로그가 된다.
* 예전에는 소스코드 관리 시스템이 없었기 때문에 이러한 관리방법이 관례였지만, 이제는 혼란만 가중할 뿐이다.

#### 있으나 마나 한 주석
* 때로는 있으나 마나 한 주석을 접한다.
* 바로 너무 당연한 사실을 언급하며 새로운 정보를 제공하지 못하는 주석이다.
* 이러한 주석을 많이 쓰면, 프로그래머가 주석을 무시하는 습관에 빠지게 된다.

#### 무서운 잡음
* 때로는 Javadocs도 잡음이다.
* 어떠한 유명한 오픈 소스 라이브러리에도 목적없는 Javadocs가 많은 경우가 있다.
* 문서를 제공해야 한다는 잘못된 욕심으로 생겨난 잡음이다.

#### 함수나 변수로 표현할 수 있다면 주석을 달지 마라
* 주석을 없애고 함수나 변수로 표현할 수 있다면, 주석을 없애는게 좋다.

#### 위치를 표시하는 주석
* 때때로 프로그래머는 소스파일에서 특정 위치를 표시하려고 주석을 사용한다.
* 극히 드문 경우 그러한 주석들이 유용한 경우도 있지만, 일반적으로는 가독성만 낮추기 때문에 제거해야 한다.
* 너무 자주 사용하지 않는다면 이와 같은 주석은 눈에 띄며 주의를 환기시킬 뿐이다.

#### 닫는 괄호에 다는 주석
* 때로는 프로그래머들이 닫는 괄호에 특수한 주석을 달아놓는다.
* 중첩이 심하고 장황한 함수라면 의미가 있을지도 모르지만, 작고 캡슐화된 함수에는 잡음일 뿐이다.
* 닫는 괄호에 주석을 달아야겠다는 생각이 들게 된다면 해당 함수를 줄이려고 노력해보자.

#### 공로를 돌리거나 저자를 표시하는 주석
* 소스코드 관리 시스템은 누가 언제 무엇을 추가했는지 잘 기억한다.
* 저자 이름으로 코드를 오염시킬 필요는 없다.
* 이런 주석이 있다면 누구한테 물어봐야 할지 아니까 유용하다고 생각할 수도 있지만, 현실적으로 오랫동안 코드에 방치되어 쓸모없는 정보로 변하기 쉽다.

#### 주석으로 처리한 코드
* 주석으로 처리한 코드는 굉장히 밉살스러운 관행이다.
* 주석으로 처리된 코드는 다른 사람들이 지우기를 주저한다.
* 이유가 있어 남겨 놓은 거라고 중요하니까 지우면 안된다고 생각한다.
* 하지만 이러한 주석들로 인해 쓸모없는 코드가 점차 쌓여가게 된다.
* **소스코드 관리 시스템의 등장으로 이러한 주석은 전혀 쓸모 없어진 주석**이다.

#### HTML 주석
* 소스코드에서 HTML 주석은 IDE에서 조차 읽기 어렵다.
* 만약 Javadocs와 같은 도구로 주석을 뽑아 웹페이지에 올릴 작정이라면, 이러한 책임은 프로그래머가 아니라 도구가 져야 한다.

#### 전역 정보
* 주석을 달아야 한다면 근처에 있는 코드만 기술해야 한다.
* 코드 일부에 주석을 달면서 시스템의 전반적인 정보를 기술하면 안된다.

#### 너무 많은 정보
* 흥미로운 역사나 관련없는 정보를 장황하게 늘어놓으면 안된다.
* 독자에게 불필요하며 불가사의한 정보일 뿐이다.

#### 모호한 관계
* 주석과 주석이 설명하는 코드는 둘 사이 관계가 명백해야 한다.
* 공들여 주석을 달았으면, 독자가 주석과 코드를 보고 무슨 소리인지 알 수 있을 것이다.

#### 함수 헤더
* 짧은 함수는 긴 설명이 필요 없다.
* 짧고 한 가지만 수행하며 이름을 잘 붙인 함수가 주석으로 헤더를 추가한 함수보다 훨씬 좋다.

#### 비공개 코드에서 Javadocs
* 위 좋은 코드에서 언급한 것처럼 공개 API에서는 Javadocs가 유용하다
* 하지만 공개하지 않을 코드라면 Javadocs는 쓸모가 없고, 시스템 내부에 속한 클래스와 함수에 Javadocs를 생성할 필요가 없다.
* 코드만 보기 싫어지고 산만해질 뿐이다.

## 6. 형식 맞추기
### 형식을 맞추는 목적
* 코드 형식은 너무나도 중요해서 무시하기 힘들다.
* 너무 중요하므로, 융통성 없이 맹목적으로 따르면 안되고, 코드 형식은 의사소통의 일환이다.
* 의사소통은 전문 개발자의 의무적인 부분이다.

### 적절한 행 길이를 유지하라
* 자바에서 파일의 크기는 클래스 크기와 밀접하다.
* 클래스는 클래스를 논하는 장에서 따로 언급될 예정이고, 지금은 파일의 크기만 고려한다.
* 500줄이 넘지 않고 대부분 200줄 정도인 파일로도 커다란 시스템을 충분히 구축할 수 있다.
* 일반적으로 큰 파일보다 작은 파일이 이해하기 쉬우므로, 꼭 지키진 않더라도 바람직한 규칙 정도로 생각하면 좋다.

#### 신문 기사처럼 작성하라
* 신문은 다양한 기사로 이뤄지고, 대다수 기사는 아주 짧다.
* 어떤 기사는 조금 길지라도 한 면을 채우는 기사는 거의 없다.
* 신문이 사실, 날짜 이름 등을 무작위로 뒤섞은 긴 기사 하나만 싣는다면 아무도 읽지 않을 것이다.
* 소스 파일도 신문 기사와 마찬가지로, 이름은 간단하면서도 설명이 가능하게 짓는다.
* 소스 파일 첫 부분은 고차원 개념과 알고리즘을 설명하고, 아래로 내려갈수록 의도를 세세하게 묘사한다.
* 마지막에는 가장 저차원 함수와 세부 내역이 나온다.

#### 개념은 빈 행으로 분리하라
* 일련의 행 묶음은 완결된 생각 하나를 표현하고, 생각 사이에는 빈 행을 넣어 분리해야 마땅하다.

#### 세로 밀집도
* 줄바꿈이 개념을 분리한다면 세로 밀집도는 연관성을 의미한다.
* 서로 밀접한 코드 행은 세로로 가까이 놓여야 한다는 뜻이다.

#### 수직 거리
* 시스템이 무엇을 하는지 이해하고 싶은데, 이 조각 저 조각이 어디에 있는지 찾고 기억하느라 시간과 노력을 많이 소모하곤 한다.
* 서로 밀접한 개념은 세로로 가까이 둬야 한다.
  * 서로 다른 파일에 속한다면 위 규칙은 통하지 않지만, 타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 한다.
  * 이와같은 이유가 바로 protected 변수를 피해야 하는 이유이다.
* 같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성을 표현한다. (연관성은 한 개념을 이해하는 데 다른 개념이 중요한 정도)
* 연관성이 깊은 두 개념이 멀리 떨어져 있으면 코드를 읽는 사람이 소스 파일과 클래스를 여기저기 찾아보게 된다.

##### 변수 선언
* 변수는 사용하는 위치에 최대한 가까이 선언한다.
  * 만들게 되는 함수는 짧으므로 지역 변수는 각 함수 맨 처음에 선언한다.
* 루프를 제어하는 변수는 흔히 루프 문 내부에 선언한다.
  * 다소 긴 함수에서 블록 상단이나 루프 직전에 변수를 선언하는 사례도 있긴 하다.

##### 인스턴스 변수
* 인스턴스 변수는 클래스 맨 처음에 선언한다.
* 변수 간에 세로로 거리를 두지 않으며, 잘 설계한 클래스는 클래스의 많은 메서드가 인스턴스 변수를 사용하기 때문이다.
* 자바에서는 보통 클래스 맨 처음에 인스턴스 변수를 선언한다.

##### 종속 함수
* 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다.
* 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다.
* 이러한 규칙을 일관적으로 적용하면 독자들은 방금 호출한 함수가 잠시 후에 정의되리라는 사실을 예측할 수 있게 된다.

##### 개념적 유사성
* 개념적인 친화도가 높은 코드는 서로 끌어당기며, 이 친화도가 높을수록 코드를 가까이 배치한다.
* 이 친화도가 높은 요인은 여러가지가 있다.
  * 한 함수가 다른 함수를 호출 해 생기는 직접적인 종속성
  * 변수와 그 변수를 사용하는 함수
  * 비슷한 동작을 수행하는 일군의 함수

#### 세로 순서
* 일반적으로 함수 호출 종속성은 아래 방향으로 유지한다.
* 즉, 호출되는 함수를 호출하는 함수보다 나중에 배치한다.
* 그러면 소스 코드 모듈이 고차원에서 저차원으로 자연스럽게 넘어간다.
* 가장 중요한 개념을 먼저 표현하고, 이 때 세세한 사항을 최대한 배제하고 이 세세한 사항은 가장 마지막에 표현한다.
* 그러면 독자가 소스 파일에서 첫 함수 몇 개만 읽어도 개념을 파악하기 쉬워진다.


### 가로 형식 맞추기
* 짧은 행이 바람직하다.
* 100자~120자에 달해도 나쁘지 않지만, 그 이상은 솔직히 말해서 주의부족이다.
  * 예전에는 오른쪽으로 스크롤할 필요가 없게 코드를 짰지만, 요즘은 모니터가 크다.
  * 글자 크기까지 많이 줄여서 200자까지도 한 화면에 들어오기도 한다.
  * 하지만 이렇게 길게 사용하는 것은 권장되는 방법은 아니다.

#### 가로 공백과 밀집도

# 클린 코드
## 1. 깨끗한 코드
### 코드가 존재하리라
* 코드는 요구사항을 상세히 표현하는 수단이다.
* 어느 수준에 이르면 코드의 도움 없이 요구사항을 상세히 표현하기는 불가능하다.
* 추상화도 불가능하다.
* 고도로 추상화된 언어나 특정 응용 분야 언어로 기술하는 명세 역시 코드이므로 결코 코드는 사라지지 않는다.

### 나쁜 코드
* killer app 하나로 대박난 회사가 망한일이 있었다.
  * 그 원인은 나쁜 코드였다.
  * 출시에 바빠 코드를 대책없이 짜서 기능을 추가할수록 코드가 점점 엉망이 되었기 때문이다.
* 우리는 나쁜 코드들을 방치하고 나중에 수정하기로 마음먹고 넘어가지만, 그 나중은 결코 오지 않는다. (르블랑의 법칙 - 나중은 결코 오지 않는다.)

### 나쁜 코드로 치르는 대가
* 나쁜 코드가 쌓일 수록 팀의 생산성은 떨어지게 된다.
* 나쁜 코드는 코드를 고칠 때마다 또 다른 엉뚱한 곳에서 문제가 생긴다.
* 생산성을 증가시키기 위해 투입되는 신규 인력들은 시스템 설계 의도를 분명하게 알지 못해 더 많은 나쁜 코드들을 양산하게 된다.
#### 원대한 재설계의 꿈
* 나쁜 코드에 의해 생산성이 바닥이 되면 되면 재설계를 하는 경우가 생긴다.
* 그러나 이 경우 기존 시스템 기능을 모두 제공하는 새 시스템을 만들며 기존 시스템에 가해지는 변경사항까지 모두 반영해야 한다.
* 새 시스템이 기존 시스템을 따라 잡을 때 쯤이면 재설계팀은 팀을 떠나고, 새로운 팀원들이 새 시스템을 설계하고자 한다.
* 바로 현재 시스템이 너무 엉망이기 때문이다.
* 따라서 이러한 문제를 일으키지 않기 위해 처음부터 깨끗한 코드를 만들어야 한다.

#### 태도
* 나쁜 코드의 위험을 이해하지 못하는 관리자의 말을 그대로 따르는 행동은 전문가 답지 못하다.
* 나쁜 코드가 되는 이유는 요구사항과 일정, 관리자와 마케팅등의 잘못이라고 할 수 없고, 프로그래머가 전문가 답지 못했기 때문이다.
* 프로젝트 실패는 프로그래머에게도 큰 책임이 있고, 특히 나쁜 코드가 초래하는 실패에는 더더욱 책임이 크다.

#### 원초적 난제
* 프로그래머가 기한을 맞추려면 나쁜코드를 양산할 수 밖에 없는건 아니다.
* 오히려 나쁜코드를 양산하면 기한을 맞추지 못한다.
* 기한을 맞추는 유일한 방법은 언제나 코드를 깨끗하게 유지하는 습관이다.

#### 깨끗한 코드라는 예술?
* 깨끗한 코드가 무엇인지 모르면 깨끗한 코드를 만들려고 노력해봤자 소용 없다.
* 깨끗한 코드를 작성하려면 청결이라는 힘겹게 습득한 감각을 활용해 다양한 기법들을 적용하는 절제와 규율이 필요하며, 그 열쇠는 코드 감각이다.
* 코드 감각이 있으면 좋은 코드와 나쁜 코드를 구분할 수 있다.
* 코드 감각이 있으면 절제와 규율을 적용해 나쁜 코드를 좋은 코드로 바꾸는 전략도 파악할 수 있다.

#### 깨끗한 코드란?
* 나는 깨끗한 코드란 코드의 성능이 좋으면서도 코드의 가독성이 좋은 코드라고 생각한다. 
* 하지만 이 질문에 대한 답은 모든 프로그래머들이 생각하는게 다를 것이다.
* 다음은 각 분야의 유명한 프로그래머들의 깨끗한 코드에 대한 의견이다.
##### 비야네 스트롭스트룹
* C++의 창시자이자이며, C++ Programing Language의 저자이다.
> "나는 우아하고 효율적인 코드를 좋아한다. 논리가 간단해야 버그가 숨어들지 못한다. 성능을 최적으로 유지해야 사람들이 원칙없는 최적화로 코드를 망치려는 유혹에 빠지지 않는다. 깨끗한 코드는 한 가지를 제대로 한다."

##### 그래디 부치
* UML을 개발하였으며, object oriented design: with applications의 저자이다.
> "깨끗한 코드는 단순하고 직접적이다. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다. 깨끗한 코드는 설계자의 의도를 숨기지 않는다. 오히려 명쾌한 추상화와 단순한 제어문으로 가득하다."

##### 데이브 토마스
* OTI 창립자이자 이클립스 전략의 대부이다.
> "깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다. 깨끗한 코드에는 의미 있는 이름이 붙는다. 특정 목적을 달성하는 방법은 하나만 제공한다.의존성은 최소이며 각 의존성을 명확히 정의한다. API는 명확하며 최소로 줄였다. 사람이 읽기 좋은 코드를 작성한 것이 좋은 코드이다."


##### 마이클 페더스
* Working Effectively with Legacy Code의 저자이다.
> "깨끗한 코드의 특징은 많지만, 그 중에서도 모두를 아우르는 특징이 하나 있다. 깨끗한 코드는 언제나 누군가 주의 깊게 짰다는 느낌을 준다. 고치려고 살펴봐도 딱히 손 댈 곳이 없다."

##### 존 제프리스
* Extreme Programming Installed 와 Extreme Programming Adventure in C#의 저자이다.
> "모든 테스트를 통과한다. 중복이 없다. 시스템 내 모든 설계 아이디어를 표현한다. 클래스, 메서드, 함수 등을 최대한 줄인다."

##### 워드 커닝햄
* wiki 창시자
> "코드를 읽으면서 짐작했던 기능을 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. 코드가 그 문제를 풀기위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다."

### 보이스카우트 규칙
* 잘 짠 코드가 전부가 아니다. 시간이 지나도 언제나 깨끗하게 유지해야 한다.
* **캠프장은 처음 왔을때 보다 더 깨끗하게 해놓고 떠나라.**
* 한꺼번에 많은 시간과 노력을 투자해 코드를 정리할 필요가 없다.
* 변수 이름 하나 개선하고, 조금 긴 함수 하나 분할하고, 약간의 중복을 제거하고, 복잡한 if문 하나를 정리하면 충분하다.

## 2. 의미 있는 이름
### 의도를 분명히 밝혀라
* 의도가 분명한 이름은 코드를 읽는 사람에게 보다 많은 정보를 주기 때문에, 코드 이해와 변경이 쉬워진다.
* 의미없는 이름을 갖고 있는 함수에서 이름만 고쳐도 함수가 하는 일을 이해하기 더 쉬워진다.

### 그릇된 정보는 피해라
* 프로그래머는 코드에 그릇된 단서를 남겨선 안된다.
* 그릇된 의미는 코드를 읽는 사람에게 혼돈을 줄 수 있으며, 널리 쓰이는 의미가 있는 단어를 다른 의미로 사용하면 안된다.
  * 예시로 여러 계정을 그룹으로 묶을 때 실제 List 자료구조가 아니라면 accountList라는 이름을 사용하면 안된다.
* 서로 규칙 없이 흡사한 이름을 쓰지 않아야 한다.
  * 일관성 있고 규칙있게 사용한 이름은 의미를 이해하는데 정보를 전달 해 주지만 그런 규칙이 없으면 혼돈을 줄 수 있다.

### 의미 있게 구분하라
* 이름을 지을 땐 의미있는 정보를 기반으로 이름을 지어야 한다. (불용어를 추가하면 안된다.)
* 컴파일이나 인터프리터만 통과하려는 생각으로 코드를 구현하면 안된다.
* 예를 들면 연속적인 숫자를 덧붙인 이름으로 지으면 안된다. (a1, a2, a3)
* ProductInfo, ProductData라는 이름으로 지으면 안된다.
  * 이미 Product라는 이름으로 충분한 의미를 제공하고 있는데 굳이 중복해서 Info와 Data를 붙일 필요가 없다.
* NameString과 같은 이름도 지으면 안된다.
  * Name과 별다른 차이가 없다.

### 발음하기 쉬운 이름을 사용해라
* 프로그래밍은 사회 활동이다.
* 서로 의논하기 쉽게 발음하기 쉬운 이름을 사용해야 소통에 좋다.

### 검색하기 쉬운 이름을 사용해라
* 문자 하나를 사용하는 이름 또는 상수는 코드 내에서 검색하기 힘들다.
* 이런 경우 검색을 하면 여러가지 경우의 수와 연관해서 볼 수 있다.
  * 찾아서 고치기 힘들어진다.
* 한 문자를 사용할거면, 간단한 메서드에서 로컬 변수의 경우 정도에서만 사용하면 좋다.
* 또한 생소한 단어를 써도 검색하기 힘들다.

### 인코딩을 피해라
* 굳이 부담을 더하지 않아도 이름에 인코딩할 정보는 충분히 많다.
* 따라서 접두어를 통해 범위 정보까지 인코딩에 넣지 않아야 한다.
* 타입을 변수명에 명시하지 마라 (헝가리식 표기법)
* 이름을 다르게 하지 않아도 멤버 변수임을 확인할 수 있어야 한다.
  * m_등의 접두어를 붙이지 말자.
* 때로는 인코딩이 필요한 경우도 있다.
  * 인터페이스와 클래스의 경우 클래스에 Impl 접미어는 필요할 수 있다. (클래스의 이름이 정보를 인코딩하자)

### 자신의 기억력을 과시하지 마라
* 코드를 읽는 사람이 머리속으로 한번 더 생각해 변환해야 할만한 변수명을 쓰지 않아야한다.
* 한 글자의 이름들(i, j, k 등)은 루프에서만 써야한다.
  * 기억은 영원하지 않다.

### 클래스 이름, 메서드 이름
* 클래스 이름은 명사구로 쓰고 메서드의 이름은 동사구로 쓴다.
  * 클래스 : Customer, Account 등
  * 메서드 : postPayment, save 등

### 기발한 이름은 피하라
* 기발한 이름과 잘 사용되지 않은 단어를 쓰는 이름은 피해야 한다.

### 한 개념에 한 단어를 사용하라
* 똑같은 메서드를 클래스마다 fetch retrieve get 등으로 제각각 부르면 혼란스럽다.
* 일관성 있는 단어를 사용해야 한다.

### 말장난을 하지 마라
* 어떤 클래스에서는 add메서드가 두 값을 더하는 것이고, 다른 메서드에서는 기본 값에 더하기를 하는 것이라면 두 메서드는 반드시 다르게 명명해야 한다.
* 즉 한 단어를 두가지 목적으로 사용하지 않아야 한다.

### 해법 영역에서 가져온 이름을 사용하라
* 코드를 읽을 사람도 프로그래머이다.
* 그러므로 전산 용어, 알고리즘 이름, 패턴 이름, 수학 용어 이름등을 사용해도 좋다.
* 예로 Visitor pattern에 친숙한 프로그래머라면 AccountVisitor라는 이름은 금방 이해한다.

### 문제 영역에서 가져온 이름을 사용하라
* 적절한 프로그래머 용어가 없거나 문제 영역과 관련이 깊은 용어의 경우 문제 영역 용어를 사용하면 좋다.
* 코드를 보수하는 프로그래머가 전문가에게 의미를 물어봐서 파악할 수 있다.

### 의미있는 맥락을 추가하라
* 스스로 의미가 분명한 이름은 있지만, 그렇지 못한 이름도 있다.
* 예로 firstName, lastName, address, state, city, zipcode와 같은 맥락이 있다면 state가 무슨 의미인지 알 수 있지만, state만 있다면 무슨 의미인지 알기 힘들다.
* 따라서 addrFirstName, addrLastName, addrState라고 쓰는게 좀 더 명확하고 좋다.

### 불필요한 맥락을 없애라
* 넓은 맥락을 가진 이름은 사용하지 않는게 좋다.
* 또한 `Gas station Delux`라는 어플리케이션을 작성한다고 해서 클래스 이름 앞에 GSD를 붙이지 않아야 한다.
  * 자동 완성시에도 모든 클래스가 나타나는 등 효율적이지 못하다.
  * 접두어를 붙이는 것은 모듈의 재사용 관점에서도 좋지 못하다.
  * 재사용하려면 이름을 바꿔야 한다. (GSDAccountAddrees 대신 Address라고만 해도 충분하다.)

## 3. 함수
### 작게 만들어라
* 함수를 만드는 첫 번째 규칙은 '작게'이고, 두 번째 규칙은 '더 작게'이다.
* if문, else문, while문 등에 들어가는 블록은 한 줄이어야 한다.
* 주로 거기서 함수를 호출하기 때문에 중첩 구조가 생길 만큼 함수가 커져서는 안된다.
* 함수에서 들여쓰기 수준은 1~2단을 넘어서면 안된다.

### 한 가지만 해라
* 함수는 한가지를 해야하며, 그 한가지를 잘해야 하고, 그 한가지만을 해야 한다.
* 즉 지정된 함수 이름 알에서 추상화 수준이 하나인 단계만 수행해야 한다.
* 함수를 만드는 큰 이유는 큰 개념을 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서 이다.
* 의미있는 이름으로 다른 함수를 추출할 수 있으면 그 함수는 여러 작업을 하는 것이다.
* 한 가지 작업만 하는 함수는 섹션으로 나눠지지 않는다.

### 함수 당 추상화 수준은 하나로
* 한 함수 내에 추상화 수준이 섞여있으면 코드를 읽는 사람이 이해하기 어려워진다.
* 코드는 위에서 아래로 이야기처럼 읽혀야 좋다.
  * 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.

### Switch 문
* Switch 문은 작게 만들기 어렵다.
* 함수가 크게 될수도 있고, Switch문을 포함한 함수를 한 가지 일로 추상화 하는게 어려울 수 있다.
* 본질적으로 switch 문은 N 가지를 처리한다.
```java
 public Money calculatePay(Employee e) throws InvalidEmployeeType{
        switch(e.type){
        case COMMISIONED:
            return calculateComissionedPay(e);
        case HOURLY:
            return calculateHourlyPay(e);
        case SALARIED:
            return calculateSalariedPay(e);
        default:
            throw new InvalidEmployeeType(e.type);
        }
}
```
* 위 예시는 직원 유형에 따라 다른 값을 반환하는 함수이다.
  * SRP를 잘 따른다.
  * 하지만 직원 유형이 추가되면 이 함수에도 추가해야 하며, 직원이 수정되면 이 함수도 수정해야 한다.
  * 즉 OCP를 위반한다.
```java
public Money calculatePay(Employee e){
      return e.calculatePay();
}
```
* 위와 같이 다형성을 이용하면 직원 유형이 추가되고 수정되어도 변경할 사항이 없어진다.
* 이런 구조를 사용하기 위해 DI나 직원 유형에 따라 직원을 생성해주는 클래스가 필요하다. 
  ```java
  public abstract class Employee{
	public Money calculatePay(); 
  }

  public interface EmployeeFactory(){
      public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType
  }

  public class EmployeeFactoryImpl implements EmployeeFactory{
      public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType{
          switch(e.type){
          case COMMISIONED: 
              return new CommisionedEmpolyee();
          case HOURLY: 
              return new HourlyEmployee();
          case SALARIED: 
              return new SalariedEmployee();
          default:
              throw new InvalidEmployeeType(e.type);
          }
      }
  } 
  ```
    * Switch문은 여전히 사용되지만 딱 한 번의 Switch문이다. (한 번 정도는 참아줄 수 있다.)

### 서술적인 이름을 사용하라
* 함수의 이름을 읽고나서 예측한 동작과 함수의 동작이 같다면 좋은 코드이다.
* 길고 서술적인 이름이 짧고 어려운 이름보다 좋다.
* 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.
* 함수 이름을 붙일 때, 여러 단어가 쉽게 읽히면서 그 여러 단어들로 함수 기능을 잘 표현할 수 있도록 해야 한다.
* 또한 이름을 붙일 때는 일관성이 있어야 한다. 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.
### 함수 인수
* 함수에서 이상적인 인수 개수는 0개이다.
* 인수가 늘어날 수록 함수를 읽는 사람은 인수까지 생각해 동작을 예측해야 한다.
* 따라서 인수의 개수는 적을수록 좋고, 3개 이상의 인수는 피하는게 좋다.
* 테스트 관점에서도 인수가 많을수록, 인수마다 유효한 값으로 모든 조합을 만들어 테스트 하기 힘들어진다.
#### 많이 쓰는 단항 형식
* 인수에 질문을 던지는 경우 `boolean fileExites("MyFile")`
* 인수를 뭔가로 변환해 결과를 반환하는 경우 `InputStream fileOpne("MyFile")`
#### 플래그 인수
* 함수에 플래그인수는 사용하지 않아야 한다.
* 함수가 여러개의 일을 처리한다고 대놓고 공표하는 것과 같다.
#### 이항 함수
* 인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다.
* 예로 `writeField(name)`보다 `writeField(outputStream, name)`이 더 이해하기 어렵다.
* 이항 함수를 만들어야 하는 불가피한 경우가 생길 수 있지만, 가능하다면 단항 함수로 바꿔야 한다.
* writeField 메서드를 outputStream 클래스 구성원으로 만들어 outputStream.writeField(name)으로 호출하게 만들어야 한다.
* 2개의 인수간의 자연적인 순서가 있는경우에는 이항 함수가 적절할 수 있다.
  * `Point p = new Point(x,y);`

#### 삼항 함수
* 인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다.
* 삼항 함수를 만들 때는 신중이 고려해야 한다.
* 일부 인수들을 묶어 하나의 클래스 변수로 만들 수 있는지를 확인하는게 좋다.

#### 인수 객체
* 인수가 2~3개가 필요하다면 일부를 독자적인 클래스 변수로 만들어서 사용할 수 있다.
* 추상화 한 개념을 표현한 것이다.

#### 인수 목록
* `String.format()`과 같은 함수들 처럼 인수 개수가 가변적인 함수도 필요하다.
* `STring.format()`의 인수도 List형 인수이기 때문에 이항함수라고 할 수 있다.

#### 동사와 키워드
* 함수의 의도 및 인수의 순서까지 제대로 표현하기 위해선 좋은 이름이 필요하다.
* 단항 함수라면 동사 / 명사 위주로 표한혀는게 좋다.
  * `writeField(name)`
* 함수의 키워드를 추가해 인수를 예측할 수 있도록 하는게 좋다.
  * `asswertExpectedEqualsActual(expected, actual);`
### 부수 효과를 일으키지 마라
* 함수에서는 딱 한가지만 수행해야 한다.
  * 한가지 일만 하기로 했는데 부수 효과를 일으키는 다른 일은 하면 안된다.
* 부수효과가 꼭 일어나야 된다면 이름에 어떠한 부수 효과를 일으키는지 명시해야 한다.
#### 출력 인수
* 일반적으로 출력 인수는 피해야 한다.
* 함수의 인수를 입력으로 이용하되 출력으로까지 이용하면 어색해진다.
* 인수를 변경해야 하는 일이 있다면 this를 이용해 함수가 속한 객체 상태를 변경하는 방식을 사용하면 된다.
### 명령과 조회를 분리하라
* 함수는 뭔가를 수행하거나, 뭔가를 답을 주거나 둘 중 하나만 해야 한다. (한 가지 일만 해야한다.)
* 두 가지를 모두 하게 되면 혼란을 줄 수 있으므로, 명령과 조회를 분리해 혼란을 주지 않도록 해야한다.
```java
// 나쁜 예시
if(set("username", "myname")){
    ...
}
// 좋은 예시
if(attributeExists("username")){
    setAttribute("username", "myname");
    ...
}
```
### 오류 코드보다 예외를 사용하라
* 오류 코드를 반환하는 방식은 여러 단계로 중첩되는 코드를 만들게 되고, 오류 코드를 바로 처리해야 한다는 문제가 발생한다.
* 오류 코드를 사용하는 것보다 예외를 사용하면 예외 처리로 뺄 수 있으므로 코드가 더 깔끔해진다.
#### Try/Catch 블록 뽑아내기
* Try/Catch 블록을 사용하면 오류 처리 관련 코드가 기존 코드에서 분리되기 때문에 코드가 깔끔해진다.
* Try/Catch 블록은 코드를 알아보기 힘들기 때문에, 별도 함수로 뽑아내고 try문 안에 실제 작업을 위한 메서드를 호출한다.

#### 오류 처리도 한 가지 작업이다.
* 오류 처리를 하는 함수는 오류 처리만 해야한다.

#### Error.java 의존성 자석
* 오류를 처리하는 곳마다 오류 코드를 사용하면 enum class를 쓰게 되는데, 이런 클래스는 의존성 자석이므로 새 오류 코드를 추가하거나 변경할 때 힘들다.
* **오류 코드 대신 예외를 사용**하는 것이 좋고, 새 예외는 Exception 클래스에서 파생된다.

### 반복하지 마라
* 중복은 소프트웨어에서 모든 악의 근원이다.
* 중복이 일어나면 코드의 길이 뿐만 아니라, 수정 시 중복된 코드의 수 만큼 수정을 해야하며, 오류가 발생할 확률도 높아진다.
* 따라서 늘 중복을 없애도록 노력해야 한다.

### 구조적 프로그래밍
* 다익스트라가 만든 프로그래밍 원칙을 따르면 모든 함수와 함수 내 모든 블록에 입구와 출구는 하나만 존재해야 한다.
  * 함수는 return문이 하나여야 하며, 루프 안에서 break나 continue를 사용해선 안되며, goto는 사용하면 안된다.
* 하지만 함수가 작다면 위 원칙은 큰 이익을 제공하지 못한다.
* 그러므로 함수를 작게 만든다면 return, break, continue를 사용해도 된다.
* 오히려 단일 입/출구 규칙보다 의도를 표현하기 쉬워질 수도 있다.

### 함수를 어떻게 짜죠?
* 처음엔 길고 복잡하면서 들여쓰기 단계나 중복된 루프도 많고, 인수목록도 길다.
* 이 코드들을 테스트하는 단위 테스트 케이스도 만들면서 코드를 리팩토링 하는 과정이 필요하다.
* 소프트웨어를 짜는 것은 글짓기와 비슷하며, 결코 한번에 짜지는게 아니다.


### 결론
* 프로그래밍은 언어 설계의 기술이다.
* 대가 프로그래머는 시스템을 구현할 프로그램이 아니라 **풀어갈 이야기**로 여긴다.
* 함수가 분명하면서 이해하기 쉬운 코드를 작성함으로써 이야기를 풀어가기 쉬워진다.

## 4. 주석
### 주석은 나쁜 코드를 보완하지 못한다
* 코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문이다.
* 이런 상황에서는 **주석을 다는게 아니라 코드를 정리**해야 한다.
* 표현력이 풍부하고 깔끔하며 주석이 거의 없는 코드가, 복잡하고 어수선하며 주석이 많이 달린 코드보다 훨씬 좋다.

### 코드의 의도를 표현하라
* 코드만으로 의도를 설명하기 어려운 경우가 존재한다.
* 많은 프로그래머들은 의도를 설명할때 코드를 사용하는 것은 좋은 수단이 아니라고 생각한다.
* 아래 두 예시를 보면 아래 코드가 더 이해하기 쉽다는 것을 알 수 있다.
```java
if ((employee.flags & HOURLY_FLAG) && (employee.age > 65))
```

```java
if(employee.isEligibleForFullBenefits())
```
* 코드로 대다수 의도를 표현할 수 있고, 많은 경우 주석으로 달려는 설명을 함수로 만들어 표현해도 충분하다.

### 좋은 주석
* 어떤 주석은 필요하거나 유익하다.
  * 그래도 **정말로 좋은 주석은 주석을 달지 않을 방법을 찾아내는 것이라는 걸 명심**해야 한다.
#### 법적인 주석
* 회사가 정립한 구현 표준에 맞춰 법적인 이유로 특정 주석을 넣으라고 명시한다.
* 예로, 각 소스파일 첫 머리에 주석으로 들어가는 저작권 정보와 소유권 정보는 필요하면서 타당하다.

#### 정보를 제공하는 주석
* 때로는 기본적인 정보를 주석으로 제공하면 편리하다.
```java
// 테스트 중인 Responder 인스턴스를 반환
protected abstract Responder responderInstance();
``` 
* 위 예시는 유용한 정보를 제공해 준다.
* 하지만 responderBeingTested라는 함수 명으로 바꾸면 주석이 필요 없어진다.

```java
// kk:mm:ss EEE, MMM dd, yyyy 형식
Pattern timeMatcher = Pattern.compile("\\d*:\\d*:\\d* \\w*, \\w* \\d*, \\d*")
```
* 위 예시는 정규표현식이 시각과 날짜를 뜻한다고 설명한다.
* 이 경우도 시각과 날짜를 변환하는 클래스를 만들어 코드를 옮겨주면 더 깔끔하며 주석도 필요 없어진다.

#### 의도를 설명하는 주석
* 때로는 주석이 구현을 이해하게 도와주는 선을 넘어 결정에 깔린 의도까지 설명한다. 
* 아래 두 예시는 이러한 의도를 표현해준다.
```java
public int compareTo(Object o){
    if(o instanceof WikiPagePath){
        ...
        return compressedName.compareTo(compressedArgumentName);
    }
    return 1; // 옳은 유형이므로 정렬순위가 더 높다
}
```
```java
public void testConcurrentAddWidgets() throws Exception}{
    ...
    // 스레드를 대량 생성하는 방법으로 어떻게든 경쟁 조건을 만들려 시도한다.    
    for (int i = 0; i< 25000; i++){
        WidgetBuilderThread widgetBuilderThread = 
            new WidgetBuilderThread(widgetBuilder, text, parent, failFlag);
        Thread thread = new Thread(widgetBuilderThread);
        thread.start();
    }
    asswertEquals(false, failFlag.get());
}
```

#### 의미를 명료하게 밝히는 주석
* 때로는 모호한 인수나 반환값이 그 의미를 읽기 좋게 표현하면 이해하기 쉬워진다.
* 인수나 반환값 자체를 명확하게 만들면 더 좋지만, 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속하면 의미를 명로하게 밝히는 주석이 유용하다.
* 하지만 그릇된 주석을 달아놓을 위험은 상항히 높고, 주석이 올바른지 검증하기 쉽지 않다.
* 따라서 이러한 주석을 달 때는 더 나은 방법이 없는지 고민하고 정확히 달아야 한다.

#### 결과를 경고하는 주석
* 때로는 다른 프로그래머에게 결과를 경고할 목적으로 주석을 사용한다.
```java
// 여유 시간이 충분하지 않다면 실행하지 마십시오.
public void _testWithReallyBigFile(){
    ...
}
```
* 위 예시는 특정 테스트케이스를 꺼야 하는 이유이다.
* 요즘은 `@Ignore("실행이 너무 오래걸린다.")`와 같이 애너테이션을 이용한다.
  * JUnit4가 나오기 전엔 메서드 이름 앞에 `_`를 붙이는 방법이 관례였다.
* 아래는 더 좋은 예시이다.
```java
public static SimpleDataFormat makeStandardHttpDateFormat(){
    // SimpleDataFormat은 스레드에 안전하지 못하다.
    // 따라서 각 인스턴스를 독립적으로 생성해야 한다.
    SimpleDataFormat df = new SimpleDataFormat("EEE, dd MMM  yyyy HH:mm:ss z");
    df.setTimeZone(TimeZone.getTimeZone("GMT"));
    return df;
}
```

#### TODO 주석
* 때로는 앞으로 할 일을 `//TODO` 주석으로 남겨두면 편하다.
* 더 이상 필요 없는 기능을 삭제하라는 알림, 누군가에게 문제를 봐달라는 요청, 더 좋은 이름을 떠올려 달라는 부탁, 앞으로 발생할 이벤트에 맞춰 코드를 고치라는 주의 등에 유용하다.
  * 하지만 나쁜 코드를 남겨놓는 핑계가 되어서는 안된다.
* 대부분의 IDE에서는 TODO 주석을 전부 찾아 보여주는 기능을 제공하므로 주석을 잊어버릴 염려도 없다.
* 그러나 TODO가 남발된 코드는 바람직하지 않으므로, 주기적으로 TODO 주석을 점검해 주석을 없애야 한다.

#### 중요성을 강조하는 주석
* 자칫 **대수롭지 않다고 여겨질 뭔가의 중요성을 강조**하기 위해 주석을 사용한다.

#### 공개 API에서 Javadocs
* 설명이 잘 된 공개 API는 유용하고 만족스럽다.
* 표준 자바 라이브러리에서 사용한 Javadocs가 좋은 예다.
* 공개 API를 구현한다면 반드시 훌륭한 Javadocs를 작성한다.
* 하지만 여느 주석과 마찬가지로, Javadocs 역시 독자를 오도하거나, 잘못 위치하거나, 그릇된 정보를 전달할 가능성이 존재한다는 것을 명심해야 한다.

### 나쁜 주석
* 대다수의 주석이 이 범주에 속한다.
* 일반적으로 대다수 주석은 허술한 코드를 지탱하거나, 엉성한 코드를 변명하거나, 미숙한 결정을 합리화 하는 등의 이유로 사용된다.

#### 주절거리는 주석
* 특별한 이유 없이 의무감으로, 혹은 프로세스에서 하라고 하니까 마지못해 주석을 단다면 시간낭비이다.
* 주석을 달기로 결정했으면 충분히 시간을 들여 최고의 주석을 달도록 노력해야 한다.
* 주절거리는 식으로 주석을 단다면, 다른 코드를 찾아볼 수 밖에 없어진다.
* 이해가 안되어 다른 모듈까지 찾아봐야 하는 주석은 독자와 제대로 소통하지 못하는 주석이며, 바이트만 낭비할 뿐이다.

#### 같은 이야기를 중복하는 주석
* 헤더에 달린 주석이 같은 코드 내용을 그대로 중복하여 설명하는 경우가 있다.
* 자칫하면 코드보다 주석을 읽는 시간이 더 오래 걸린다.
* 쓸모없고 중복된 주석이 매우 많아지면 코드만 지저분하고 정신없게 만든다.

#### 오해할 여지가 있는 주석
* 때로는 의도는 좋았으나 프로그래머가 딱 맞을 정도록 엄밀하게 주석을 달지 못하기도 한다.
* 코드보다 읽기도 어려운 주석에 담긴 잘못된 정보로 인해 어느 프로그래머가 경솔하게 해당 함수를 호출하게 될 수도 있다.

#### 의무적으로 다는 주석
* 모든 함수에 javadocs를 달거나, 모든 변수에 주석을 달아야 한다는 등의 규칙은 굉장히 어리석다.
* 이런 주석은 코드를 복잡하게 만들며, 거짓말을 퍼뜨리고, 혼동과 무질서를 초래한다.

#### 이력을 기록하는 주석
* 때로는 사람들이 모듈을 편집할 때마다 모듈 첫머리에 주석을 추가한다.
* 그러면 모듈 첫머리 주석은 모듈의 가한 변경을 모두 기록하는 로그가 된다.
* 예전에는 소스코드 관리 시스템이 없었기 때문에 이러한 관리방법이 관례였지만, 이제는 혼란만 가중할 뿐이다.

#### 있으나 마나 한 주석
* 때로는 있으나 마나 한 주석을 접한다.
* 바로 너무 당연한 사실을 언급하며 새로운 정보를 제공하지 못하는 주석이다.
* 이러한 주석을 많이 쓰면, 프로그래머가 주석을 무시하는 습관에 빠지게 된다.

#### 무서운 잡음
* 때로는 Javadocs도 잡음이다.
* 어떠한 유명한 오픈 소스 라이브러리에도 목적없는 Javadocs가 많은 경우가 있다.
* 문서를 제공해야 한다는 잘못된 욕심으로 생겨난 잡음이다.

#### 함수나 변수로 표현할 수 있다면 주석을 달지 마라
* 주석을 없애고 함수나 변수로 표현할 수 있다면, 주석을 없애는게 좋다.

#### 위치를 표시하는 주석
* 때때로 프로그래머는 소스파일에서 특정 위치를 표시하려고 주석을 사용한다.
* 극히 드문 경우 그러한 주석들이 유용한 경우도 있지만, 일반적으로는 가독성만 낮추기 때문에 제거해야 한다.
* 너무 자주 사용하지 않는다면 이와 같은 주석은 눈에 띄며 주의를 환기시킬 뿐이다.

#### 닫는 괄호에 다는 주석
* 때로는 프로그래머들이 닫는 괄호에 특수한 주석을 달아놓는다.
* 중첩이 심하고 장황한 함수라면 의미가 있을지도 모르지만, 작고 캡슐화된 함수에는 잡음일 뿐이다.
* 닫는 괄호에 주석을 달아야겠다는 생각이 들게 된다면 해당 함수를 줄이려고 노력해보자.

#### 공로를 돌리거나 저자를 표시하는 주석
* 소스코드 관리 시스템은 누가 언제 무엇을 추가했는지 잘 기억한다.
* 저자 이름으로 코드를 오염시킬 필요는 없다.
* 이런 주석이 있다면 누구한테 물어봐야 할지 아니까 유용하다고 생각할 수도 있지만, 현실적으로 오랫동안 코드에 방치되어 쓸모없는 정보로 변하기 쉽다.

#### 주석으로 처리한 코드
* 주석으로 처리한 코드는 굉장히 밉살스러운 관행이다.
* 주석으로 처리된 코드는 다른 사람들이 지우기를 주저한다.
* 이유가 있어 남겨 놓은 거라고 중요하니까 지우면 안된다고 생각한다.
* 하지만 이러한 주석들로 인해 쓸모없는 코드가 점차 쌓여가게 된다.
* **소스코드 관리 시스템의 등장으로 이러한 주석은 전혀 쓸모 없어진 주석**이다.

#### HTML 주석
* 소스코드에서 HTML 주석은 IDE에서 조차 읽기 어렵다.
* 만약 Javadocs와 같은 도구로 주석을 뽑아 웹페이지에 올릴 작정이라면, 이러한 책임은 프로그래머가 아니라 도구가 져야 한다.

#### 전역 정보
* 주석을 달아야 한다면 근처에 있는 코드만 기술해야 한다.
* 코드 일부에 주석을 달면서 시스템의 전반적인 정보를 기술하면 안된다.

#### 너무 많은 정보
* 흥미로운 역사나 관련없는 정보를 장황하게 늘어놓으면 안된다.
* 독자에게 불필요하며 불가사의한 정보일 뿐이다.

#### 모호한 관계
* 주석과 주석이 설명하는 코드는 둘 사이 관계가 명백해야 한다.
* 공들여 주석을 달았으면, 독자가 주석과 코드를 보고 무슨 소리인지 알 수 있을 것이다.

#### 함수 헤더
* 짧은 함수는 긴 설명이 필요 없다.
* 짧고 한 가지만 수행하며 이름을 잘 붙인 함수가 주석으로 헤더를 추가한 함수보다 훨씬 좋다.

#### 비공개 코드에서 Javadocs
* 위 좋은 코드에서 언급한 것처럼 공개 API에서는 Javadocs가 유용하다
* 하지만 공개하지 않을 코드라면 Javadocs는 쓸모가 없고, 시스템 내부에 속한 클래스와 함수에 Javadocs를 생성할 필요가 없다.
* 코드만 보기 싫어지고 산만해질 뿐이다.

## 5. 형식 맞추기
### 형식을 맞추는 목적
* 코드 형식은 너무나도 중요해서 무시하기 힘들다.
* 너무 중요하므로, 융통성 없이 맹목적으로 따르면 안되고, 코드 형식은 의사소통의 일환이다.
* 의사소통은 전문 개발자의 의무적인 부분이다.

### 적절한 행 길이를 유지하라
* 자바에서 파일의 크기는 클래스 크기와 밀접하다.
* 클래스는 클래스를 논하는 장에서 따로 언급될 예정이고, 지금은 파일의 크기만 고려한다.
* 500줄이 넘지 않고 대부분 200줄 정도인 파일로도 커다란 시스템을 충분히 구축할 수 있다.
* 일반적으로 큰 파일보다 작은 파일이 이해하기 쉬우므로, 꼭 지키진 않더라도 바람직한 규칙 정도로 생각하면 좋다.

#### 신문 기사처럼 작성하라
* 신문은 다양한 기사로 이뤄지고, 대다수 기사는 아주 짧다.
* 어떤 기사는 조금 길지라도 한 면을 채우는 기사는 거의 없다.
* 신문이 사실, 날짜 이름 등을 무작위로 뒤섞은 긴 기사 하나만 싣는다면 아무도 읽지 않을 것이다.
* 소스 파일도 신문 기사와 마찬가지로, 이름은 간단하면서도 설명이 가능하게 짓는다.
* 소스 파일 첫 부분은 고차원 개념과 알고리즘을 설명하고, 아래로 내려갈수록 의도를 세세하게 묘사한다.
* 마지막에는 가장 저차원 함수와 세부 내역이 나온다.

#### 개념은 빈 행으로 분리하라
* 일련의 행 묶음은 완결된 생각 하나를 표현하고, 생각 사이에는 빈 행을 넣어 분리해야 마땅하다.

#### 세로 밀집도
* 줄바꿈이 개념을 분리한다면 세로 밀집도는 연관성을 의미한다.
* 서로 밀접한 코드 행은 세로로 가까이 놓여야 한다는 뜻이다.

#### 수직 거리
* 시스템이 무엇을 하는지 이해하고 싶은데, 이 조각 저 조각이 어디에 있는지 찾고 기억하느라 시간과 노력을 많이 소모하곤 한다.
* 서로 밀접한 개념은 세로로 가까이 둬야 한다.
  * 서로 다른 파일에 속한다면 위 규칙은 통하지 않지만, 타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 한다.
  * 이와같은 이유가 바로 protected 변수를 피해야 하는 이유이다.
* 같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성을 표현한다. (연관성은 한 개념을 이해하는 데 다른 개념이 중요한 정도)
* 연관성이 깊은 두 개념이 멀리 떨어져 있으면 코드를 읽는 사람이 소스 파일과 클래스를 여기저기 찾아보게 된다.

##### 변수 선언
* 변수는 사용하는 위치에 최대한 가까이 선언한다.
  * 만들게 되는 함수는 짧으므로 지역 변수는 각 함수 맨 처음에 선언한다.
* 루프를 제어하는 변수는 흔히 루프 문 내부에 선언한다.
  * 다소 긴 함수에서 블록 상단이나 루프 직전에 변수를 선언하는 사례도 있긴 하다.

##### 인스턴스 변수
* 인스턴스 변수는 클래스 맨 처음에 선언한다.
* 변수 간에 세로로 거리를 두지 않으며, 잘 설계한 클래스는 클래스의 많은 메서드가 인스턴스 변수를 사용하기 때문이다.
* 자바에서는 보통 클래스 맨 처음에 인스턴스 변수를 선언한다.

##### 종속 함수
* 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다.
* 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다.
* 이러한 규칙을 일관적으로 적용하면 독자들은 방금 호출한 함수가 잠시 후에 정의되리라는 사실을 예측할 수 있게 된다.

##### 개념적 유사성
* 개념적인 친화도가 높은 코드는 서로 끌어당기며, 이 친화도가 높을수록 코드를 가까이 배치한다.
* 이 친화도가 높은 요인은 여러가지가 있다.
  * 한 함수가 다른 함수를 호출 해 생기는 직접적인 종속성
  * 변수와 그 변수를 사용하는 함수
  * 비슷한 동작을 수행하는 일군의 함수

#### 세로 순서
* 일반적으로 함수 호출 종속성은 아래 방향으로 유지한다.
* 즉, 호출되는 함수를 호출하는 함수보다 나중에 배치한다.
* 그러면 소스 코드 모듈이 고차원에서 저차원으로 자연스럽게 넘어간다.
* 가장 중요한 개념을 먼저 표현하고, 이 때 세세한 사항을 최대한 배제하고 이 세세한 사항은 가장 마지막에 표현한다.
* 그러면 독자가 소스 파일에서 첫 함수 몇 개만 읽어도 개념을 파악하기 쉬워진다.


### 가로 형식 맞추기
* 짧은 행이 바람직하다.
* 100자~120자에 달해도 나쁘지 않지만, 그 이상은 솔직히 말해서 주의부족이다.
  * 예전에는 오른쪽으로 스크롤할 필요가 없게 코드를 짰지만, 요즘은 모니터가 크다.
  * 글자 크기까지 많이 줄여서 200자까지도 한 화면에 들어오기도 한다.
  * 하지만 이렇게 길게 사용하는 것은 권장되는 방법은 아니다.

#### 가로 공백과 밀집도
* 가로로는 공백을 사용해 밀접한 개념과 느슨한 개념을 표현한다.

```java
private void measureLine(String line){
    lineCount++;
    int lineSize = line.length();
    totalChars += lineSize;
    lineWidthHistogram.addLine(lineSize, lineCount);
    recordWidestLine(lineSize)
}
```

* 위 예시를 보면 연산자를 강조하기 위해 앞뒤에 공백을 뒀고, 할당문은 왼쪽 요소와 오른쪽 요소가 분명하게 나뉜다.
* 반면 함수 이름과 이어지는 괄호 사이에는 공백을 넣지 않았다. (함수와 인수는 서로 밀접하기 때문)
* 또한 함수를 호출하는 코드에서 괄호 안 인수는 공백으로 분리했다. (쉼표를 강조해 인수가 별개라는 부분을 보여주기 위함)
* 위 예시 외에도 덧셈과 뺄셈은 곱셈보다 우선순위가 낮기 때문에 곱셈 앞뒤에는 공백이 없고 덧셈과 뺄셈 앞뒤에는 공백을 두는 방법도 있다.

#### 가로 정렬
* 선언부의 변수 이름이나 할당문의 오른쪽 피연산자를 나란히 정렬하기도 하는데, 좋은 방법은 아니다.
* 코드가 엉뚱한 부분을 강조해 진짜 의도가 가려지기 때문이다.
  * 변수 유형은 무시하고 변수 이름부터 읽게 됨.
  * 할당 연산자는 보이지 않고 오른쪽 정렬된 피연산자에 눈이 감.
* 만약 정렬이 필요할 정도로 목록이 길면 문제는 목록 길이이고, 정렬 문제는 아니다.

#### 들여쓰기
* 소스 파일에는 윤곽도(outline)와 계층이 비슷하다.
* 파일 전체에 적용되는 정보가 있고 블록 내 블록에 재귀적으로 적용되는 정보가 있으며, 계층에서 각 수준은 이름을 선언하는 범위이자 선언문과 실행문을 해석하는 범위다.
* 범위(scope)로 이뤄진 계층을 표현하기 위해 들여쓰기를 이용한다.
* 들여쓰기한 파일은 구조가 한눈에 들어오며, 들여쓰기를 하지 않은 코드는 열심히 분석하지 않는 한 해석이 거의 불가능하다.

##### 들여쓰기 무시하기
* 때로는 간단한 if문, 짧은 while문, 짧은 함수에서 들여쓰기 규칙을 무시하고 싶어진다.
* 이런 상황에서도 들여쓰기로 범위를 제대로 표현한 코드가 좋다.

#### 가짜 범위
* 때로는 빈 while문이나 for문을 접한다.
* 이런 구조를 피하지 못할 때는 빈 블록을 올바로 들여쓰고 괄호로 감싼다.
```java
while (dis.read(buf, 0, readBufferSize) != -1)
;
```
* 이러한 구조에서 위 예시와 같이 세미콜론은 새 행에다가 제대로 들여써서 눈에 띄게 만들어 주는게 좋다.

### 팀 규칙
* 프로그래머라면 각자 선호하는 규칙이 있지만, 팀에 속한다면 자신이 선호해야 할 규칙은 바로 팀 규칙이다.
* 팀은 한 가지 규칙에 합의해야 하고, 모든 팀원은 그 규칙을 따라야 한다.
* 개개인이 따로따로 맘대로 짜대는 코드는 피해야 한다.

## 6. 객체와 자료 구조
### 자료 추상화
```java
public class Point {
    public double x;
    public double y;
}
```
```java
public interface Point {
    double getX();
    double getY();
    void setCartesian(double x, double y);
    double getR();
    double getTheta();
    void setPolar(double r, double theta);
}
```
* 위 두가지 예시 중 첫 번째 예시는 구현을 외부로 노출하고, 두 번째 예시는 구현을 완전히 숨긴다.
* 두 번째 예시는 직교좌표계를 사용하는지 극좌표계를 사용하는지 알 길이 없지만, 그럼에도 불구하고 자료 구조를 명백하게 표현한다.
* 또한 두 번째 예시는 좌표를 읽을 때 각 값을 개별적으로 읽어야 하고, 좌표를 설정할 때는 두 값을 한번에 설정해야 한다. (클래스 메서드가 접근 정책을 강제)
* 변수 사이에 함수라는 계층을 넣어도 구현이 저절로 감춰지지는 않고, 구현을 감추려면 추상화가 필요하다.
  * 조회/설정 함수(getter, setter 등)를 이용해 변수를 다룬다고 클래스가 되지 않는다.
  * 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진짜 클래스이다.
* 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 것이 좋다.
* 아무 생각 없이 조회/설정 함수를 추가하는 방법이 가장 나쁘다.

### 자료/객체 비대칭
* **객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.**
* **자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.**
* 자료 구조를 사용하는 절차적인 코드의 특징
  * 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다.
  * 새로운 자료 구조를 추가하기 어렵다. (모든 함수룰 고쳐야 함)
* 객체 지향 코드의 특징
  * 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.
  * 새로운 함수를 추가하기 어렵다. (모든 클래스를 고쳐야 함)
* 객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉽고, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다.


### 디미터 법칙
* 디미터 법칙은 잘 알려진 휴리스틱으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다.
* 객체는 자료를 숨기고 함수를 공개한다. (객체는 조회 함수로 내부 구조를 공개하면 안된다는 의미)
* 예시로, 클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다.
  * 클래스 C
  * f가 생성한 객체
  * f 인수로 넘어온 객체
  * C 인스턴스 변수에 저장된 객체

#### 기차 충돌

``` java
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath(); 
```
* 위와 같은 코드는 디미터 법칙을 어기는 것 처럼 보인다.
  * `getOptions()` 함수가 반환하는 객체의 `getScratchDir()` 함수를 호출한 후 `getScratchDir()` 함수가 반환하는 객체의 `getAbsolutePath()` 함수를 호출함
* 이와 같은 코드는 여러 객차가 한 줄로 이어진 기차처럼 보이기 때문에 기차 충돌이라고 부른다.
* 따라서 아래 코드와 같이 나누는 편이 좋다.
```java
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```
* 하지만 위 코드는 `ctxt`, `opts`, `scratchDir`이 객체인지 자료구조인지에 따라 디미터 법칙을 위반할 수도 있다.
  * 객체라면 내부 구조를 숨겨야 하므로 디미터 법칙 위반
* 따라서 아래 코드와 같이 구현 하면 디미터 법칙을 거론할 필요가 없어진다.
```java
final String outputDir = ctxt.options.scratchDir.absolutePath; 
```

#### 잡종 구조
* 자료구조는 무조건 함수없이 공개 변수만 포함하고 객체는 비공개 변수와 공개 함수를 표현한다면 간단해지지만, 단순한 자료 구조에도 조회 함수와 설정 함수를 정의하라 요구하는 프레임워크와 표준(bean)이 존재한다.
* 이러한 혼란으로 때때로 절반은 객체, 절반은 자료구조인 잡종 구조가 나온다.
* 잡종 구조는 중요한 기능을 수행하는 함수도 있고, 공개 변수나 공개 조회/설정 함수도 있다.
* 따라서 다른 함수가 절차적인 프로그래밍의 자료구조 접근 방식처럼 비공개 변수를 사용하고 싶어질 수 있다.
* 이러한 잡종 구조는 새로운 함수는 물론이고 새로운 자료 구조도 추가하기 어렵다. (양쪽의 단점만 모아놓은 구조)
* 그러므로 이러한 잡종 구조는 되도록 피하는게 좋다.

#### 구조체 감추기
* 객체는 뭔가를 하라고 말해야 하며, 속을 드러내라고 말하면 안된다.
```java
String outFile = outputDir + "/" + className.replace('.', '/') + ".class";
FileOutputStream fout = new FileOutputStream(outFile);
BufferedOutputStream bos = new BufferedOutputStream(fout);
```
* 위 예시는 임시 디렉토리의 절대 경로를 얻으려는 이유가 임시 파일을 생성하기 위한 목적이라는 사실이 들어난다.
* 아래와 같이 바꾸면, `ctxt`는 내부 구조를 드러내지 않으며 모듈에서 해당 함수는 자신이 몰라야 하는 여러 객체를 탐색할 필요가 없어진다.
```java
BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName); 
```

### 자료 전달 객체
* 자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스이다.
* 이런 자료 구조체를 자료 전달 객체(DTO, Data Transfer Object) 라고 한다.
* DTO는 굉장히 유용한 구조체이고, 특히 데이터베이스와 통신하거나 소켓에서 받은 메시지의 구문을 분석할 때 유용하다.
* 더 일반적인 형태는 bean 구조인데, 비공개 변수를 조회/설정 함수로 조작한다.
  * 따라서 별 다른 이익을 제공하지 않는다.

#### 활성 레코드
* 활성 레코드는 DTO의 특수한 형태이다. 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료 구조지만, 대게 save나 find와 같은 탐색 함수도 제공한다.
* 활성 레코드는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과이다.
* 활성 레코드에 비즈니스 규칙 메서드를 추가해 이런 자료 구조를 객체로 취급하는 개발자가 흔하지만, 바람직하지 않은 방법이다.
  * 자료 구조도 아니고 객체도 아닌 잡종 구조가 나오게 된다.
* 이러한 문제의 해결책은, 활성 레코드는 자료 구조로 취급하고 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체는 따로 생성하면 된다.

### 결론
* 객체는 동작을 공개하고 자료를 숨긴다.
  * 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉽고, 기존 객체에 새 동작을 추가하기는 어렵다.
* 자료 구조는 별다른 동작 없이 자료를 노출한다.
  * 기존 자료 구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다.
* 따라서 시스템을 구현할 때 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하고, 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다.

## 7. 오류 처리
### 오류 코드보다 예외를 사용하라
* 얼마 전까지만 해도 예외를 지원하지 않는 프로그래밍 언어가 더 많았다.
* 예외를 지원하지 않는 언어는 오류를 처리하고 보고하는 방법이 제한적이었다. (오류 플래그를 설정하거나 호출자에게 오류코드를 반환)
* 하지만 이와 같은 방법을 사용하면 호출자 코드가 복잡해진다. (호출 즉시 오류를 확인해야 함)
* 따라서 오류가 발생하면 예외를 던지는 편이 더 좋다. (논리가 오류 처리 코드와 섞이지 않음)
* 예외를 사용하면 코드가 확실히 깔끔해지고, 뒤섞여있던 개념들을 분리할 수 있어 각 개념을 독립적으로 살펴보고 이해할 수 있다.

### Try-Catch-Finally 문부터 작성하라
* 예외에서 프로그램 안에다 범위를 정이한다는 것은 매우 흥미로운 내용이다.
* 어떤 면에서 try 블록은 트랜잭션과 비슷하다.
  * try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일고나성 있게 유지해야 한다.
* 따라서 예와가 발생할 코드를 짤 때는 try-catch-finally 문으로 시작하는 편이 좋다.
* 그러면 try 블록에서 무슨 일이 생기든지 호출자가 기대하는 상태를 정의하기 쉬워진다.

### 미확인(unchecked) 예외를 사용하라
* 긴 기간동안 자바 프로그래머들은 확인된(checked) 예외의 장단점을 놓고 논쟁을 벌여왔다.
* 초창기에는 확인된 예외를 멋진 아이디어라 생각했고, 실제로도 확인된 예외는 몇가지 장점도 제공한다.
* 하지만 지금은 안정적인 소프트웨어를 제작하는 요소로 확인된 예외가 반드시 필요하지는 않다.
  * C#, C++, 파이썬 루비 등 확인된 예외를 지원하지 않지만, 그럼에도 불구하고 안정적인 소프트웨어를 구현하기에 무리가 없다.
* 따라서 확인된 오류가 치르는 비용에 상응하는 이익을 제공하는지 따져봐야 한다.
* 확인된 오류가 치르는 비용은 OCP를 위반한다는 점이다.
  * 메서드에서 확인된 예외를 던졌는데 catch 블록이 세 단계 위에 있다면 그 사이 메서드 모두가 선언부에 해당 예외를 정의해야 한다.
  * 하위단계에서 코드를 변경하면 상위 단계 메서드 선언부를 전부 고쳐야 한다.
* 만약 최하위 함수를 변경해 새로운 오류를 던지게 되면, catch 블록에서 새로운 예외를 처리하거나, 선언부에 throw 절을 추가해야 한다.
* 연쇄적인 수정이 일어나고, throws 경로에 위치하는 모든 함수가 최하위 함수에서 던지는 예외를 알아야 하므로 캡슐화도 깨진다.
* 때로는 확인된 예외도 유용하지만, 일반적인 애플리케이션은 의존성이라는 비용이 이익보다 크다.

### 예외에 의미를 제공하라
* 예외를 던질 때는 전후 상황을 충분히 덧붙이면 오류가 발생한 원인과 위치를 찾기가 쉬워진다.
* 자바는 모든 예외에 호출 스택을 제공하지만, 실패한 코드의 의도를 파악하려면 호출 스택만으로 부족하다.
* 따라서 오류 메시지에 정보를 담아 예외와 함께 던지며, 실패한 연산 이름과 실패 유형도 언급한다.
* 만약 애플리케이션이 로깅 기능을 사용한다면 catch 블록에서 오류를 기록하도록 충분한 정보를 넘겨준다.

### 호출자를 고려해 예외 클래스를 정의하라
* 오류를 분류하는 방법은 수없이 많지만, 오류가 발생한 위치로도 분류가 가능하다.
* 애플리케이션에서 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야 한다.
```java
public class LocalPort {
    private ACMEPort innerPort;
    
    public LocalPort(int portNumber) {
        innerPort = new ACMEPort(portNumber);
    }
    
    public void open() {
        try{
            innerPort.open();
        } catch (DeviceResponseException e) {
            throw new PortDeviceFailure(e);
        } catch (ATM1212UnlockedException e) {
            trhow new PortDeviceFailure(e);
        } catch (GMXError e) {
            throw new PortDeviceFailure(e);
        }
    }
    ...
} 
```
* 외부 API를 사용할 때는 감싸기 기법이 최선이다.
* 외부 API를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어들고, 나중에 다른 라이브러리로 갈아타도 비용이 적게 든다.
* 또한 외부 API를 호출하는 대신 테스트 코드를 넣어주는 방법으로 프로그램을 테스트하기도 쉬워진다.
* 또 특정 업체가 API를 설계한 방식에 발목이 잡히지 않는다. 프로그램이 사용하기 편리한 API를 정의하기만 하면 된다.

### 정상 흐름을 정의하라
* 앞 절에서 충고한 대로 코드를 설계하면 비즈니스 논리와 오류 처리가 잘 분리된 코드가 나오며, 코드 대부분이 깨끗하고 간결한 알고리즘으로 보이기 시작한다.
* 하지만 그러다 보면 오류 감지가 프로그램 언저리로 밀려나게 된다.
* 외부 API를 감싸 독자적인 예외를 던지고 코드 위에 처리기를 정의해 중단된 계산을 처리하게 되는데, 대개는 멋진 처리 방식이지만 때로는 적합하지 않은 때도 있다.
* 클래스를 만들거나 특수 사례를 처리하는 방식이 필요할 때가 있는데, 이를 특수 사례 패턴(Special Case Pattern)이라고 한다.
* 클래스나 객체가 예외적인 상황을 캡슐화해서 처리하므로 코드가 예외적인 상황을 처리할 필요가 없어진다. 

### null을 반환하지 마라
* 한 줄 건너 하나씩 null을 확인하는 코드로 가득한 애플리케이션은 수도없이 많다.
* null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라, 호출자에게 문제를 떠넘긴다.
* 누구 하나라도 null 확인을 빼먹는다면 애플리케이션이 통제 불능에 빠질수도 있다.
* 따라서 메서드에서 null을 반환하고 싶다면, 그 대신 예외를 던지거나 특수 사례 객체를 반환해야 한다.
* 만약 사용하려는 외부 API가 null을 반환한다면 감싸기 메서드를 구현해 예외를 던지거나 특수 사례 객체를 반환하는 방식을 고려해야 한다.
* 리스트의 경우, null 보다는 빈 리스트를 반환하는 방법도 있다.

### null을 전달하지 마라
* 메서드에서 null을 반환하는 방식도 나쁘지만 메서드로 null을 전달하는 방식은 더 나쁘다.
* 정상적인 인수로 null을 기대하는 API가 아니라면 메서드로 null을 전달하는 코드는 최대한 피해야 한다.
* 대다수의 프로그래밍 언어는 호출자가 실수로 넘기는 null을 적절히 처리하는 방법이 없다.
* 따라서 애초에 null을 넘기지 못하도록 금지하는 방법이 합리적이다.

### 결론
* 깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다.
* 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있으며, 독립적인 추론이 가능해지며 코드 유지보수성도 크게 높아진다.

## 8. 경계
### 외부 코드 사용하기
* 패키지 제공자나 프레임워크 제공자는 적용성을 최대한 넓히려고 한다.
* 하지만 사용자는 자신의 요구에 집중하는 인터페이스를 원한다.
* 한가지 예로, Java에서 Map은 굉장히 다양한 인터페이스로 수많은 기능을 제공한다.
* Map이 제공하는 기능성과 유연성은 확실히 유용하지만, 그만큼 위험도 크다. 
  * Map을 만들어 여기저기 넘기는 상황에서, Map 사용자라면 누구나 Map내용을 지울 수 있다.
  * 설계 시 Map에 특정 객체 유형만 저장하기로 결정한 상황에서, 마음만 먹으면 사용자는 어떤 객체 유형도 추가할 수 있다.
* 따라서 그냥 Map을 제공하지 말고, 캡슐화를 해서 필요한 기능만 만들어 제공해주면 좋다.
* Map을 사용할 때마다 캡슐화하라는 얘기는 아니고, Map과 같은 경계 인터페이스를 여기저기 넘기지 않아야 된다는 뜻이다.

### 경계 살피고 익히기
* 외부 코드를 사용하면 적은 시간에 더 많은 기능을 출시하기 쉬워진다.
* 외부 패키지 테스트는 우리 책임이 아니지만, 우리를 위해서 테스트 하는 편이 바람직하다.
* 타사 라이브러리를 가져왔을때 사용법이 분명치 않다면, 시간을 투자하여 문서를 읽으며 사용 방법을 익혀야 한다.
* 외부 코드를 익히기는 어렵고 외부 코드를 통합하기도 어려우며, 두 가지를 동시에 하기는 두배나 어렵다.
* 우르쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 방법이 있는데, 학습 테스트라고 한다.
* 학습 테스트는 프로그램에서 사용하려는 방식대로 외부 API를 호출하고, 통제된 환경에서 API를 제대로 이해하는지 확인할 수 있다.

### 학습 테스트는 공짜 이상이다
* 학습 테스트는 공짜 이상이고, 투자하는 노력보다 얻는 성과가 더 크다.
* 패키지 새 버전이 나온다면 학습 데스트를 돌려서 차이가 있는지 확인한다.
* 패키지 새 버전이 나올 때마다 새로운 위험이 생긴다. (새 버전이 우리 코드와 호환된다는 보장은 없음)
* 학습 테스트를 이용한 학습이 필요하든 그렇지 않든, 실제 코드와 동일한 방식으로 인터페이스를 사용하는 테스트 케이스가 필요하다.
* 이러한 경계 테스트가 있으면 패키지의 새 버전으로 이전하기 쉬워진다.

### 아직 존재하지 않는 코드 사용하기
* 때로는 우리 지식이 경계를 너머 미치지 못하는 코드 영역도 있다.
* API 설계조차 되지 않은 상황에서 개발을 해야할 수도 있다.
* 자체적으로 인터페이스를 정의하고, 어댑터 패턴으로 API 사용을 캡슐화해 API가 바뀔때 수정할 코드를 한 곳으로 모으는 방법이 있다.
* 이와 같은 설계는 테스트도 편하다. 
  * API 인터페이스가 나온 다음 경계 테스트 케이스를 생성해 API를 올바로 사용하는지 테스트 할 수도 있다. 

### 깨끗한 경계
* 통제하지 못하는 코드를 사용할 때는 향후 변경 비용이 지나치게 커지지 않도록 각별히 주의해야 한다.
* 경계에 위치하는 코드는 깔끔히 분리해야 하며, 기대치를 정의하는 테스트 케이스도 작성해야 한다.
* 또한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 좋다.
* 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리해야 한다.
* 새로운 클래스로 경계를 감싸거나, 어댑터 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환해야 한다.
* 코드 가독성이 높아지며, 경계 인터페이스를 사용하는 일관성도 높아지고, 외부 패키지가 변했을 때 변경할 코드도 줄어들게 된다.

## 9. 단위 테스트
### TDD 법칙 세 가지
* 첫째 법칙 : 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
* 둘째 법칙 : 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
* 셋째 법칙 : 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
* 위 세 가지 규칙을 따르면 테스트 코드와 실제 코드가 함께 나올뿐더러 테스트 코드가 실제 코드보다 불과 몇 초 전에 나온다.
* 이렇게 일하면 실제 코드를 전부 테스트하는 테스트케이스가 나오지만, 실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 한다.

### 깨끗한 테스트 코드 유지하기
* 테스트 코드가 복잡할수록 실제 코드를 짜는 시간보다 테스트 케이스를 추가하는 시간이 더 걸리며,  실제 코드를 변경하여 기존 테스트 케이스가 실패하기 시작하면 실패하는 테스트 케이스를 점점 통과시키기 어려워진다.
* 테스트코드는 실제 코드 못지 않게 중요하기 때문에, 실제 코드 못지 않게 깨끗하게 짜야 한다.

#### 테스트는 유연성, 유지보수성, 재사용성을 제공한다.
* 테스트 코드를 깨끗하게 유지하지 않으면 결국 잃어버리게 되고, 테스트 케이스가 없으면 실제 코드를 유연하게 만드는 버팀목도 사라진다.
* 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 단위 테스트이다.
* 실제 코드를 점검하는 자동화된 단위 테스트 슈트는 설계와 아키텍처를 깨끗하게 보존하는 열쇠다.
* 테스트 코드가 지저분하면 코드를 변경하는 능력이 떨어지고 코드 구조를 개선하는 능력도 떨어진다. 
* 테스트 코드가 지저분할수록 실제 코드도 지저분해지며, 테스트 코드도 잃어버리고 실제 코드도 망가지게 된다.

### 깨끗한 테스트 코드
* 깨끗한 테스트코드를 만들려면 가독성이 필요하다.
* 가독성은 실제 코드에서 보다 테스트 코드에서 더 중요하다.
* 테스트 코드에서 가독성을 높이기 위해서 명료성, 단순성, 풍부한 표현력이 필요하다.
* 자질구레한 사항이 너무 많으면 테스트 코드의 표현력이 떨어진다.
* 테스트 코드에서는 잡다하고 세세한 코드를 거의 다 없애고, 진짜 필요한 자료 유형과 함수만 사용해야 한다.

### 테스트 당 assert 하나
* JUnit으로 테스트 코드를 짤 때에는 함수마다 assert 문을 하나만 사용해야 한다.
* assert 문이 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠르다.
* assert문 하나로 안된다면 테스트를 두 개로 분리해 각자가 assert를 수행하면 된다.

#### 테스트 당 개념 하나
* 테스트 함수마다 한 개념만 테스트 해야한다.
* 이것저것 잡다한 개념을 연속으로 테스트하는 긴 함수는 피해야 한다.
* 새 개념을 한 함수로 몰아넣으면 독자가 각 절이 거기에 존재하는 이유와 각 절이 테스트하는 개념을 모두 이해해야 한다.
* 가장 좋은 규칙은 **개념 당 assert문 수를 최소로 줄이고, 테스트 함수 하나는 개념 하나만 테스트해야 한다.**

### F.I.R.S.T
* 깨끗한 테스트는 다섯 가지 규칙을 따르며, 각 규칙에서 첫 글자를 따오면 FIRST가 된다.

#### Fast
* 테스트는 빨라야 한다.
* 테스트가 느리면 자주 돌릴 엄두를 못 낸다.
* 자주 돌리지 않으면 초반에 문제를 찾아내 고치지 못하고, 코드를 마음껏 정리하지도 못한다.

#### Independent
* 테스트는 서로 의존하면 안된다.
* 한 테스트가 다음 테스트가 실행 될 환경을 준비해서는 안된다.
* 각 테스트는 독립적으로, 어떤 순서로 실행해도 괜찮아야 한다.
* 테스트가 서로에게 의존하면 하나가 실패할 때 나머지도 잇달아 실패하므로, 원인을 진단하기 어려워진다.

#### Repeatable
* 테스트는 어떤 환경에서도 반복 가능해야 한다.
* 테스트가 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다.
* 또한 환경이 지원되지 않기에 테스트를 수행하지 못하는 상황이 올 수도 있다.

#### Self-Validating
* 테스트는 bool 값으로 결과를 내야 한다.
* 성공 아니면 실패이고, 통과 여부를 알려고 로그 파일을 읽게 만들어서는 안 된다.
* 통과 여부를 보려고 텍스트 파일 두 개를 수작업으로 비교하게 만들어서도 안 된다.
* 테스트가 스스로 성공과 실패를 가늠하지 않는다면 판단은 주관적이 되며, 지루한 수작업 평가가 필요하게 된다.

#### Timely
* 테스트는 적시에 작성해야 한다.
* 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다.
* 실제 코드를 구현한 다음에 테스트 코드를 만들면 실제 코드가 테스트하기 어렵다는 사실을 발견할지도 모른다.

### 결론
* 깨끗한 테스트 코드라는 주제는 책 한권을 할애해도 모자랄 주제이다.
* 테스트 코드는 실제 코드 만큼이나 프로젝트 건강에 중요하다. (실제 코드보다 더 중요할수도 있음)
* 테스트코드는 실제 코드의 유연성, 유지보수성, 재사용성을 보존하고 강화한다.
* 테스트 코드가 방치되어 망가지면 실제 코드도 망가지므로, 테스트 코드를 깨끗하게 유지해야 한다.

## 10. 클래스
### 클래스 체계
* 클래스를 정의하는 표준 자바 관례에 따르면, 가장 먼저 변수 목록이 나온다.
* static, public 상수가 있다면 맨 처음에 나오고, 그 다음으로 private 변수가 나오며, 이어서 비공개 인스턴스 변수가 나온다.
* 변수 목록 다음에는 공개 함수가 나오며, 비공개 함수는 자신을 호출하는 공개 함수 직후에 넣는다.
* 즉 추상화 단계가 추상적으로 내려가게 되고, 프로그램은 신문 기사처럼 읽힌다.

#### 캡슐화
* 변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫지만 반드시 숨겨야 한다는 법칙도 없다.
* 우리에게 테스트는 아주 중요하며, 같은 패키지 안에서 테스트 코드가 함수를 호출하거나 변수를 사용해야 한다면 그 함수나 변수를 protected로 선언하거나 패키지 전체로 공개한다.
* 그렇지만 그 전에 비공개 상태를 유지할 온갖 방법을 강구해야 하며, 캡슐화를 풀어주는 결정은 언제나 최후의 수단이다.

### 클래스는 작아야 한다
* 클래스를 만들 때 첫 번째 규칙은 크기다.
* 클래스를 설계할 때도 함수와 마찬가지로 '작게'가 기본 규칙이다.
* 함수는 물리적인 행 수로 크기를 측정했지만, 클래스는 클래스가 맡은 책임을 센다.

#### 단일 책임 원칙
* 단일 책임 원칙(SRP, Single Responsibility Principle)은 클래스나 모듈을 변경할 이유가 단 하나뿐이어야 한다는 원칙이다.
* SRP는 객체 지향 설계에서 더욱 중요한 개념이면서 이해하고 지키기 수월한 개념이지만 클래스 설계자들이 가장 무시하는 규칙 중 하나다.
  * 깨끗하고 체계적인 소프트웨어보다 돌아가는 소프트웨어에 초점을 맞추기 때문이다.
* 큰 클래스 몇개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다.
* 작은 클래스는 각자 맡은 책임이 하나이며, 변경할 이유가 하나이고, 다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행해야 한다.

#### 응집도
* 클래스는 인스턴스 변수 수가 작아야 한다.
* 각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다.
* 일반적으로 메서드가 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 더 높다.
  * 모든 인스턴스 변수를 메서드마다 사용하는 클래스는 응집도가 가장 높다.
* 이처럼 응집도가 가장 높은 클래스는 가능하지도 바람직하지도 않지만, 우리는 응집도가 높은 클래스를 선호한다.
* 함수를 작게, 매개변수 목록을 짧게라는 전략을 따르다 보면 때때로 몇몇 메서드만이 사용하는 인스턴스 변수가 아주 많아진다.
* 이것은 새로운 클래스로 쪼개야 한다는 신호이며, 응집도가 높아지도록 변수와 메서드를 적절히 분리해 새로운 클래스 두세 개로 쪼개줘야 한다.

#### 응집도를 유지하면 작은 클래스 여럿이 나온다.
* 큰 함수를 작은 함수 여러개로 나누기만 해도 클래스 수가 많아진다.
* 예시로 변수가 아주 많은 큰 함수 하나가 있는 경우, 큰 함수 일부를 작은 함수 하나로 빼낼 때 빼내려는 코드가 큰 함수에 정의된 변수를 사용할 수 있다.
* 이럴 때는 이 변수들을 클래스 인스턴스 변수로 승격하면 새 함수는 인수가 필요없어진다. (함수를 쪼개기 쉬워짐)
* 하지만 이렇게 하면 인스턴스 변수가 점점 늘어나 클래스가 응집력을 잃으므로, 독자적인 클래스로 분리해야 한다.
* 클래스가 응집력을 잃는다면 여러 클래스로 분리해야 한다.

### 변경하기 쉬운 클래스
* 대다수의 시스템은 지속적인 변경이 가해지며, 변경할 때마다 시스템이 의도대로 동작하지 않을 위험이 따른다.
* 깨끗한 시스템은 클래스를 체계적으로 정리해 변경에 수반하는 위험을 낮춘다.
* 새 기능을 수정하거나 기존 기능을 변경할 때 건드릴 코드가 최소인 시세틈 구조가 바람직하다.
* 이상적인 시스템이라면 새 기능을 추가할 때 시스템을 확장할 뿐 기존 코드를 변경하지 않는다.

#### 변경으로부터 격리
* 요구사항은 변하기 마련이고, 그에따라 코드도 변하기 마련이다.
* 상세한 구현에 의존하는 코드는 구현이 바뀌면 위험에 빠지며, 테스트도 어렵다.
* 그래서 인터페이스와 추상 클래스를 사용해 구현이 미치는 영향을 격리한다.
* 시스템의 결합도를 낮추면 유연성과 재사용성도 더욱 높아진다.
  * 결합도가 낮다는 소리는 각 시스템 요소가 다른 요소로부터, 변경으로부터 잘 격리되어 있다는 의미이다.
* 또한 결합도를 최소로 낮추면 자연스럽게 DIP를 따르는 클래스가 나온다.
  * DIP는 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙이다.

## 11. 시스템
### 도시를 세운다면?
* 도시를 세운다고 생각해보면 온갖 세세한 사항을 혼자서 관리할 수 없다.
* 이미 세워진 도시라도 한사람의 힘으로는 무리다.
* 그럼에도 불구하고 도시는 잘 돌아가는데 수도 관리팀, 전력 관리팀 등각 분야를 관리하는 팀이 있기 때문이다.
* 소프트웨어 팀도 도시처럼 구성지만, 막상 팀이 제작하는 시스템은 비슷한 수준으로 관심사를 분리하거나 추상화를 이뤄내지 못한다.
* 깨끗한 코드를 구현하면 낮은 추상화 수준에서 관심사를 분리하기 쉬워진다.
* 이 시스템 장에서는 시스템 수준에서도 깨끗함을 유지하는 방법을 소개한다.

### 시스템 제작과 시스템 사용을 분리하라.
* 우선 제작과 사용은 아주 다르다는 사실을 명심해야 한다.
* 소프트웨어 시스템은 애플리케이션 객체를 제작하고 의존성을 서로 연결하는 준비 과정과, 준비 과정 이후에 이어지는 런타임 로직을 분리해야 한다.
* 관심사 분리는 우리 분야에서 가장 오래되고 가장 중요한 설계 기법이지만, 대다수 애플리케이션은 시작 단계라는 관심사를 분리하지 않는다.
```java
public Service getService() {
    if (service == null)
        service = new MyServiceImpl(...);   // 모든 상황에 대한 적절한 기본값..?
    return service
} 
```
* 위 예시는 초기화 지연 혹은 계산 지연이라 한다.
  * 장점
    * 실제로 필요할 때까지 객체를 생성하지 않으므로 불필요한 부하가 걸리지 않는다. (애플리케이션 시작하는 시간이 그만큼 빨라짐)
    * 어떤 경우에도 null 포인터를 반환하지 않는다.
  * 단점
    * getService 메서드는 MyServiceImpl과 생성자 인수에 명시적으로 의존한다.
    * 테스트를 하러면 getService 메서드를 호출하기 전에 적절한 테스트 전용 객체를 할당해여 한다.
    * 또한 런타임 로직에 객체 생성 로직을 섞어놓은 탓에 모든 실행 경로(service가 null인 경로와 null이 아닌 경로)를 테스트해야 한다. (작게나마 단일 책임 원칙을 깸)
* 체계적이고 탄탄한 시스템을 만들고 싶다면 흔히 쓰는 손쉬운 기법으로 모듈성을 깨서는 절대 안된다.

#### Main 분리
* 시스템 생성과 시스템 사용을 분리하는 한 가지 방법으로, 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다.
* main 함수에서 시스템에 필요한 객체를 생성한 후 이를 애플리케이션에 넘긴고, 애플리케이션은 그저 객체를 사용할 뿐이다. (제어 흐름이 쉬움)
* 애플리케이션은 main이나 객체가 생성되는 과정을 전혀 몰라야 하고, 단지 모든 객체가 적절히 생성되었다고 가정한다.

#### 팩토리
* 객체가 생성되는 시점을 애플리케이션이 결정할 필요도 생긴다.
* ABSTRACT FACTORY 패턴을 사용하면, 객체를 생성하는 시점은 애플리케이션이 결정하지만 객체를 생성하는 코드는 애플리케이션이 모른다.
* 애플리케이션은 객체가 생성되는 시점을 완벽하게 통헤자며, 필요하다면 애플리케이션에서만 사용하는 생성자 인수도 넘길 수 있다.

#### 의존성 주입
* 사용과 제작을 분리하는 강력한 메커니즘이 의존성 주입(DI, Dependency Injection)이다.
* 의존성 주입은 제어 역전(IoC, Inversion of Control)기법을 의존성 관리에 적용한 메커니즘이다.
* 제어 역전에서는 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘긴다.
* 새로운 객체는 넘겨받은 책임만 맡으므로 단일 책임 원칙을 지키게 된다.
* 초기 설정은 시스템 전체에 필요하므로 대개 '책임질' 메커니즘으로 main 루틴이나 특수 컨테이너를 사용한다.
* 스프링 프레임워크는 가장 널리 알려진 자바 DI 컨테이너를 제공한다.
* 대다수 DI 컨테이너는 필요할 때까지는 객체를 생성하지 않고 대부분 계산 지연이나 비슷한 최적화에 쓸 수 있도록 팩토리를 호출하거나 프록시를 생성하는 방법을 제공한다. (계산 지연 기법이나 최적화 기법에서 이런 메커니즘 사용 가능)

### 확장
* 군락은 마을로, 마을은 도시로 성장하지만, 성장에는 고통이 따른다.
* 처음부터 올바르게 시스템을 만들 수 있다는 믿음은 미신이다.
* 우리는 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 하고, 내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 된다. (반복적이고 점진적인 애자일 방식의 핵심)
* TDD, 리팩터링 등으로 얻어지는 깨끗한 코드는 코드 수준에서 시스템을 조정하고 확장하기 쉽게 만든다.
* 소프트웨어 시스템에서는 관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다.
  * 소프트웨어 시스템은 수명이 짧다는 본질로 인해 아키텍처의 점진적인 발전이 가능하다.

#### 횡단(cross-cutting) 관심사
* 영속성과 같은 관심사는 애플리케이션의 자연스로운 객체 경계를 넘나드는 경향이 있다.
* 원론적으로는 모듈화되고 캡슐화된 방식으로 영속성 방식을 구상할 수 있지만, 현실적으로는 영속성 방식을 구현한 코드가 온갖 객체로 흩어진다.
* 횡단 관심사라는 용어는 여기서 나왔으며, 영속성 프레임워크 또한 모듈화할 수 있다.
* AOP는 횡단 관심사에 대처해 모듈성을 확보하는 일반적인 방법론이다.
* AOP에서 관점(aspect)이라는 모듈 구성 개념은 "특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다"라고 명시하며, 명시는 간결한 선언이나 프로그래밍 메커니즘으로 수행한다.
* 영속성을 예로 들면 프로그래머는 영속적으로 저장할 객체와 속성을 선언한 후 영속성 책임을 영속성 프레임워크에 위임한다.
  * AOP 프레임워크는 대상 코드에 영향을 미치지 않는 상태로 동작 방식을 변경한다. (대상 소스 코드를 수작업으로 편집할 필요 없음)
* 자바에서 사용하는 관점 혹은 관점과 유사한 메커니즘 세 개가 있다. (자바 프록시, 순수 자바 AOP 프레임워크, AspectJ 관점)

### 자바 프록시
* 자바 프록시는 단순한 상황에 적합하며, 개별 객체나 클래스에서 메서드 호출을 감싸는 경우가 좋은 예이다.
* JDK에서 제공하는 동적 프록시는 인터페이스만 지원하기 때문에, 클래스 프록시를 사용하려면 CGLIB, ASM, Javassist 등과 같은 바이트 코드 처리 라이브러리가 필요하다.
* 코드 양과 크기는 프록시의 두 가지 단점이다.
* 프록시를 사용하면 깨끗한 코드를 작성하기 어렵고, 시스템 단위로 실행 지점을 명시하는 메커니즘도 제공하지 않는다. 

### 순수 자바 AOP 프레임워크
* 대부분의 프록시 코드는 판박이라 도구로 자동화할 수 있다.
* 순수 자바 관점을 구현하는 스프링 AOP, JBoss AOP 등과 같은 여러 자바 프레임워크는 내부적으로 프록시를 사용한다.
* 스프링은 비즈니스 논리를 POJO로 구현하며, POJO는 순수하게 도메인에 초점을 맞춘다.
* POJO는 엔터프라이즈 프레임워크에 의존하지 않기 때문에 테스트가 개념적으로 더 쉽고 간단하며, 미래 스토리에 맞춰 코드를 보수하고 개선하기 편하다.
* 프로그래머는 설정 파일이나 API를 사용해 필수적인 애플리케이션 기반 구조를 구현하며, 여기에는 영속성, 트랜잭션, 보안, 캐시, 장애조치 등과 같은 횡단 관심사도 포함된다.
* 많은 경우 실제로는 스프링이나 JBoss 라이브러리의 관점을 명시하고, 이때 프레임워크는 사용자가 모르게 프록시나 바이트코드 라이브러리를 사용해 이를 구현한다.
* 이런 선언들이 요청에 따라 주요 객체를 생성하고 서로 연결하는 등 DI 컨테이너의 구체적인 동작을 제어한다.

### AspectJ 관점
* 관심사를 관점으로 분리하는 가장 강력한 도구는 AspectJ 언어다.
* AspectJ는 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장이다.
* 스프링 AOP와 JBoss AOP가 제공하는 순수 자바 방식은 관점이 필요한 상황 중 80~90%에 충분하다.
* AspectJ는 관점을 분리하는 강력하고 풍부한 도구 집합을 제공하긴 하지만, 새 도구를 사용하고 새 언어 문법과 사용법을 익혀야 한다는 단점이 있다.
* AspectJ 애너테이션 폼은 새로운 도구와 새로운 언어라는 부담을 어느정도 완하하며, 애너테이션 폼은 순수한 자바 코드에 자바 5 애너테이션을 사용해 관점을 정의한다.
* 스프링 프레임워크는 AspectJ에 미숙한 사람들이 애너테이션 기반 관점을 쉽게 사용하도록 다양한 기능을 제공한다.

### 테스트 주도 시스템 아키텍처 구축
* 관점으로 관심사를 분리하는 방식은 그 위력이 막강하다.
* 애플리케이션 도메인 논리를 POJO로 작성할 수 있다면 진정한 테스트 주도 아키텍처 구축이 가능해진다.
* 그때그때 새로운 기술을 채택해 단순한 아키텍처를 복잡한 아키텍처로 키워갈 수도 있다.
* BDUF(Big Design Up front)를 추구할 필요는 없으며 실제로 해롭기까지 한데, 처음에 쏟아 부은 노력을 버리지 않으려는 심리적 저항으로 인해 변경을 쉽사리 수용하지 못하기 때문이다.
* 소프트웨어의 경우 소프트웨어 구조가 관점을 효과적으로 분리한다면 극적인 변화가 가능하다.
* 프로젝트를 시작할 때는 일반적인 범위, 목표, 일정은 물론이고 결과로 내놓을 시스템의 일반적인 구조도 생각해야 하지만, 변하는 환경에 대처해 진로를 변경할 능력도 반드시 유지해야 한다.
* 최선의 시스템 구조는 각기 POJO 객체로 구현되는 모듈화된 관심사 영역(도메인)으로 구성된다.
  * 이렇게 서로 다른 영역은 코드에 최소한의 영향을 미치는 고나점이나 유사한 도구를 사용해 통합한다.
  * 이런 구조 역시 코드와 마찬가지로 테스트 주도 기법을 적용할 수 있다.

### 의사 결정을 최적화하라
* 모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능해진다.
* 도시든 소프트웨어 프로젝트든 아주 큰 시스템에서는 한 사람이 모든 결정을 내리기 어렵다.
* 가능한 마지막 순간까지 결정을 미루는 방법이 최선이다.
  * 게으르거나 무책임해서가 아니라, 최대한 정보를 모아 최선의 결정을 내리기 위해서이다.
  * 너무 일찍 결정하면 고객 패드백을 더 모으고, 프로젝트를 더 고민하고, 구현 방안을 더 탐험할 기회가 사라진다.
* 관심사를 모듈로 분리한 POJO 시스템은 기민함을 제공한다.
  * 이런 기민함으로 인해, 최신 정보에 기반해 최선의 시점에 최적으 결정을 내리기가 쉬워진다.
  * 또한 결정의 복잡성도 줄어든다.

### 명백한 가치가 있을 때 표준을 현명하게 사용하라
* 표준을 사용하려면 아이디어와 컴포넌트를 재사용하기 쉽고, 적절한 경험을 가진 사람을 구하기 쉬우며, 좋은 아이디어를 캡술화하기 쉽고, 컴포넌트를 엮기 쉽다.
* 하지만 때로는 표준은 만드는 시간이 너무 오래 걸려 업계가 기다리지 못한다.
* 어떤 표즌은 원래 표준을 제정한 목적을 잊어버리기도 한다.

### 시스템은 도메인 특화 언어가 필요하다
* 건축 분야 역시 필수적인 정보를 명료하고 정확하게 전달하는 어휘, 관용구, 패턴이 풍바하다.
* 소프트웨어 분야에서도 DSL이 새롭게 조명받기도 했다.
* DSL은 간단한 스크립트 언어나 표준 언어로 구현한 API를 가리킨다.
* DSL로 짠 코드는 도메인 전문가가 작성한 구조적인 산문처럼 읽힌다.
* 좋은 DSL은 도메인 개념과 그 개념을 구현한 코드 사이에 존재하는 의사소통 간극을 줄여준다. (애자일 기법이 팀과 프로젝트 이해관계자 사이에 의소소통 간극을 줄여주듯이)
* 효과적으로 사용한다면 DSL은 추상화 수준을 코드 관용구나 디자인 패턴 이상으로 끌어올려, 개발자가 적절한 추상화 수준에서 코드 의도를 표현할 수 있다.
* DSL을 사용하면 고차원 정책에서 저차원 세부사항에 이르기까지 모든 추상화 수준과 모든 도메인을 POJO로 표현할 수 있다.

### 결론
* 시스템은 역시 깨끗해야 한다.
* 깨끗하지 못한 아키텍처는 도메인 논리를 흐리며 기민성을 떨어뜨린다.
* 도메인 논리가 흐려지면 버그가 숨어들기 쉬워지고, 스토리를 구현하기 어려워지기 때문에 제품 품질이 떨어진다.
* 기민성이 떨어지면 생산성이 낮아져 TDD가 제공하는 장점이 사라진다.
* 모든 추상화 단계에서 의도는 명확히 표현해야 하며, 그러기 위해선 POJO를 작성하고 관점 혹은 관점과 유사한 메커니즘을 사용해 각 구현 관심사를 분리해야 한다.
* 시스템을 설계하든 개별 모듈을 설계하든 실제로 돌아가는 가장 단순한 수단을 사용해야 한다는 사실을 명심해야 한다.

## 12. 창발성
### 창발적 설계로 깔끔한 코드를 구현하자
* 켄트 벡이 제시한 단순한 설계규칙 네 가지는 소프트웨어 설계 품질을 크게 높여준다.
1. 모든 테스트를 실행한다.
2. 중복을 없앤다.
3. 프로그래머 의도를 표현한다.
4. 클래스와 메서드 수를 최소로 줄인다.
* 위 네가지 규칙은 중요도 순이다.

### 단순한 설계 규칙 1: 모든 테스트를 실행하라
* 설계는 의도한 대로 돌아가는 시스템을 내놓아야 한다.
* 테스트를 철저히 거쳐 모든 테스트 케이스를 항상 통과하는 시스템은 테스트가 가능한 시스템이다.
* 테스트가 가능한 시스템을 만들려고 노력하면 설계 품질이 더불이 높아진다.
* 결합도가 높으면 테스트 케이스를 작성하기 어려우므로, 테스트 케이스를 많이 작성할수록 개발자는 DIP와 같은 원칙을 적용하고 DI, 인터페이스, 추상화 등과 같은 도구를 사용해 결합도를 낮춘다. (설계 품질 높아짐)
* 따라서 테스트 케이스를 만들고 계속 돌려야 된다는 간단하고 단순한 규칙을 따르면 시스템의 품질은 저절로 높아진다.

### 단순한 설계 규칙 2~4: 리팩터링
* 테스트 케이스를 모두 작성했다면 이제 코드와 클래스를 정리해도 좋다.
* 테스트 케이스가 있으므로, 코드를 정리하면서 시스템이 깨질까 걱정할 필요는 없다.
* 리팩터링 단계에서는 소프트웨어 설계 품질을 높이는 기법이라면 무엇이든 적용해도 괜찮다.
* 응집도를 높이고, 결합도를 낮추고, 관심사를 분리하고, 시스템 관심사를 모듈로 나누고, 함수와 클래스 크기를 줄이고, 더 나은 이름을 선택하는 등 다양한 기법을 동원한다.
* 또한 단순한 설계 규칙 중 나머지 3개를 적용해 중복을 제거하고, 프로그래머 의도를 표현하고, 클래스와 메서드 수를 최소로 줄이는 단계이다.

### 중복을 없애라
* 중복은 추가 작업, 추가 위험, 불필요한 복잡도를 뜻하기 때문에 우수한 설계에서 중복은 커다란 적이다.
* 똑같은 코드는 당연히 중복이고, 비슷한 코드는 더 비슷하게 고쳐주면 리팩터링이 쉬워진다.
* 구현 중복도 중복의 한 형태이다.

### 표현하라
* 자신이 이해하는 코드를 짜기는 쉽다.
* 하지만 나중에 코드를 유지보수할 사람이 코드를 짜는 사람만큼이나 문제를 깊이 이해할 가능성은 희박하다.
* 개발자가 코드를 명백하게 짤수록 다른 사람이 그 코드를 이해하기 쉬워지며, 그로인해 결함이 줄어들고 유지보수 비용이 적게든다.
* 코드를 명백하게 짜기 위한 아래와 같은 방법이 있다.
1. 좋은 이름을 선택한다.
2. 함수와 클래스 크기를 가능한 줄인다.
3. 표준 명칭을 사용한다.
4. 단위 테스트 케이스를 꼼꼼히 작성한다.
* 하지만 코드의 표현력을 높이는 가장 중요한 방법은 노력이다.
  * 흔히 코드만 돌린 후 다음 문제로 직행하는 사례가 너무도 흔하다.
  * 나중에 읽을 사람을 고려해 조금이라도 읽기 쉽게 만들려는 충분한 고민은 거의 찾기 어렵다.
* 나중에 코드를 읽을 사람은 바로 자신일 가능성이 높다는 사실을 명심해야 한다.

### 클래스와 메서드 수를 최소로 줄여라
* 중복을 제거하고, 의도를 표현하고, SRP를 준수한다는 기본적인 개념도 극단으로 치달으면 득보다 실이 많아진다.
* 클래스와 메서드 크기를 줄이자고 조그만 클래스와 메서드를 수없이 만드는 사례도 있다.
* 따라서 이 규칙은 함수와 클래스 수를 **가능한** 줄이라고 제안한다.
* 때로는 무의미하고 독단적인 정책 탓에 클래스 수와 메서드 수가 늘어나기도 한다.
  * 클래스마다 무조건 인터페이스를 생성하라고 요구하는 구현 표준이 좋은 예다.
  * 자료 클래스와 동작 클래스는 무조건 분리해야 한다고 주장하는 개발자도 좋은 예다.
  * 가능한 독단적인 견해는 멀리하고 실용적인 방식을 택해야 한다.
* 클래스와 함수 수를 줄이는 작업도 중요하지만, 테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업이 더 중요하다.

### 결론
* 경험을 대신할 단순한 개발 기법은 당연히 없다.
* 하지만 여기서 소개하는 기법들은 저자들이 수십 년 동안 쌓은 경험의 정수이다.
* 단순한 설계 규칙을 따른다면 오랜 경험 후에야 익힐 우수한 기법과 원칙을 단번에 활용할 수 있다.

## 13. 동시성
### 동시성이 필요한 이유?
* 동시성은 결합을 없애는 전략이다.
* 무엇(what)과 언제(when)를 분리하는 전략이다.
* 쓰레드가 하나인 프로그램은 무엇과 언제가 서로 밀접하다.
  * 흔히 단일 쓰레드 프로그램을 디버깅하는 프로그래머는 정지점을 정한 후 어느 정지점에 걸렸는지 살펴보면서 시스템 상태를 파악한다.
* 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다.
* 구조적인 관점에서 프로그램은 거대한 루프 하나가 아니라 작은 협력 프로그램 여럿으로 보인다.
* 따라서 시스템을 이해하기가 쉽고 문제를 분리하기도 쉽다.
* 구조적 개선만을 위해 동시성을 채택하는 건 아니며, 어떤 시스템은 응답 시간과 작업 처리량 개선이라는 요구사항으로 인해 직접적인 동시성 구현이 불가피하다.

#### 미신과 오해
* 반드시 동시성이 필요한 상황이 존재하지만, 동시성은 어렵기 때문에 각별히 주의하지 않으면 난감한 상황에 처한다.
* 동시성과 관련한 일반적인 미신과 오해가 있다.
  * 동시성은 항상 성능을 높여준다.
    * 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다.
  * 동시성을 구현해도 설계는 변하지 않는다.
    * 단일 쓰레드 시스템과 다중 쓰레드 시스템은 설계가 판이하게 다르다. (시스템 구조가 크게 달라짐)
  * 웹 또는 EJB 컨테이너 등을 사용하면 동시성을 이해할 필요가 없다.
    * 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지를 알아야 한다.
* 반대로 동시성과 관련된 타당한 생각도 있다.
  * 동시성은 다소 부하를 유발한다.
  * 동시성은 복잡하다.
  * 일반적으로 동시성 버그는 재현하기 어렵다.
  * 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.

### 난관
* 두 쓰레드가 자바 코드 한 줄을 거쳐가는 경로는 많다.
* 경로는 굉장히 많은데, 그 중 대다수 경로는 올바른 결과를 내놓지만, 잘못된 결과를 내놓는 일부 경로가 문제가 된다.

### 동시성 방어 원칙
* 동시성 코드가 일으키는 문제로부터 시스템을 방어하는 원칙과 기술이 있다.

#### 단일 책임 원칙
* SPR는 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙이다.
* 동시성은 복잡성 하나만으로도 따로 분리할 이유가 충분하다.
* 따라서 **동시성 관련 코드는 다른 코드와 분리**해야 한다.
* 동시성을 구현할 때는 몇 가지를 고려해야 한다.
  * 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
  * 동시성 코드에는 독자적인 난관이 있는데, 다른 코드에서 겪는 난관과 다르며 훨씬 어렵다.
  * 잘못 구현한 동시성 코드는 별의별 방식으로 실패하기 떄문에, 주변에 있는 다른 코드가 발목을 잡지 않더라도 덩시성 하나만으로도 충분히 어렵다.

#### 따름정리: 자료 범위를 제한하라
* 객체 하나를 공유한 후 동일 필드를 수정하던 두 쓰레드가 서로 간섭하므로 예상치 못한 결과를 내놓는다.
* 이런 문제를 해결하는 방안으로 공유 객체를 사용하는 코드 내 임계영역을 synchronized 키워드로 보호하라고 권장한다.
* 이런 임계영역의 수를 줄이는 기술이 중요하다.
* 공유 자료를 수정하는 위치가 많을수록 다음과 같은 가능성도 커진다
  * 보호할 임계영역을 빼먹는다. (공유 자료를 수정하는 모든 코드를 망가뜨림)
  * 모든 임계 영역을 올바로 보호했는지 확인하느라 똑같은 노력과 수고를 반복한다.
  * 그렇지 않아도 찾아내기 어려운 버그가 더욱 찾기 어려워진다.
* 따라서 자료를 캡슐화하여 공유 자료를 최대한 줄여야 한다.

#### 따름 정리: 자료 사본을 사용하라
* 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다.
* 어떤 경우에는 객체를 복사해 읽기 전용으로 사용하는 방법이 가능하고, 어떤 경우에는 각 쓰레드가 객체를 복사해 사용한 후 한 쓰레드가 해당 사본에서 결과를 가져오는 방법도 가능하다.
* 공유 객체를 피하는 방법이 있다면 코드가 문제를 일으킬 가능성도 아주 낮아진다.
* 객체를 복사하는 시간과 부하가 걱정일 수 있지만, 사본으로 동기화를 피할 수 있다면 내부 잠금을 없애 절약한 수행 시간이 사본 생성과 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 크다.

#### 따름 정리: 쓰레드는 가능한 독립적으로 구현하라
* 다른 쓰레드와 자료 공유를 하지 않고, 각 쓰레드는 클라이언트 요청 하나를 처리한다.
* 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장한다.
* 그러면 각 쓰레드는 다른 쓰레드와 동기화할 필요가 없으므로 자신만 있는 듯이 돌아갈 수 있다.
* 독자적인 쓰레드로, 가능하면 다른 프로세서에서 돌려도 괜찮도록, 자료를 독립적인 단위로 분할해야 한다.

### 라이브러리를 이해하라
* 자바 5는 동시성 측면에서 이전 버전보다 많이 나아졌고, 쓰레드 코드를 구현한다면 다음과 같은 사항을 고려해야 한다.
  * 쓰레드 환경에 안전한 컬렉션을 사용한다.
  * 서로 무관한 작업을 수행할 때는 executor 프레임워크를 사용한다.
  * 가능하다면 쓰레드가 차단되지 않는 방법을 사용한다.
  * 일부 클래스 라이브러리는 쓰레드에 안전하지 못하다.

#### 쓰레드 환경에 안전한 컬렉션
* Doug Lea는 Cuncurrent Programming in Java라는 책을 집필하며, 쓰레드에 사용해도 안전한 컬렉션 클래스를 구현했다.
* java.util.concurrent 패키지가 제공하는 클래스는 다중 쓰레드 환경에서 사용해도 안전하며, 성능도 좋다.
  * 실제로 ComcurrentHashMap의 경우 거의 모든 환경에서 HashMap보다 빠르다.
* 동시 읽기/쓰기를 지원하며, 자주 사용하는 복합 연산을 다중 쓰레드 상에서 안전하게 만든 메서드로 제공한다.
* 복잡한 동시성 설계를 지원하고자 자바5에는 다른 클래스도 추가되었다. 
  * `ReentrantLock` 한 메서드에서 잠그고 다른 메서드에서 푸는 락이다.
  * `Semaphore` 젼형적인 세마포로, 개수가 있는 락이다.
  * `CountDownLatch` 지정한 수만큼 이벤트가 발생하고 나서야 대기중인 쓰레드를 모두 해제하는 락이다. (모든 쓰레드에게 동시에 공평하게 시작할 기회를 줌)
* 언어가 제공하는 클래스를 검토해야 한다.
  * `java.util,concurrent`, `java.util.concurrent.atomic`, `java.util.concurrent.locks` 등을 익혀야 한다.

### 실행 모델을 이해하라
* 다중 쓰레드 애플리케이션을 분류하는 방식은 여러가지로, 몇 가지 기본 용어가 있다.
  * 한정된 자원(Bound Resource) : 다중 쓰레드 환경에서 사용하는 자원으로 크기가 숫자가 제한적이다. 데이터베이스 연결, 길이가 일정한 읽기/쓰기 버퍼 등이 예다.
  * 상호 배제(Mutual Exclusion) : 한 번에 한 쓰레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.
  * 기아(Starvation) : 한 쓰레드나 여러 쓰레드가 굉장히 오랫동안 혹은 여원히 자원을 기다린다. 예로 항상 짧은 쓰레드에게 우선순위를 준다면 짧은 쓰레드가 지속적으로 이어질 경우, 긴 쓰레드가 기아 상태에 빠진다.
  * 데드락(Deadlock) : 여러 쓰레드가 서로가 끝나기를 기다린다. 모든 쓰레드가 각기 필요한 자원을 다른 쓰레드가 점유하는 바람에 어느 쪽도 더 이상 진행하지 못한다.
  * 라이브락(Livelock) : 락을 거는 단계에서 각 쓰레드가 서로를 방해한다. 쓰레드는 계속해서 진행하려 하지만, 공명으로 인해 굉장히 오랫동안 혹은 영원하 진행하지 못한다.
* 다중 쓰레드 프로그래밍에서 사용하는 실행 모델들이 있다.

#### 생산자-소비자(Producer-Consumer)
* 하나 이상 생산자 쓰레드가 정보를 생성해 버퍼나 대기열(queue)에 넣는다.
* 하나 이상 소비자 쓰레드가 대기열에서 정보를 가져와 사용한다.
* 생산자 쓰레드와 소비자 쓰레드가 사용하는 대기열은 한정된 자원이다.
* 생산자 쓰레드는 대기열에 빈 공간이 있어야 정보를 채운다. (빈 공간이 생길 때까지 기다림)
* 소비자 쓰레드는 대기열에 정보가 있어야 가져온다. (정보가 채워질 때까지 기다림)
* 대기열을 올바로 사용하고자 생산자 쓰레드와 소비자 쓰레드는 서로에게 시그널을 보낸다.
* 생산자 쓰레드는 대기열에 정보를 채운 다음 소비자 쓰레드에게 대기열에 정보가 있다는 시그널을 보낸다.
* 소비자 쓰레드는 대기열에서 정보를 읽어들인 후 대기열에 빈 공간이 있다는 시그널을 보낸다.
* 잘못하면 생산자 쓰레드와 소비자 쓰레드가 둘 다 진행 가능함에도 불구하고 동시에 서로에게서 시그널을 기다릴 가능성이 존재한다.

#### 읽기-쓰기(Readers-Writers)
* 읽기 쓰레드를 위한 주된 정보원으로 공유 자원을 사용하지만 쓰기 쓰레드가 이 공유 자원을 이따금 갱신하는 경우, 처리율이 문제의 핵심이다.
* 처리율을 강조하면 기아 현상이 생기거나 오래된 정보가 쌓이고, 갱신을 허용하면 처리율에 영향을 미친다.
* 쓰기 쓰레드가 버퍼를 갱신하는 동안 읽기 쓰레드가 버퍼를 읽지 않으려면, 마찬가지로 읽기 쓰레드가 버퍼를 읽는 동안 쓰게 쓰레드가 버퍼를 갱신하지 않으려면, 복잡한 균형잡기가 필요하다.
* 대개는 쓰기 쓰레드가 버퍼를 오랫동안 유지하는 바람에 여러 읽기 쓰레드가 버퍼를 기다리느라 처리율이 떨어진다.
* 따라서 읽기 쓰레드의 요구와 쓰기 쓰레드의 요구를 적절히 만족시켜줄 처리율도 높이고 기아도 방지하는 해법이 필요한데, 간단한 전력은 읽기 쓰레드가 없을 때까지 갱신을 원하는 쓰기 쓰레드가 버퍼를 기다리는 방법이다.
  * 읽기 쓰레드가 계속 이어진다면 쓰기 쓰레드는 기아 상태에 빠진다.
  * 반면 쓰기 쓰레드에게 우선권을 준 상태에서 쓰기 쓰레드가 계속 이어진다면 처리율이 떨어진다.
  * 양쪽 균형을 잡으면서 동시에 갱신 문제를 피하는 해법이 필요하다.

### 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
* 동기화하는 메서드 사이에 의존성이 존재하면 동시성 코드에서 찾아내기 어려운 버그가 생긴다.
* 자바 언어는 개별 메서드를 보호하는 synchronized 라는 개념을 지원하지만, 공유 클래스 하나에 동기화된 메서드가 여럿이라면 구현이 올바른지 다시 한 번 확인해야 한다.
* 공유 객체 하나에는 메서드 하나만 사용하는게 좋다.
* 하지만 공유 객체 하나에 여러 메서드가 필요한 상황도 생기는데, 그럴 떄는 다음 세 가지 방법을 고려해야 한다.
1. 클라이언트에서 잠금
   * 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠그고, 마지막 메서드를 호출할 때까지 잠금을 유지한다.
2. 서버에서 잠금
   * 서버에다 서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는 메서드를 구현하고, 클라이언트는 이 메서드를 호출한다.
3. 연결 서버
   * 잠금을 수행하는 중간 단계를 생성한다.
   * 서버에서 잠금 방식과 유사하지만 원래 서버는 변경하지 않는다.

### 동기화하는 부분을 작게 만들어라
* 자바에서 synchronized 키워드를 사용하면 락을 설정한다.
* 같은 락으로 감싼 모든 코드 영억은 한 번에 한 쓰레드만 실행이 가능하기 때문에, 락은 쓰레드를 지연시키고 부하를 가중시킨다.
* 그러므로 여기저기서 synchronized 문을 남발하는 코드는 바람직하지 않지만, 임계영역은 반드시 보호해야 한다.
* 따라서 코드를 짤 때 임계 영역 수를 최대한 줄여야 한다.
  * 임계영역 개수를 줄인답시고 거대한 임계영역 하나로 구현하기도 하는데, 필요 이상으로 임계영역 크기를 키우면 쓰레드 간에 경쟁이 늘어나고 프로그램 성능이 떨어진다.

### 올바른 종료 코드는 구현하기 어렵다
* 영구적으로 돌아가는 시스템을 구현하는 압업과 잠시 돌다 깔끔하게 종료하는 시스템을 구현하는 방법은 다르다.
* 깔끔하게 종료하는 코드는 올바로 구현하기 어려운데, 가장 흔히 발생하는 문제가 데드락이다. (쓰레드가 절대 오지 않을 시그널을 기다림)
* 예로 부모 쓰레드가 자식 쓰레드를 여러 개 만든 후 모두가 끝나기를 기다렸다가 자원을 해제하고 종료하는 시스템이 있다고 가정한다.
  * 만약 자식 쓰레드 중 하나가 데드락에 걸렸으면 부모 쓰레드는 영원히 기다리고, 시스템은 영원히 종료하지 못한다.
* 또다른 예로 유사한 시스템이 사용자에게서 종료하라는 지시를 받았다고 가정한다.
  * 부모 쓰레드는 모든 자식 쓰레드에게 작업을 멈추고 종료하라는 시그널을 전달한다.
  * 그런데 자식 쓰레드 중 두 개가 생산자-소비자 관계라면, 생산자 쓰레드는 재빨리 종료했는데 소비자 쓰레드가 생산자 쓰레드에서 오는 메세지를 기다리므로 차단 상태가 되어 종료하라는 시그널을 못 받는다.
* 따라서 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현해야 하는데, 생각보다 오래 걸리고 어려우므로 이미 나온 알고리즘을 검토해봐야 한다.

### 쓰레드 코드 테스트하기
* 코드가 올바르다고 증명하기는 현실적으로 불가능하다. 테스트가 정확성을 보장하지는 않지만, 그럼에도 충분한 테스트는 위험을 낮춘다.
* 쓰레드가 하나인 프로그램은 위 말이 모두 옳지만, 같은 코드와 같은 자원을 사용하는 쓰레드가 둘 이상으로 늘어나면 상황은 급격하게 복잡해진다.
* 문제를 노출하는 테스트 케이스를 작성해야 하며, 프로그램 설정과 시스템 설정과 부하를 바꿔가며 자주 돌려야 한다.
* 테스트가 실패하면 원인을 추적해야 한다. (다시 돌렸더니 통과한다고 그냥 넘어가면 절대 안됨)
* 쓰레드 코드 테스트와 관련된 몇 가지 구체적인 지침이 있다.

#### 말이 안 되는 실패는 잠정적인 쓰레드 문제로 취급하라
* 다중 쓰레드 코드는 때때로 말이 안 되는 오류를 일으킨다.
* 대다수 개발자는 쓰레드가 다른 코드와 교류하는 방식을 직관적으로 이해하지 못한다.
* 따라서 실패를 재현하기 아주 어려워 우주선(cosmic-ray), 하드웨어 문제, 단순한 일회성 문제로 치부하고 무시한다.
* 일회성 문제란 존재하지 않는다고 가정하는 편이 안전하며, 시스템 실패를 일회성이라 치부하면 안된다.
  * 일회성 문제를 계속 무시한다면 잘못된 코드 위에 코드가 계속 쌓인다.

#### 다중 쓰레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
* 쓰레드 환경 밖에서 코드가 제대로 도는지 반드시 확인해야 한다.
* 일반적인 방법으로, 쓰레드가 호출하는 POJO를 만들면 쓰레드 환경 밖에서 테스트가 가능하다. (POJO는 쓰레드를 모름)
* 쓰레드 환경 밖에서 생기는 버그와 쓰레드 환경에서 생기는 버그를 동시에 디버깅 하지 말고, 쓰레드 환경 밖에서 코드를 올바로 돌려야 한다.

#### 다중 쓰레드는 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 쓰레드 코드를 구현하라
* 다중 쓰레드를 쓰는 코드를 다양한 설정으로 실행하기 쉽게 구현한다.
  * 한 쓰레드로 실행하거나, 여러 쓰레드로 실행하거나, 실행 중 쓰레드 수를 바꿔본다.
  * 쓰레드 코드를 실제 환경이나 테스트 환경에서 돌려본다.
  * 테스트 코드를 빨리, 천천히, 다양한 속도로 돌려본다.
  * 반복 테스트가 가능하도록 테스트 케이스를 작성한다.

#### 다중 쓰레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
* 적절한 쓰레드 개수를 파악하려면 상당한 시행착오가 필요하다.
* 처음부터 다양한 설정으로 프로그램의 성능 측정 방법을 강구한다.
* 쓰레드 개수를 조율하기 쉽게 코드를 구현해야 하며, 프로그램이 돌아가는 도중에 쓰레드 개수를 변경하는 방법도 고려해야 한다.
* 프로그램 처리율과 효율에 따라 스스로 쓰레드 개수를 조율하는 코드도 고민해야 한다.

#### 프로세서 수보다 많은 쓰레드를 돌려보라
* 시스템이 쓰레드를 스와핑 할 때도 문제가 발생한다.
* 스와핑을 일으키려면 프로세서 수보다 많은 쓰레드를 돌린다.
* 스와핑이 잦을수록 임계영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워진다.

#### 다른 플랫폼에서 돌려보라
* 운영체제마다 쓰레드를 처리하는 정책이 다르다.
* 따라서 다중 쓰레드 코드는 플랫폼에 따라 다르게 돌아간다.
* 코드가 돌아갈 가능성이 있는 플랫폼 전부에서 테스트를 수행해야 한다.

#### 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라
* 흔히 쓰레드 코드는 오류를 찾기가 쉽지 않기 때문에, 간단한 테스트로는 버그가 드러나지 않는다.
* 쓰레드 버그가 산발적이고 우발적이고 재현이 어려운 이유는 코드가 실행되는 많은 경로 중에 아주 소수만 실패하기 때문이다.
* 보조 코드를 추가해 코드가 실행되는 순서를 바꿔서 코드를 다양한 순서로 실행되도록 하면 버그가 드러날 가능성도 높이진다. 
* 코드에 보조 코드를 추가하는 방법은 두가지다.
  * 직접 구현하기
  * 자동화
##### 직접 구현하기
* 코드에다 직접 `wait()`, `sleep()`, `yield()`, `priority()` 함수를 추가한다.
* 하지만 이 방법은 여러 문제가 있다.
  * 보조 코드를 삽입할 적정 위치를 직접 찾아야 한다.
  * 어떤 함수를 어디서 호출해야 적당한지 알아야 한다.
  * 배포 환경에 보조 코드를 그대로 남겨두면 프로그램 성능이 떨어진다.
  * 무작위적이다. 오류가 드러날지도 모르고 드러나지 않을지도 모르며, 사실상 드러나지 않을 확률이 더 높다.
* 따라서 배포 환경이 아니라 테스트 환경에서 보조 코드를 실행할 방법이 필요하고, 실행할 때마다 설정을 바꿔줄 방법도 필요하다.
* 쓰레드를 전혀 모르는 POJO와 쓰레드를 제어하는 클래스로 프로그램을 분할하면 보조 코드를 찾기가 쉬워지며, 여러 상황에서 sleep, yield 등으로 POJO를 호출하게 다양한 테스트 지그를 구현할 수도 있다.

##### 자동화
* 보조 코드를 자동으로 추가하려면 AOF(Aspect-Oriented Framework), CGLIB, ASM 등과 같은 도구를 사용한다.
* 코드를 흔드는(jiggle) 이유는 쓰레드를 매번 다른 순서로 실행하기 위해서다.
* 좋은 테스트 케이스와 흔들기(jiggling)기법은 오류가 드러날 확률을 크게 높여준다.

### 결론
* 다중 쓰레드 코드는 올바로 구현하기 어렵다.
* 간단했던 코드가 여러 쓰레드와 공유 자료를 추가하면서 악몽으로 변한다.
* 다중 쓰레드 코드를 작성한다면 각별히 깨끗하게 코드를 짜야 한다.
* SRP를 준수하고, POJO를 사용해 쓰레드를 아는 코드와 쓰레드를 모르는 코드를 분리하며, 쓰레드 코드를 테스트 할 때는 전적으로 쓰레드만 테스트한다.
  * 쓰레드 코드는 최대한 집약되고 작야아 한다는 의미이다.
* 동시성 오류를 일으키는 잠정적인 원인을 철저히 이해해야 한다.
  * 루프 반복을 끝내거나 프로그램을 깔끔하게 종료하는 등 경계 조건의 경우가 까다로우므로 특히 주의한다.
* 사용하는 라이브러리와 기본 알고리즘을 이해한다.
  * 특정 라이브러리 기능이 기본 알고리즘과 유사한 어떤 문제를 어떻게 해결하는지 파악해야 한다.
* 보호할 코드 영억을 찾아내는 방법과 특정 코드 영역을 잠그는 방법을 이해한다.
  * 잠글 필요가 없는 코드는 잠그지 않는다.
  * 잠긴 영역에서 다른 잠긴 영역을 호출하지 않는다.
  * 그러기 위해선 공유하는 정보와 공유하지 않는 정보를 제대로 이해해야 한다.
  * 공유 객체 수와 범위를 최대로 줄이고, 클라이언트에게 공유 상태를 관리하는 책임을 떠넘기지 않는다.
* 어떻게든 문제는 생기며, 초반에 드러나지 않는 문제는 일회성으로 치부해 무시하기 십상이다.
  * 일회성 문제는 대개 시스템에 부하가 걸릴때나 아니면 뜬금없이 발생한다.
  * 따라서 쓰레드 코드는 많은 플랫폼에서 많은 설정으로 반복해서 계속 테스트해야 한다.
  * 테스트 용이성은 TDD 3개 규칙을 따르면 자연히 얻어진다.
* 시간을 들여 보조 코드를 추가하면 오류가 드러날 가능성이 크게 높아진다.
  * 직접 구현해도 괜찮고, 몇 가지 자동화 기술을 사용해도 괜찮다.
  * 초반부터 보조 코드를 고려해야 하며, 쓰레드 코드는 출시하기 전까지 최대한 오랫동안 돌려봐야 한다.

## 14. 점진적인 개선
### 점진적으로 개선하다
* 깨끗한 코드를 짜려면 먼저 지저분한 코드를 짠 뒤에 개선해야 한다.
* 하지만 프로그램을 망치는 가장 좋은 방법 중 하나는 개선이라는 이름 아래 구조를 크게 뒤집는 행위다.
* 어떤 프로그램은 그저 그런 개선에서 결코 회복하지 못하는데, 개선 전과 똑같이 프로그램을 돌리기가 아주 어렵기 때문이다.
* 그래서 TDD 기법을 사용해야 한다. 
  * TDD는 언제 어느때라도 시스템이 돌아가야 한다는 원칙을 따른다.
  * 따라서 TDD는 시스템을 망가뜨리는 변경을 허용하지 않는다.
* 변경 전후에 시스템이 똑같이 돌아간다는 사실을 확인하려면 언제든 실행이 가능한 자동화된 테스트 슈트가 필요하다.

### 코드 개선 과정
* 246p ~ 320p 코드 개선 과정 참고

### 결론
* 단순히 돌아가는 코드에 만족한느 프로그래머는 전문가 정신이 부족하다.
* 나쁜 코드보다 더 오랫동안 더 심각하게 개발 프로젝트에 악영향을 미치는 요인도 없다.
* 물론 나쁜 코드도 깨끗한 코드로 개선할 수 있지만, 비용이 엄청나게 많이 든다.
  * 코드가 썩어가며 모듈은 서로서로 얽히고 설켜 숨겨진 의존성이 수도 없이 생긴다.
  * 오래된 의존성을 찾아내 깨려면 상당한 시간과 인내심이 필요하다.
* 처음부터 코드를 깨끗하게 유지하기란 상대적으로 쉽다.
  * 오전에 엉망으로 만든 코드를 오후에 정리하기는 어렵지 않다.
  * 5분전에 엉망으로 만든 코드는 지금 당장 정리하기 아주 쉽다.
* 코드는 절대로 방치하면 안되고, 언제나 최대한 깔끔하고 단순하게 정리해야 한다.
 
## 15. JUnit 들여다보기
### JUnit 프레임워크
* 살펴볼 모듈은 문자열 비교 오류를 파악할 때 유용한 코드인 `ComparisonCompactor`라는 모듈로, 영리하게 짜인 코드이다.
```java
package junit.framework;

public class ComparisonCompactor {

    private static final String ELLIPSIS = "...";
    private static final String DELTA_END = "]";
    private static final String DELTA_START = "[";

    private int fContextLength;
    private String fExpected;
    private String fActual;
    private int fPrefix;
    private int fSuffix;

    public ComparisonCompactor(int contextLength, String expected, String actual) {
        fContextLength = contextLength;
        fExpected = expected;
        fActual = actual;
    }

    public String compact(String message) {
        if (fExpected == null || fActual == null || areStringsEqual()) {
            return Assert.format(message, fExpected, fActual);
        }

        findCommonPrefix();
        findCommonSuffix();
        String expected = compactString(fExpected);
        String actual = compactString(fActual);
        return Assert.format(message, expected, actual);
    }

    private String compactString(String source) {
        String result = DELTA_START + source.substring(fPrefix, source.length() - fSuffix + 1) + DELTA_END;
        if (fPrefix > 0) {
            result = computeCommonPrefix() + result;
        }
        if (fSuffix > 0) {
            result = result + computeCommonSuffix();
        }
        return result;
    }

    private void findCommonPrefix() {
        fPrefix = 0;
        int end = Math.min(fExpected.length(), fActual.length());
        for (; fPrefix < end; fPrefix++) {
            if (fExpected.charAt(fPrefix) != fActual.charAt(fPrefix)) {
                break;
            }
        }
    }

    private void findCommonSuffix() {
        int expectedSuffix = fExpected.length() - 1;
        int actualSuffix = fActual.length() - 1;
        for (; actualSuffix >= fPrefix && expectedSuffix >= fPrefix; actualSuffix--, expectedSuffix--) {
            if (fExpected.charAt(expectedSuffix) != fActual.charAt(actualSuffix)) {
                break;
            }
        }
        fSuffix = fExpected.length() - expectedSuffix;
    }

    private String computeCommonPrefix() {
        return (fPrefix > fContextLength ? ELLIPSIS : "") + fExpected.substring(Math.max(0, fPrefix - fContextLength), fPrefix);
    }

    private String computeCommonSuffix() {
        int end = Math.min(fExpected.length() - fSuffix + 1 + fContextLength, fExpected.length());
        return fExpected.substring(fExpected.length() - fSuffix + 1, end) + (fExpected.length() - fSuffix + 1 < fExpected.length() - fContextLength ? ELLIPSIS : "");
    }

    private boolean areStringsEqual() {
        return fExpected.equals(fActual);
    }
}
```
* 저자들이 모듈을 아주 좋은 상태로 남겨두었지만 보이스카우트 규칙에 따르면 우리는 처음 왔을 때보다 더 깨끗하게 해놓고 떠나야 한다.

### 접두어 f 제거를 모두 제거하자
```java
private int contextLength;
private String expected;
private String actual;
private int prefix;
private int suffix;
```

### compact 함수 시작부에 캡슐화되지 않은 조건문이 보인다.
* 의도를 명확히 표현하려면 조건문을 캡슐화해야 한다.
* 따라서 조건문을 메서드로 뽑아내 적절한 이름을 붙인다.
```java
public String compact(String message) {
    if (shouldNotCompact) {
        return Assert.format(message, expected, actual);
    }

    findCommonPrefix();
    findCommonSuffix();
    String expected = compactString(expected);
    String actual = compactString(actual);
    return Assert.format(message, expected, actual);
}

private boolean shouldNotCompact() {
    return expected == null || actual == null || areStringsEqual();
}
```

### 이름은 명확하게 붙이자
* 함수에 이미 expected라는 지역 변수가 있는데 this.expected와 this.actual은 거슬린다. (fExpected에서 f를 빼버리는 바람에 생긴 결과)
* 함수에서 멤버 변수와 이름이 똑같은 변수를 사용하는 이유는 이름을 명확하게 붙이지 않아서이다.
* 따라서 이름은 명확하게 붙인다.
```java
String compactExpected = compactString(expected);
String compactActual = compactString(actual);
```

### 부정문은 긍정문보다 이해하기 약간 더 어렵다. 부정문을 긍정문으로 표현하자
```java
public String compact(String message) {
    if (canBeCompacted()){
        findCommonPrefix();
        findCommonSuffix();
        String compactExpected = compactString(expected);
        String compactActual = compactString(actual);
        return Assert.format(message, compactExpected, compactActual);
    } else {
        return Assert.format(message, expected, actual);
    }
}

private boolean canBeCompacted() {
    return expected != null && actual != null && !areStringsEqual();
}
```

### 함수의 이름으로 명확하게 설명하자
* 문자열을 압축하는 함수지만, canBeCompacted가 false면 압축하지 않는다.
* 게다가 함수는 단순히 압축된 문자열이 아니라 형식이 갖춰진 문자열을 반환한다.
* 따라서 formatCompatedComparison이라는 이름이 적합하다.

### 함수가 한가지 일만 하도록 분리하자
```java
...
    private String compactExpected;
    private String compactActual;
...
    public String format CompactedComparison(String message) {
        if (canBeCompacted()) {
            compactExpectedAndActual();
            return Asswert.formay(message, compactExpected, compactActual);
        } else {
            return Asswert.format(message, expected, actual)
        }
    }
    
    private void compactExpectedAndActual() {
        findCommonPrefix();
        findCommonSuffix();
        compactExpected = compactString(expected);
        compactActual = compactString(actual);
    }
```
* 예상 문자열과 실제 문자열을 진짜로 압축하는 부분을 함수를 빼내어 compactExpectedActual이라는 메서드로 만든다.
* compactExpected와 compactActual을 멤버 변수로 승격했다.


### 함수를 일관적으로 사용하자
* 위 코드의 새로 분리한 함수에서 1~2줄은 반환값이 없고 3~4줄은 변수를 반환한다.
* 함수의 사용방식이 일관적이지 못하므로, 일관적으로 사용하게 변경한다.
```java
private compactExpectedAndActual() {
    prefixIndex = findCommonPrefix();
    suffixIndex = findCommonSuffix();
    String compactExpected = compactString(expected);
    String compactActual = compactString(actual);
}

private int findCommonPrefix() {
    int prefixIndex = 0;
    int end = Math.min(expected.length(), actual.length());
    for (; prefixIndex < end; prefixIndex++) {
        if (expected.charAt(prefixIndex) != actual.charAt(prefixIndex)) {
            break;
        }
    }
    return prefixIndex;
}

private int findCommonSuffix() {
    int expectedSuffix = expected.length() - 1;
    int actualSuffix = actual.length() - 1;
    for (; actualSuffix >= prefixIndex && expectedSuffix >= prefix; actualSuffix--, expectedSuffix--) {
        if (expected.charAt(expectedSuffix) != actual.charAt(actualSuffix)) {
            break;
        }
    }
    return expected.length() - expectedSuffix;
}
```

### 숨겨진 시각적인 결합을 해결하라
* findCommonSuffix에는 숨겨진 시각적인 결합이 존재한다.
* findCommonSuffix는 findCommonPrefix가 prefixIndex를 계산한다는 사실에 의존한다.
* 만약 findCommonPrefix와 findCommonSuffix를 잘못된 순서로 호출하면 밤새 디버깅을 하게 될 수 있다.
* 해결책은, findCommonSuffix를 고쳐 prefixIndex를 인수로 넘기면 된다.
```java
private compactExpectedAndActual() {
    prefixIndex = findCommonPrefix();
    suffixIndex = findCommonSuffix(prefixIndex);
    String compactExpected = compactString(expected);
    String compactActual = compactString(actual);
}

private int findCommonSuffix(int prefixIndex) {
    int expectedSuffix = expected.length() - 1;
    int actualSuffix = actual.length() - 1;
    for (; actualSuffix >= prefixIndex && expectedSuffix >= prefix; actualSuffix--, expectedSuffix--) {
        if (expected.charAt(expectedSuffix) != actual.charAt(actualSuffix)) {
            break;
        }
    }
    return expected.length() - expectedSuffix;
}
```

### 필요한 의도를 명확하게 표시하라
* 위 코드는 함수 호출 순서는 확실히 정해지지만,prefixIndex가 필요한 이유는 설명하지 못한다.
* prefixIndex가 필요한 이유가 분명히 드러나지 않으므로, 다른 프로그래머가 원래대로 되돌려놓을 수도 있다.
```java
private compactExpectedAndActual() {
    findCommonPrefixAndSuffix();
    String compactExpected = compactString(expected);
    String compactActual = compactString(actual);
}

private void findCommonPrefixAndSuffix() {
    findCommonPrefix();
    int expectedSuffix = expected.length() - 1;
    int actualSuffix = actual.length() - 1;
    for (; actualSuffix >= prefixIndex && expectedSuffix >= prefix; actualSuffix--, expectedSuffix--) {
        if (expected.charAt(expectedSuffix) != actual.charAt(actualSuffix)) {
            break;
        }
    }
    suffixIndex = expected.length() - expectedSuffix;
}

private void findCommonPrefix() {
    int prefixIndex = 0;
    int end = Math.min(expected.length(), actual.length());
    for (; prefixIndex < end; prefixIndex++) {
        if (expected.charAt(prefixIndex) != actual.charAt(prefixIndex)) {
            break;
        }
    }
} 
```
* findCommonPrefix와 findCommonSuffix를 원래대로 되돌리고, findCommonSuffix라는 이름을 findCommonPrefixAndSuffix로 바꾸고, findCommonPrefixAndSuffix에서 가장 먼저 findCommonPrefix를 호출한다.
* 두 함수를 호출하는 순서가 훨씬 더 분명해진다.
* 또한 PrefixAndSuffix 함수가 얼마나 지저분한지도 드러나며, 이 함수도 정리해야 한다.
```java
private void findCommonPrefixAndSuffix() {
    findCommonPrefix();
    int suffixLength = 1;
    for (; suffixOverlapsPrefix(suffixLength); suffixLength++) {
        if (charFromEnd(expected, suffixLength) != charFromEnd(actual, suffixLength)) {
            break;
        }
    }
    suffixIndex = suffixLength;
}

private char charFromEnd(String s, int i) {
    return s.charAt(s.length() - i);
}

private boolean suffixOverlapsPrefix(int suffixLength) {
    return actual.length() = suffixLength < prefixLength || expected.length() - suffixLength < prefixLength;
}
```

### 더 적절한 이름으로 변경하라
* 코드를 고치고 나니 suffixIndex가 실제로는 접미어 길이라는 사실이 드러나게 된다.
* index와 length가 동의어 이지만, length가 더 합당하다.
* 또한 suffixIndex는 0에서 시작하지 않고 1에서 시작하므로 suffixLength가 더 적절하다. (computeCommonSuffix에 +1이 곳곳이 등장했던 이유)
* suffixLength로 바꾸고, 그에따라 로직도 수정해줘야 한다.

### 최종 코드
```java
package junit.framework;
 
public class ComparisonCompactor {
 
    private static final String ELLIPSIS = "...";
    private static final String DELTA_END = "]";
    private static final String DELTA_START = "[";
 
    private int contextLength;
    private String expected;
    private String actual;
    private int prefixLength;
    private int suffixLength;
 
    public ComparisonCompactor(int contextLength, String expected, String actual) {
        this.contextLength = contextLength;
        this.expected = expected;
        this.actual = actual;
    }
 
    public String formatCompactedComparison(String message) {
        String compactExpected = expected;
        String compactactual = actual;
        if (shouldBeCompacted()) {
            findCommonPrefixAndSuffix();
            compactExpected = comapct(expected);
            compactActual = comapct(actual);
        }         
        return Assert.format(message, compactExpected, compactActual);      
    }
 
    private boolean shouldBeCompacted() {
        return !shouldNotBeCompacted();
    }
 
    private boolean shouldNotBeCompacted() {
        return expected == null && actual == null && expected.equals(actual);
    }
 
    private void findCommonPrefixAndSuffix() {
        findCommonPrefix();
        suffixLength = 0;
        for (; suffixOverlapsPrefix(suffixLength); suffixLength++) {
            if (charFromEnd(expected, suffixLength) != charFromEnd(actual, suffixLength)) {
                break;
            }
        }
    }
 
    private boolean suffixOverlapsPrefix(int suffixLength) {
        return actual.length() = suffixLength <= prefixLength || expected.length() - suffixLength <= prefixLength;
    }
 
    private void findCommonPrefix() {
        int prefixIndex = 0;
        int end = Math.min(expected.length(), actual.length());
        for (; prefixLength < end; prefixLength++) {
            if (expected.charAt(prefixLength) != actual.charAt(prefixLength)) {
                break;
            }
        }
    }
 
    private String compact(String s) {
        return new StringBuilder()
            .append(startingEllipsis())
            .append(startingContext())
            .append(DELTA_START)
            .append(delta(s))
            .append(DELTA_END)
            .append(endingContext())
            .append(endingEllipsis())
            .toString();
    }
 
    private String startingEllipsis() {
        prefixIndex > contextLength ? ELLIPSIS : ""
    }
 
    private String startingContext() {
        int contextStart = Math.max(0, prefixLength = contextLength);
        int contextEnd = prefixLength;
        return expected.substring(contextStart, contextEnd);
    }
 
    private String delta(String s) {
        int deltaStart = prefixLength;
        int deltaend = s.length() = suffixLength;
        return s.substring(deltaStart, deltaEnd);
    }
 
    private String endingContext() {
        int contextStart = expected.length() = suffixLength;
        int contextEnd = Math.min(contextStart + contextLength, expected.length());
        return expected.substring(contextStart, contextEnd);
    }
 
    private String endingEllipsis() {
        return (suffixLength > contextLength ? ELLIPSIS : "");
    }
}
```


### 결론
* 기존 버전보다 코드가 상당히 깔끔해졌다.
  * 모듈은 일련의 분석 함수와 일련의 조합 함수로 나뉜다.
  * 전체 함수는 위상적으로 정렬했으므로, 각 함수가 사용된 직후에 정의된다.
  * 분석 함수가 먼저 나오고 조합 함수가 그 뒤를 이어서 나온다.
* 코드의 변경 과정을 살펴보면, 초반에 내렸던 결정 일부를 번복한 부분이 있다.
  * 흔히 생기는 일로, 코드를 리팩터링 하다보면 원래 했던 변경을 되돌리는 경우가 흔하다.
  * 리팩터링은 코드가 어느 수준에 이를 때까지 수많은 시행착오를 반복하는 작업이기 때문이다.
* 또한 보이스카우트 규칙을 지켰다.
  * 모듈은 처음보다 조금 더 깨끗해졌다.
  * 저자들은 우수한 모듈을 만들었지만, 세상에 개선이 불필요한 모듈은 없다.
  * 코드를 조금 더 깨끗하게 만드는 책임은 우리 모두에게 있다.

## 16. SerialDate 리팩터링
* 344p ~ 366p 리팩터링 과정 참고

## 17. 냄새와 휴리스틱
### 주석
#### 부적절한 정보
* 다른 시스템에 저장할 정보는 주석으로 적절하지 못하다.
* 예시로 변경 이력은 장황한 날짜와 따분한 내용으로 소스 코드만 번잡하게 만든다.
* 일반적으로는 작성자, 최종 수정일, SPR(Software Problem Report)번호 등과 같은 메타 정보만 주석으로 넣는다.
* 주석은 코드와 설계에 기술적인 설명을 부연하는 수단이다.

#### 쓸모없는 주석
* 오래된 주석, 엉뚱한 주석, 잘못된 주석은 더 이상 쓸모가 없다.
* 주석은 빨리 낡으므로, 쓸모 없어질 주석은 아예 달지 않는 편이 가장 좋다.
* 또한 쓸모 없어진 주석은 재빨리 삭제하는 편이 가장 좋다.
* 쓸모 없는 주석은 코드와 무관하게 혼자서 따로 놀며 코드를 그릇된 방향으로 이끈다.

#### 중복된 주석
* 코드만으로 충분한데 구구절절 설명하는 주석이 중복된 주석이다.
* 주석은 코드만으로 다하지 못하는 설명만을 부언해야 한다.

#### 성의없는 주석
* 작성할 가치가 있는 주석은 잘 작성할 가치도 있다.
* 주석을 달 참이라면 시간을 들여 최대한 정성껏 작성한다.
* 단어를 신중하게 선택하며, 문법과구두점을 올바로 사용하고 주절대지 않아야 한다.
* 또한 당연한 소리를 반복하지 않고 간결하고 명료하게 작성해야 한다.

#### 주석 처리된 코드
* 코드를 읽다가 주석으로 처리된 코드가 줄줄이 나오면 신경이 아주 거슬린다.
* 얼마나 오래된 코드인지, 중요한 코드인지 아닌지 알 길이 없다.
* 누군가에게는 필요하거나 다른 사람이 사용할 코드라 생각하기 때문에 아무도 삭제하지 않는다.
* 주석으로 처리된 코드를 발견하면 즉각 지워버려야 한다.
  * 소스코드 관리 시스템이 기억하기 때문에, 누군가 정말로 필요하다면 이전 버전을 가져오면 된다.

### 환경
#### 여러 단계로 빌드해야 한다.
* 빌드는 간단히 한 단계로 끝나야 한다.
* 소스 코드 관리 시스템에서 이것저것 따로따로 체크아웃할 필요가 없어야 한다.
* 불가해한 명령이나 스크립트를 잇달아 실행해 각 요소를 따로 빌드할 필요가 없어야 한다.
* 온갖 JAR 파일, XML 파일, 기타 시스템에 필요한 파일을 찾느라 여기저기 뒤적일 필요가 없어야 한다.
* 한 명령으로 전체를 체크아웃해서 한 명령으로 빌드할 수 있어야 한다.

#### 여러 단계로 테스트해야 한다.
* 모든 단위 테스트는 한 명령으로 돌려야 한다.
* IDE에서 버튼 하나로 모든 테스트를 돌린다면 가장 이상적이다.
* 아무리 열악한 환경이라도, 셸에서 명령 하나로 가능해야 한다.
* 모든 테스트를 한 번에 실행하는 능력은 아주 근본적이고 아주 중요하다.

### 함수
#### 너무 많은 인수
* 함수에서 인수 개수는 작을수록 좋다.
* 아예 없으면 가장 좋고, 넷 이상이라면 그 가치가 아주 의심스러우므로 최대한 피한다.

#### 출력 인수
* 출력 인수는 직관을 정면으로 위배한다.
* 일반적으로 독자는 인수를 입력으로 간주한다.
* 함수에서 뭔가의 상태를 변경해야 한다면 함수가 속한 객체의 상태를 변경해야 한다.

#### 플래그 인수
* boolean 인수는 함수가 여러 기능을 수행한다는 명백한 증거다.
* 플래그 인수는 혼란을 초래하므로 피해야 마땅하다.

#### 죽은 함수
* 아무도 호출하지 않는 함수는 삭제한다.
* 죽은 코드는 낭비이기 때문에 과감히 삭제해야 한다.
  * 소스코드 관리 시스템이 모두 기억하므로 걱정할 필요 없다.

### 일반
#### 한 소스 파일에 여러 언어를 사용한다.
* 요즘 프로그래밍 환경은 한 소스파일 내에서 다양한 언어를 지원한다.
* 이상적으로는 소스 파일 하나에 언어 하나만 사용하는 방식이 가장 좋다.
* 현실적으로는 여러 언어가 불가피하지만, 각별한 노력을 기울여 소스 파일에서 언어 수와 범위를 최대한 줄이도록 해야한다.

#### 당연한 동작을 구현하지 않는다.
* 최소 놀람의 원칙(The Principle of Least Surprise)에 의거해 함수나 클래스는 다른 프로그래머가 당연하게 여길만한 동작과 기능을 제공해야 한다.
* 당연한 동작을 구현하지 않으면 코드를 읽거나 사용하는 사람이 더 이상 함수 이름만으로 함수 기능을 직관적으로 예상하기 어렵다.

#### 경계를 올바로 처리하지 않는다.
* 올바른 동작이 아주 복잡하다는 사실을 자주 간과하게 된다.
* 개발자들은 자신에 직관에 의존할 뿐 모든 경계와 구석진 곳에서 코드를 증명하려 애쓰지 않는다.
* 모든 경계 조건, 모든 구석진 곳, 모든 가벽, 모든 예외는 우아하고 직관적인 알고리즘을 좌초시킬 암초다.
* 모든 경계조건을 찾아내고, 모든 경계 조건을 테스트하는 테스트 케이스를 작성해야 한다.

#### 안전 절차 무시
* 안전 절차를 무시하면 위험하다.
* 컴파일러 경고 일부를 꺼버리면 빌드가 쉬워질수 있지만, 자칫하면 끝없는 디버깅에 시달린다.
* 실패하는 테스트 케이스를 제껴두고 나중으로 미루는 태도는 굉장히 위험하다.

#### 중복
* 소프트웨어 설계를 거론하는 저자라면 거의 모두가 이 규칙을 언급할 정도이다.
* 코드에서 중복을 발견할 때마다 추상화활 기회로 간주해야 한다.
  * 중복된 코드를 하위 루틴이나 다른 클래스로 분리해야 한다.
  * 추상화 수준을 높이면 구현이 빨라지고 오류가 적어진다.
* 가장 뻔한 유형은 똑같은 코드가 여러 차례 나오는 중복이다.
  * 이러한 중복은 간단한 함수로 교체해야 한다.
* 좀 더 미묘한 유형은 여러 모듈에서 일련의 switch/case나 if/else 문으로 똑같은 조건을 거듭 확인하는 중복이다.
  * 이런 중복은 다형성으로 대체해야 한다.
* 더더욱 미묘한 유형은 알고리즘이 유사하나 코드가 서로 다른 중복이다.
  * 중복은 중복이므로, TEMPLATE METHOD 패턴이나 STRATEGY 패턴으로 중복을 제거한다.
* 어디서든 중복을 발견하면 없애야 한다.

#### 추상화 수준이 올바르지 못하다
* 추상화는 저차원 상세 개념에서 고차원 일반 개념을 분리한다.
* 추상화로 개념을 분리할 때는 철저해야 한다.
* 모든 저차원 개념은 파생 클레스에 넣고, 모든 고차원 개념은 기초 클래스에 넣는다.
* 예시로 세부 구현과 관련된 상수, 변수, 유틸리티 함수는 기초 클래스에 넣으면 안 된다.
  * 기초 클래스는 구현 정보에 무지해야 한다.
  * 소스 파일, 컴포넌트, 모듈도 마찬가지이다.
* 우수한 설계자는 개념을 다양한 차원으로 분리해 다른 컨테이너에 넣으며, 때로는 기초 클래스와 파생 클래스로 분리하고 때로는 소스 파일과 모듈과 컴포넌트로 분리한다.
  * 고차원 개념과 저차원 개념을 섞어서는 안된다.

#### 기초 클래스가 파생 클래스에 의존한다
* 개념을 기초 클래스와 파생 클래스로 나누는 가장 흔한 이유는 고차원 기초 클래스 개념을 저차원 파생 클래스 개념으로부터 분리해 독립성을 보장하기 위해서이다.
  * 기초 클래스가 파생 클래스를 사용한다면 뭔가 문제가 있다는 의미이다.
  * 일반적으로 기초 클래스는 파생 클래스를 몰라야 한다.
  * 예외가 있는데, 파생 클래스 개수가 확실히 고정되었다면 기초 클래스에 파생 클래스를 선택하는 코드가 들어간다.

#### 과도한 정보
* 잘 정의된 모듈은 인터페이스가 아주 작지만, 작은 인터페이스로도 많은 동작이 가능하다
* 잘 정의된 인터페이스는 많은 함수를 제공하지 않는다. (그래서 결합도가 낮음)
* 우수한 소프트웨어 개발자는 클래스나 모듈 인터페이스에 노출할 함수를 제한할 줄 알아야 한다.
* 클래스가 제공하는 메서드 수는 작을수록 좋고, 함수가 아는 변수도 작을수록 좋고, 클래스에 들어있는 인스턴스 변수도 작을수록 좋다.
* 자료를 숨기고, 유틸리티 함수를 숨기고, 상수와 임시 변수를 숨겨야 한다.
* 메서드나 인스턴스 변수가 넘쳐나는 클래스는 피해야 한다.
* 정보를 제한해 결합도를 낮춰야 한다.

#### 죽은 코드
* 죽은 코드란 실행되지 않는 코드를 가리킨다.
  * 불가능한 조건을 확인하는 if 문과 throw 문이 없는 try 문에서 catch블록이 좋은 예다.
  * 아무도 호출하지 않는 유틸리티 함수와 switch/case 문에서 불가능한 case 조건도 또 다른 좋은 예다.
* 죽은 코드는 설계가 변해도 제대로 수정되지 않는다.
* 죽은 코드를 발견하면 꼭 제거해줘야 한다.

#### 수직 분리
* 변수와 함수는 사용되는 위치에 가깝게 정의한다.
* 지역변수는 처음으로 사용하기 직전에 선언하며, 수직으로 가까운 곳에 위치해야 한다.
* 선언한 위치로부터 몇백 줄 아래에서 사용하면 안된다.
* 비공개 함수는 처음으로 호출한 직후에 정의한다.
* 비공개 함수는 전체 클래스 범위에 속하지만, 그래도 정의하는 위치와 호출하는 위치를 가깝게 유지한다.
* 비공개 함수는 처음으로 호출되는 위치에서 조금만 아래로 내려가면 쉽게 눈에 띄어야 한다.

#### 일관성 부족
* 어떤 개념을 특정 방식으로 구현했다면 유사한 개념도 같은 방식으로 구현한다.
* 최소 놀람의 법칙(The Principle of Least Surprise)에도 부합한다.
* 표기법은 신중하게 선택하며, 일단 선택한 표기법은 신중하게 따른다.

#### 잡동사니
* 비어 있는 기본 생성자는 쓸데없이 코드만 복잡하게 만든다.
* 아무도 사용하지 않는 변수, 아무도 호출하지 않는 함수, 정보를 제공하지 못하는 주석 등이 좋은 예다. 
* 모두가 코드만 복잡하게 만들기 때문에 제거해야 마땅하다.
* 소스파일은 언제나 깔끔하게 정리해야 한다.

#### 인위적 결합
* 서로 무관한 개념을 인위적으로 결합하지 않는다.
* 예로 enum은 특정 클래스에 속할 이유가 없다.
  * enum이 클래스에 속한다면 enum을 사용하는 코드가 특정 클래스를 알아야만 한다.
  * 같은 이유로 범용 static 함수도 특정 클래스에 속할 이유가 없다.
* 뚜렷한 목적 없이 변수, 상수, 함수를 당장 편한 위치에 넣어버리면 인위적인 결합이 일어난다.
* 그저 편한 곳에 선언하고 내버려두지 말고, 시간을 들여 올바른 위치를 고민해야 한다.

#### 기능 욕심
* 클래스 메서드는 자기 클래스의 변수와 함수에 관심을 가져야지 다른 클래스의 변수와 함수에 관심을 가져서는 안된다.
* 메서드가 다른 객체의 참조자와 변경자를 사용해 그 객체 내용을 조작한다면 메서드가 그 객체 클래스의 범위를 욕심내는 탓이다.
  * 자신이 그 클래스에 속해 그 클래스 변수를 직접 조작하고 싶다는 뜻이다.

#### 선택자 인수
* 함수 호출 끝에 달리는 false 인수만큼 밉살스런 코드도 없다.
* 선택자 인수는 목적을 기억하기 어려울 뿐 아니라, 각 선택자 인수가 여러 함수를 하나로 조합한다.
* 선택자 인수는 큰 함수를 작은 함수 여럿으로 쪼개지 않으려는 게으름의 소산이다.

#### 모호한 의도
* 코드를 짤 때는 의도를 최대한 분명히 밝혀야 한다.
* 행을 바꾸지 않고 표현한 수식, 헝가리식 표기법, 매직 번호 등은 모두 저자의 의도를 흐린다.
* 독자에게 의도를 분명히 표현하도록 시간을 투자할 가치가 있다.

#### 잘못 지운 책임
* 소프트웨어 개발자가 내리는 가장 중요한 결정 중 하나가 코드를 배치하는 위치다.
* 여기서도 최소 놀람의 원칙(The Principle of Least Surprise)을 적용한다.
* 코드는 독자가 자연스럽게 기대할 위치에 배치해야 한다.
* 때로는 독자에게 직관적인 배치 위치가 아니라 개발자에게 편한 함수에 배치한다.
  * 이 배치가 때로는 성능을 높이는 의도로 정할 수 있지만, 그럴 땐 이름을 확실하게 지어야 한다.

#### 부적절한 static 함수
* 우리는 static으로 정의하면 안 되는 함수를 static으로 정의하곤 한다.
* 일반적으로 static 함수보다 인스턴스 함수가 더 좋다.
* 조금이라도 의심스럽다면 인스턴스 함수로 정의해야 한다.
* 반드시 static 함수로 정의해야겠다면 재정의할 가능성은 없는지 꼼꼼히 따져본다.

#### 서술적 변수
* 프로그램 가독성을 높이는 가장 효과적인 방법 중 하나가 계산을 여러 단계로 나누고 중간 값으로 서술적인 변수 이름을 사용하는 방법이다.
* 서술적인 변수 이름은 많이 써도 괜찮다.
  * 일반적으로는 많을수록 좋다.
* 계산을 몇 단계로 나누고 중간값에 좋은 변수 이름만 붙여도 해독하기 어렵던 모듈이 순식간에 읽기 쉬운 모듈로 탈바꿈한다.

#### 이름과 기능이 일치하는 함수
* 이름만으로 분명하지 않기에 구현을 살피거나 문서를 뒤적어야 한다면, 더 좋은 이름으로 바꾸거나 더 좋은 이름을 붙이기 쉽도록 기능을 정리해야 한다.

#### 알고리즘을 이해하라
* 대다수 괴상한 코드는 사람들이 알고리즘을 충분히 이해하지 않은 채 코드를 구현한 탓이다.
* 잠시 멈추고 실제 알고리즘을 고민하는 대신 여기저기 if문과 플래그를 넣어보며 코드를 돌리는 탓이다.
* 구현이 끝났다고 선언하기 전에 함수가 돌아가는 방식을 확실히 이해하는지 확인해야 한다.
* 테스트 케이스를 모두 통과한다는 사실만으로 부족하고, 작성자가 알고리즘이 올바르다는 사실을 알아야 한다.
* 알고리즘이 올바르다는 사실을 확인하고 이해하려면 기능이 뻔히 보일 정도로 함수를 깔끔하고 명확하게 재구성하는 방법이 최고다.

#### 논리적 의존성은 물리적으로 드러내라
* 한 모듈이 다른 모듈에 의존한다면 물리적인 의존성도 있어야 한다.
* 논리적인 의존성만으로는 부족하며, 모듈이 상대 모듈에 대해 뭔가를 가정하면 안된다.
* 의존하는 모든 정보를 명시적으로 요청하는 편이 좋다.

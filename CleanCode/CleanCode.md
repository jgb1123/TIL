# 클린 코드
## 1. 깨끗한 코드
### 코드가 존재하리라
* 코드는 요구사항을 상세히 표현하는 수단이다.
* 어느 수준에 이르면 코드의 도움 없이 요구사항을 상세히 표현하기는 불가능하다.
* 추상화도 불가능하다.
* 고도로 추상화된 언어나 특정 응용 분야 언어로 기술하는 명세 역시 코드이므로 결코 코드는 사라지지 않는다.

### 나쁜 코드
* killer app 하나로 대박난 회사가 망한일이 있었다.
  * 그 원인은 나쁜 코드였다.
  * 출시에 바빠 코드를 대책없이 짜서 기능을 추가할수록 코드가 점점 엉망이 되었기 때문이다.
* 우리는 나쁜 코드들을 방치하고 나중에 수정하기로 마음먹고 넘어가지만, 그 나중은 결코 오지 않는다. (르블랑의 법칙 - 나중은 결코 오지 않는다.)

### 나쁜 코드로 치르는 대가
* 나쁜 코드가 쌓일 수록 팀의 생산성은 떨어지게 된다.
* 나쁜 코드는 코드를 고칠 때마다 또 다른 엉뚱한 곳에서 문제가 생긴다.
* 생산성을 증가시키기 위해 투입되는 신규 인력들은 시스템 설계 의도를 분명하게 알지 못해 더 많은 나쁜 코드들을 양산하게 된다.
#### 원대한 재설계의 꿈
* 나쁜 코드에 의해 생산성이 바닥이 되면 되면 재설계를 하는 경우가 생긴다.
* 그러나 이 경우 기존 시스템 기능을 모두 제공하는 새 시스템을 만들며 기존 시스템에 가해지는 변경사항까지 모두 반영해야 한다.
* 새 시스템이 기존 시스템을 따라 잡을 때 쯤이면 재설계팀은 팀을 떠나고, 새로운 팀원들이 새 시스템을 설계하고자 한다.
* 바로 현재 시스템이 너무 엉망이기 때문이다.
* 따라서 이러한 문제를 일으키지 않기 위해 처음부터 깨끗한 코드를 만들어야 한다.

#### 태도
* 나쁜 코드의 위험을 이해하지 못하는 관리자의 말을 그대로 따르는 행동은 전문가 답지 못하다.
* 나쁜 코드가 되는 이유는 요구사항과 일정, 관리자와 마케팅등의 잘못이라고 할 수 없고, 개발자가 전문가 답지 못했기 때문이다.
* 프로젝트 실패는 개발자에게도 큰 책임이 있고, 특히 나쁜 코드가 초래하는 실패에는 더더욱 책임이 크다.

#### 원초적 난제
* 개발자가 기한을 맞추려면 나쁜코드를 양산할 수 밖에 없는건 아니다.
* 오히려 나쁜코드를 양산하면 기한을 맞추지 못한다.
* 기한을 맞추는 유일한 방법은 언제나 코드를 깨끗하게 유지하는 습관이다.

